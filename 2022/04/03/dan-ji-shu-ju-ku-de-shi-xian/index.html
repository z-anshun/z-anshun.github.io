<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="单机数据库的实现, 面条二两">
    <meta name="description" content="nothing">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>单机数据库的实现 | Noodles2hg的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Noodles2hg的博客" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Noodles2hg的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Noodles2hg的博客</div>
        <div class="logo-desc">
            
            nothing
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/10.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">单机数据库的实现</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/books/">
                                <span class="chip bg-color">books</span>
                            </a>
                        
                            <a href="/tags/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">
                                <span class="chip bg-color">redis设计与实现</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/redis/" class="post-category">
                                redis
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-04-03
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h2><p>Redis 服务器将所有数据库都保存在服务器状态 redis.h/redisServer 结构的 db 数组中，db 数组的每一个项都是一个 redis.h/redisDb 结构</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span><span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token comment">// 一个数组，保存服务器中的所有数据库</span>
    redisDb <span class="token operator">*</span>db<span class="token punctuation">;</span>
    <span class="token comment">// 根据dbnum来创建多少个数据库，默认为16</span>
    <span class="token keyword">int</span> dbnum<span class="token punctuation">;</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>如何切换数据库？</p>
</blockquote>
<p>默认情况下，客户端的目标数据库为0号数据库，客户端可以使用 SELECT 来切换目标数据库</p>
<p>如：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis&gt; SER msg "hello world"
OK
redis&gt; GET msg
"hello world"
redis&gt; SELECT 2
OK
redis[2]&gt; GET msg
(nil)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而在服务器内部，客户端状态 redisClient 结构的db记录当前的目标数据库，其为一个redisDb的指针</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span><span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token comment">// 记录当前客户端正在使用的数据库</span>
    redisDb <span class="token operator">*</span>db<span class="token punctuation">;</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span>redisClient<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h2><p>Redis 是一个键值对（key-value pair）数据库服务器，服务器中的每个数据库都由一个 redis.h/redisDb 结构表示，而其中的 dict 字典就保存了数据库中的所有键值对，这个字典也被称为了键空间</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span><span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    
    <span class="token comment">// 数据库的键空间，保存着所有键值对</span>
    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>
    
    <span class="token comment">//...</span>
<span class="token punctuation">}</span>redisDb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>键空间的key就是一个字符串对象，值就是可以是Redis中的任意一种对象</p>
<p>有因为键空间为一个字典，所有针对数据库的CRUD操作，实际上都是通过键空间来实现的</p>
<blockquote>
<p>对键空间读写还有其它维护操作？肯定不止CRUD、还有同步和检查等</p>
</blockquote>
<ul>
<li>在读取一个键之后（即读和写操作），服务器都会根据键是否存在来更新服务的键空间命中（hit）次数和不命中（miss）次数（可以使用 INFO stats 命令的 keyspace_hits 属性和 keyspace_misses 属性）</li>
<li>服务器还会更新键的 LRU 时间（使用 OBJECT idletime <key> 命令查看）</key></li>
<li>如果发现该键已经过期，那么服务器会先删除这个过期键</li>
<li>如果有客户端使用了 WATCH 命令监视了某个键，那么服务器在对被监视的键进行修改后，会将这个键标记为脏 （dirty），进而让事务注意到这个键已经被修改</li>
<li>每修改一个键后，都会对脏（dirty）键计数器的值+1，这个计数器会触发服务器的持久化以及复杂操作</li>
<li>如果服务器开启了数据库通知功能，那么在对键进行修改后，服务器会将配置发送相应的数据库通知</li>
</ul>
<blockquote>
<p>如何设置过期时间？</p>
</blockquote>
<ul>
<li><code>EXPIRE &lt;key&gt; &lt;ttl&gt;</code>：将key的生存时间设置为 ttl s</li>
<li><code>PEXPIRE &lt;key&gt; &lt;ttl&gt;</code>：生存时间设置为ttl ms</li>
<li><code>EXPIREAT &lt;key&gt; &lt;timestamp&gt;</code>：将key的过期时间设置为 timestamp 所指定的秒数时间戳</li>
<li><code>PEXPIREAT &lt;key&gt; &lt;timestamp&gt;</code>：设置为 timestamp 所指定的毫秒数时间搓</li>
</ul>
<p>虽然上面有四种设置，实际都是使用 PEXPIREAT 实现的</p>
<p>比如：EXPIRE</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">EXPIRE</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>ttl_in_sec<span class="token punctuation">)</span><span class="token punctuation">:</span>
    ttl_in_ms<span class="token operator">=</span>set_to_ms<span class="token punctuation">(</span>ttl_in_sec<span class="token punctuation">)</span>
    PEXPIRE<span class="token punctuation">(</span>key<span class="token punctuation">,</span>ttl_in_ms<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">PEXPIRE</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>ttl_in_ms<span class="token punctuation">)</span><span class="token punctuation">:</span>
    now_ms<span class="token operator">=</span>get_current_unix_timestamp_in_ms<span class="token punctuation">(</span><span class="token punctuation">)</span>
    PEXPIREAT<span class="token punctuation">(</span>key<span class="token punctuation">,</span>now_ms<span class="token operator">+</span>ttl_in_ms<span class="token punctuation">)</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>如何保存过期时间？</p>
</blockquote>
<p>redisDb 结构的 expires 字典<strong>保存了数据库中所有键</strong>的过期时间，这个字典也被称为 过期字典</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span><span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    
    <span class="token comment">// 过期字典，保存着键的过期时间</span>
    <span class="token comment">// 键为一个对象，实际中会与键空间的键指向同一个地方</span>
    <span class="token comment">// 值为 long long 类型的整数，一个毫秒精度的 UNIX 时间戳</span>
    dict <span class="token operator">*</span>expires<span class="token punctuation">;</span>
    
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>redisDb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>如何移除过期时间？</p>
</blockquote>
<p>PERSIST 可以移除一个键的过期时间</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis&gt; PEXPIREAT message 1391234400000
(integer) 1
redis&gt; TTL message
(integer) 13893281
redis&gt; PERSIST message
(integer) 1
redis&gt; TTL message
(integer) -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>过期键如何判定？</p>
</blockquote>
<ol>
<li>检查给定键是否存在于过期字典；如果存在，那么就会取得键的过期时间</li>
<li>检查当前 UNIX 时间戳是否大于键的过期时间；如果是的，那么键就过期，反之就未过期</li>
</ol>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">is_expired</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>
    expire_time_in_ms<span class="token operator">=</span>redisDb<span class="token punctuation">.</span>expires<span class="token punctuation">.</span>get<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    
    <span class="token keyword">if</span> expire_time_in_ms <span class="token keyword">in</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
    now_ms<span class="token operator">=</span>get_current_unix_timestamp_in_ms<span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    <span class="token keyword">if</span> now_ms <span class="token operator">&gt;</span> expire_time_in_ms<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><p>一共有三种不同的删除策略：</p>
<ul>
<li>定时删除：设置键的过期时间的同时，创建一个定时器（timer）。</li>
<li>惰性删除：放任键过期不管，每次从键空间获取值时，再去过期字典查询是否过期</li>
<li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。</li>
</ul>
<p>定时和定期删除都是主动删除，而惰性都是被动删除</p>
<p>定时删除对内存友好，但是对CPU不友好，当过期键比较多的时候，就会抢CPU资源。并且，创建一个timer需要用到 Redis 服务器种的时间事件，其实现方式为 无序链表，因此查找一个事件的时间复杂度为O(N)，并不能高效</p>
<p>惰性删除对 CPU 友好，但对内存不友好，过期的键，只要不被访问，就会一直占用着内存</p>
<p>定时删除相当于一个折中的策略，但其难点在于删除执行的时长和频率</p>
<h2 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h2><p>redis 服务器实际上使用 惰性删除和定期删除 两种策略；通过两种删除策略配合，服务器就可以很好的合理使用CPU 时间和避免浪费内存空间之间取得了平衡</p>
<p>惰性删除：redis的db.c/expireIfNeeded函数实现了惰性删除，即如果过期就删除，反之就不执行任何操作</p>
<p>定期删除：由 redis.c/activeExpireCycle 函数实现，每当 Redis 的服务器周期性操作 redis.c/serverCron 函数执行时，都会调用 activeExpireCycle 函数，其在规定时间内，分多次遍历服务器中的各个数据库，从数据库的 expires 字典中随机检查一部分键的过期时间，并删除</p>
<h2 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h2><ul>
<li>RDB文件：<ul>
<li>生成时：执行 SAVE 或者 BGSAVE 时，程序会对数据库中的键进行检查，如果过期，就不会放入RDB,即过期键并不会对 RDB 文件造成影响</li>
<li>载入时：如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查；如果以从服务器模式运行，那么就会全部都载入，不管过不过期。因为主从服务器同步时，从数据库都会被清空</li>
</ul>
</li>
<li>AOF文件：<ul>
<li>写入时：如果键未被查找到删除，就会动AOF文件。如果键被惰性或者定时删除了，也只会在AOF文件追加（append）一条DEL命令</li>
<li>重写时：在AOF重写时，跟RDB文件生成时类似，会对数据的键进行检查，已过期的就不会保存到重写后的AOF文件中</li>
</ul>
</li>
<li>复制：当服务器运行在复制模式下的时候，从服务器的删除由主服务器控制，即，主服务器在删除一个过期键后，会向从服务器发送一个del；而在从服务器读到一个过期键时，也不会有惰性删除。这样就也就主服务器控制了删除，保证了主从的一致性问题</li>
</ul>
<h2 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h2><p>为 Redis 2.8 新增加的功能，可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化</p>
<p>分为两种</p>
<ul>
<li>键空间通知（key-space notification）：某个键执行了什么命令，主要监听的键</li>
<li>键事件通知（key-event notification）：某个命令被什么键执行，主要监听的某个命令</li>
</ul>
<blockquote>
<p>如何发送数据库通知？</p>
</blockquote>
<p>由 notify.c/notifyKeyspaceEvent 函数实现</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">notifyKeyspaceEvent</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>event<span class="token punctuation">,</span>robj <span class="token operator">*</span>key<span class="token punctuation">,</span><span class="token keyword">int</span> dbid<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>type：当前想发送通知的类型，程序根据这个值来判断通知是否为服务器配置 notify-keyspace-events 选项所选定的通知</li>
<li>event：事件的名称</li>
<li>keys：产生事件的键</li>
<li>dbid：数据库号码</li>
</ul>
<p>如：SADD 命令的一段代码</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">saddCommand</span><span class="token punctuation">(</span>redisClient <span class="token operator">*</span>c<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    
    <span class="token comment">// 如果至少有一个元素被添加成功，</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>added<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//...</span>
        <span class="token comment">// REDIS_NOTIFY_SET 表明这是一个集合键的通知</span>
        <span class="token comment">// ”sadd" 表明这是 SADD 命令所产生的</span>
        <span class="token function">notifykeyspaceEvent</span><span class="token punctuation">(</span>REDIS_NOTIFY_SET<span class="token punctuation">,</span><span class="token string">"sadd"</span><span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>argvp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>db<span class="token operator">-&gt;</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">//...</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再如：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">delCommand</span><span class="token punctuation">(</span>redisClient <span class="token operator">*</span>c<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> deleted<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">,</span> j<span class="token punctuation">;</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>c<span class="token operator">-&gt;</span>argc<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 尝试删除</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dbDelete</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>db<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//...</span>
            
            <span class="token comment">// 删除键成功，发送通知</span>
            <span class="token function">notifyKeyspaceEvent</span><span class="token punctuation">(</span>REDIS_NOTIFY_GENERIC<span class="token punctuation">,</span><span class="token string">"del"</span><span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>agrv<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>db<span class="token operator">-&gt;</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            <span class="token comment">//...</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>notifyKeyspaceEvent 函数的伪代码实现：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">notifyKeyspaceEvent</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">,</span>event<span class="token punctuation">,</span>key<span class="token punctuation">,</span>dbid<span class="token punctuation">)</span><span class="token punctuation">:</span>
    
    <span class="token comment"># 不是服务器允许发送的通知</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>notify_keyspace_events <span class="token operator">&amp;</span> <span class="token builtin">type</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    <span class="token comment"># 键空间通知</span>
    <span class="token keyword">if</span> server<span class="token punctuation">.</span>notify_keyspace_events <span class="token operator">&amp;</span> REDIS_NOTIFY_KEYSPACE<span class="token punctuation">:</span>
        
        <span class="token comment"># 将通知发送给频道 __keyspace@&lt;dbid&gt;__:&lt;key&gt;</span>
        <span class="token comment"># 内容为键所发生的事件 &lt;event&gt;</span>
        
        <span class="token comment"># 构建频道名字</span>
        chan<span class="token operator">=</span><span class="token string">"__keyspace@{dbid}__:{key}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">{</span>dbid<span class="token operator">=</span>dbid<span class="token punctuation">,</span>key<span class="token operator">=</span>key<span class="token punctuation">}</span>
        
        <span class="token comment"># 发送消息</span>
        pubsubPublishMessage<span class="token punctuation">(</span>chan<span class="token punctuation">,</span>event<span class="token punctuation">)</span>
    <span class="token comment"># 键事件通知</span>
    <span class="token keyword">if</span> server<span class="token punctuation">.</span>notify_keyspace_events <span class="token operator">&amp;</span> REDIS_NOTIFY_KEYEVENT<span class="token punctuation">:</span>
        <span class="token comment"># 将通知发送给频道 __keyspace@&lt;dbid&gt;__:&lt;event&gt;</span>
        <span class="token comment"># 内容为键所发生的事件 &lt;key&gt;</span>
        
        <span class="token comment"># 构建频道名字</span>
        chan<span class="token operator">=</span><span class="token string">"__keyevent@{dbid}__:{event}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">{</span>dbid<span class="token operator">=</span>dbid<span class="token punctuation">,</span>event<span class="token operator">=</span>event<span class="token punctuation">}</span>
        
        pubsubPublishMessage<span class="token punctuation">(</span>chan<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h1><p>因为 Redis 为内存数据库，将自己的数据库状态存储在内存中，需要将其保存进磁盘，否则一旦进程退出，就没了</p>
<p>RDB持久化既可以手动执行，也可以根据服务器的配置定期执行，将某个时间点上的数据库状态保存到一个RDB文件中。</p>
<p>其实，RDB持久化功能生成的RDB文件是一个经过压缩的为一个二进制文件，该文件可以还原生成对应的数据库状态</p>
<h2 id="RDB-文件的创建与载入"><a href="#RDB-文件的创建与载入" class="headerlink" title="RDB 文件的创建与载入"></a>RDB 文件的创建与载入</h2><p>SAVE和BGSAVE 都能生成 RDB 文件 </p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis&gt; SAVE  # 等待，直到RDB文件创建完
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis&gt; BGSAVE  # 派生子程序，并由子程序创建RDB文件
Background saving started<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>伪代码实现，rbdSave函数为创建 RDB 文件的实际工作</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">SAVE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 创建RDB 文件</span>
    rdbSave<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">BGSAVE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    
    <span class="token comment"># 创建子进程</span>
    pid<span class="token operator">=</span>fork<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> pid<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
        rdbSave<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment"># 完成之后向父进程发送信号</span>
        signal_parent<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span> pid<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token comment"># 父进程继续处理命令，并轮询等待子进程的信号</span>
        handle_request_and_wait_signal<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token comment"># 处理出错情况</span>
        handle_fork_error<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>跟使用 SAVE和BGSAVE 创建 RDB 文件不同，RDB的载入是在服务启动时，自己执行的。因此并没用专门用于载入 RDB 文件的命令</p>
<p>注意：因为AOF文件的更新频率通常比RDB文件更高，因此如果服务器开启了AOF持久化，就会优选选择AOF，只有当其关闭时，才会使用RDB</p>
<blockquote>
<p>SAVE执行时，服务器的命令会被执行嘛？</p>
</blockquote>
<p>不能，因为当前服务器为阻塞的，是直接拒绝，只有当SAVE执行完后，才能重新请求</p>
<blockquote>
<p>BGSAVE执行时，SAVE、BGSAVE和BGREWRITEAOF三个命令和平时有什么不同？</p>
</blockquote>
<p>SAVE和BGSAVE会直接被拒绝，而 BGREWRITEAOF 命令会延迟到 BGSAVE 执行完后才执行。另外，如果 BGREWRITEAOF 正在执行， BGSAVE命令会被直接拒绝。虽然 BGSAVE和BGREWRITEAOF 在操作方面并没用什么冲突，它们两个不能同时执行是出于性能考虑，两个子进程同时执行大量的磁盘写入操作不是一个好主意</p>
<blockquote>
<p>RDB 载入时，会阻塞嘛？</p>
</blockquote>
<p>会，服务器在载入 RDB 文件时，会一直处于阻塞状态</p>
<h2 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h2><p>很明显，SAVE和BGSAVE的区别就是在于是否阻塞当前进程，因此，Redis允许用户配置每隔一段时间执行 BGSAVE</p>
<p>用户可以设置多个保存选项，只要其中一个被满足，服务器就会执行 BGSAVE</p>
<p>如，</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">save 900 1
save 300 10
save 60 10000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>那么，满足以下某一个，就会执行：</p>
<ul>
<li>服务器就900s以内至少执行了一次修改</li>
<li>300内，至少执行了一次修改</li>
<li>60秒内，至少执行了10000次修改</li>
</ul>
<blockquote>
<p>如何实现的设置保存条件？</p>
</blockquote>
<p>首先，当用户没主动设置时，会设置默认条件，即：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">save 900 1
save 300 10
save 60 10000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>而在代码层，服务器状态 redisServer 结构的 saveparams 属性会记录这个</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span><span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    
    <span class="token comment">// 记录保存条件的数组</span>
    <span class="token keyword">struct</span> <span class="token class-name">saveparam</span> <span class="token operator">*</span>saveparams<span class="token punctuation">;</span>
    
    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">saveparam</span><span class="token punctuation">{</span>
    <span class="token comment">// 秒数</span>
    time_t seconds<span class="token punctuation">;</span>
    <span class="token comment">// 修改数</span>
    <span class="token keyword">int</span> changes<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="dirty-计数器和-lastsave-属性"><a href="#dirty-计数器和-lastsave-属性" class="headerlink" title="dirty 计数器和 lastsave 属性"></a>dirty 计数器和 lastsave 属性</h3><ul>
<li>dirty 计数器记录上一次成功执行 SAVE 或者 BGSAVE 服务器对数据库状态进行了多少次修改（写入、删除、更改等）</li>
<li>lastsave 为一个时间戳，记录上一次 SAVE 或者 BGSAVE 的执行时间</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span><span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    
    <span class="token keyword">long</span> <span class="token keyword">long</span> dirty<span class="token punctuation">;</span>
    time_t 	lastsave<span class="token punctuation">;</span>
    
    <span class="token comment">//...</span>
 
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>定期 BGSAVE 时，怎么进行判断条件满足的？</p>
</blockquote>
<p>Redis的周期性操作函数 serverCron 默认为100ms执行一次，该函数就会检查当前是否满足 save 选项所设置的权限，从而决定是否执行 BGSAVE</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">serverCron</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># ...</span>
    
    <span class="token comment"># 遍历所有保存条件</span>
    <span class="token keyword">for</span> saveparam <span class="token keyword">in</span> server<span class="token punctuation">.</span>saveparams<span class="token punctuation">:</span>
        <span class="token comment"># 距离上次隔离多久</span>
        save_interval<span class="token operator">=</span>unixtime_now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>server<span class="token punctuation">.</span>lastsave
        
        <span class="token comment"># 次数和时间都满足，就执行保存操作</span>
        <span class="token keyword">if</span> server<span class="token punctuation">.</span>dirty<span class="token operator">&gt;=</span>saveparam<span class="token punctuation">.</span>changes <span class="token keyword">and</span> save_interval <span class="token operator">&gt;</span> saveparam<span class="token punctuation">.</span>seconds<span class="token punctuation">:</span>
            BGSAVE<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># ...        </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="RDB的文件结构"><a href="#RDB的文件结构" class="headerlink" title="RDB的文件结构"></a>RDB的文件结构</h2><p>一个完整的 RBD文件所包含下面几个部分：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">REDIS | db_version | databases | EOF | check_sum<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>REDIS：占5个字节，为 RDB 文件开头的 “REDIS” 五个字符，用于 Redis 载入时，快速判断载入文件是否为 RDB（注意：因为 RDB 为二进制文件，这里并不跟 C字符串一样，带着 ‘\0’ 符号标识结尾）</li>
<li>db_version：占4个字节，为一个字符串表示的整数，记录 RDB 的版本好，如”0006”，代表RDB 文件的版本为第六版</li>
<li>databases：包含0个或任意多个数据库，以及各个数据库中的键值对数据。如果数据库状态为空，即当前数据库为空，那么这个部门也会为空；反之就根据对应的类型，占用对应的长度</li>
<li>EOF：一字节，表示当前所以键值对已载入完毕</li>
<li>check_sum：占8字节，保存着一个校验和，根据前面四个部分的内容生成，用来判断 RDB 文件是否受损</li>
</ul>
<h3 id="databases部分"><a href="#databases部分" class="headerlink" title="databases部分"></a>databases部分</h3><p>因为databases保存的是任意多个非空数据库，所以，假设当服务器的0号数据库和3号数据库都为非空时，都会为其保存键值对</p>
<p>如：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">REDIS | db_version | database 0 | database 3 | EOF | check_sum<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>就表示了0号和3号数据库不为空</p>
<p>而每个非空数据库都可以保存 为SELECTDB、db_number、key_value_pairs 三个部分</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">SELECTDB | db_number | key_value_pairs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>SELECTDB：常量，占1字节，告诉程序接下来会读取一个数据库号码</li>
<li>db_number：占1、2或5个字节，表示一个数据库号码，用于服务器调用 SELECT 命令进行数据库切换</li>
<li>key_value_pairs：保存数据库中所有键值对数据，当然，如果键值对带有过期时间，那么保存时，也会将过期时间和键值对保存在一起</li>
</ul>
<p>整个格式如下：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">REDIS | db_version | SELECTDB | 0 | pairs | SELECTDB | 3 | pairs | EOF | check_sum<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="key-value-pairs-部分"><a href="#key-value-pairs-部分" class="headerlink" title="key_value_pairs 部分"></a>key_value_pairs 部分</h3><p>这个部门保存了一个或者以上数量的键值对，如果有过期时间的话，当然也会带上</p>
<p>不带过期时间的键值对在 RDB 文件中由 TYPE、key、value 三部分</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">TYPE | key | value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>TYPE：占用1字节，记录 value 类型，如：REDIS_RDB_TYPE_STRING、REDIS_RDB_TYPE_LIST等</li>
<li>key：总是一个字符串对象，其编码方式与 REDIS_RDB_TYPE+STRING 类型的value一样。根据其长度不同，key的长度也就会有所不同</li>
<li>value：保存对应的值对象</li>
</ul>
<p>带过期时间的键值对，会新增 EXPIRETIME_MS 和 ms 字段</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">EXPIRETIME_MS | ms | TYPE | key | value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>EXPIRETIME_MS：占1字节，告知程序下一个是以毫秒为单位的过期时间</li>
<li>ms：8字节，表示该键的一个过期时间的时间戳</li>
</ul>
<p><strong>value</strong>编码</p>
<p>因为value跟TYPE有关，所以不同类型的保存结构也不同</p>
<ul>
<li><p>字符串对象：REDIS_RDB_TYPE_STRING，编码为 REDIS_ENCODING_INT 或者 REDIS_ENCODING_RAW</p>
<ul>
<li><p>如果为 整数类型，那么就可能是 REDIS_ENCODING_INT8、REDIS_ENCODING_INT16或者 REDIS_ENCODING_INT32 中的某一个，及代表使用多少位来保存</p>
<p>如：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">ENCODING | msg | REDIS_ENCODING_INT8 | 123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这里的123就占了8位</p>
</li>
<li><p>如果位为 raw 类型，那么说明保存的就是一个字符串，根据字符串的长度不同，也会有压缩和不压缩的区别</p>
<ul>
<li><p>如果长度小于等于20字节，不压缩，原文保存</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">len | string<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- 如果大于20字节，会被压缩后再保存（当然是服务器打开了 RDB 文件压缩的情况下，若没有，还是原文保存）

  <pre class="line-numbers language-html" data-language="html"><code class="language-html">REDIS_RDB_ENC_LZF | compressed_len | origin_len | compressed_string<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

  这里的 REDIS_RDB_FND_LZF 常量标识着该字符串已经被使用了 LZF 算法，然后程序再读入 compressed_len、origin_len和 compressed_string，就能对字符串进行解压</code></pre>
<ul>
<li><p>列表对象：TYPE 为 REDIS_RDB_TYPE_LIST，其value就是 REDIS_ENCODING_LINKEDLIST 编码的列表对象</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">list_length | item1 | item2 | ... | itemN<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其中list_length 记录了当前列表的长度，表示当前要读几个项，为每个项开头也记录了该项得长度</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">| 3 | 5 | "hello" | 5 | "world" | 1 | "!" |<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>集合对象：REDIS_RDB_TYPE_SET，value保存的为 REDIS_ENCODING_HT 编码的集合对象</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">| set_size | elem1 | elem2 | ... | elemN |<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其存储跟列表对象类似</p>
</li>
<li><p>哈希表对象：REDIS_RDB_TYPE_HASH，其 value 保存的为一个 REDIS_ENCODING_HT 编码的对象</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">| hash_size | key_value_pair 1 | key_value_pair 2 | ... | key_value_pair N |<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其中的 hash_size 记录当前了哈希表的大小，即多少个键值对</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">| hash_size | key1 | v1 | key2 | v2 | ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



</li>
</ul>
  <pre class="line-numbers language-html" data-language="html"><code class="language-html">| 2 | 1 | "a" | 5 | "apple" | 1 | "b" | "6" | "banana"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><p>有序集合对象：REDIS_RDB_TYPE_ZSET， 其 value 保存的是一个 REDIS_ENCODING_SKIPLIST 编码的有序集合</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html">| sorted_set_size | e1 | e2 | e3 | ... | eN<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其中的每个元素包含了 member和score，member为字符串，socre为double</p>
</li>
<li><p>INTSET 编码的集合：REDIS_RDB_TYPE_SET_INTSET，其 value 就是一个整数集合的对象，然后将其转为字符串对象，再保存</p>
</li>
<li><p>ZIPLIST 编码的列表、哈希表或者有序集合：TYPE为REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST或者REDIS_RDB_TYPE_ZSET_ZIPLIST，那么 value 就是一个压缩列表对象。其在RDB中的保存方式，也是转为字符串对象</p>
</li>
</ul>
<h3 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h3><p>首先，执行下面命令</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis&gt; FLUSHALL # 清空数据库状态
OK
redis&gt; SAVE
OK
$ od -c dump.rdb # ASCLL 码打印文件
0000000    R E D I S 0 0 0 6 377 334 263 C 360 Z 334
0000020 362 V
0000022<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>分析：</p>
<p>当没有任何数据时，由下面四个部分组成</p>
<ul>
<li>5个字节的 “REDIS”</li>
<li>四个字节的版本号（db_version）：0006</li>
<li>一个字节的 EOF常量：377</li>
<li>八个字节的check_sum：334 263 C 360 Z 334 362 V</li>
</ul>
<p>加一个set，即：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis&gt; FLUSHALL # 清空数据库状态
OK
redis&gt; SET MSG "HELLO"
OK
redis&gt; SAVE
OK
$ od -c dump.rdb # ASCLL 码打印文件
0000000    R E D I S 0 0 0 6 376 \0 \0 003 M S G
0000020  005 H E L L O 377 207 z = 304 f T L 343
0000037<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>新增：</p>
<ul>
<li>一个字节长的 SELECTDB：376</li>
<li>1、2或5个字节长的数据库号码（db_number）：\0</li>
<li>一个或以上的键值对（key_value_pairs）：\0 代表 TYPE类型为字符串对象，003为MSG长度</li>
</ul>
<p>如果设置包含过期时间的键值对</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis&gt; FLUSHALL # 清空数据库状态
OK
redis&gt; SET MSG 10086 "HELLO"
OK
redis&gt; SAVE
OK
$ od -c dump.rdb # ASCLL 码打印文件
0000000    R E D I S 0 0 0 6 376 \0 374 \ 2 365 336 
0000020    @ 001 \0 \0 \0 003 M S G 005 H E L L O 377 
0000040    212 231 x 247 252 } 021 306
0000050<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>新增：</p>
<ul>
<li>一个一字节长的 EXPIRETIME_MS：374</li>
<li>一个8字节长的过期时间ms：\ 2 365 336 @ 001 \0 \0</li>
</ul>
<h1 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h1><p>与 RDB 直接记录当前数据库状态不同，AOF为通过保存 Redis 服务器执行的写命令来记录数据库状态</p>
<p>并且 AOF 文件的所有命令都是以 Redis 的命令请求协议格式保存的，即纯文本格式</p>
<p>如：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis&gt; SET msg "hello"
OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<pre class="line-numbers language-html" data-language="html"><code class="language-html">*2\r\n$6\r\nSELECT\r\n$1\r\n0\r\n
*3\r\n$3\r\nSET\r\n$3\r\nmsg\r\n$5\r\nhello\r\n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="持久化的实现"><a href="#持久化的实现" class="headerlink" title="持久化的实现"></a>持久化的实现</h2><p>AOF的持续化功能的实现，可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤</p>
<p><strong>命令追加</strong></p>
<p>服务器在执行一个命令后，会将命令追加到服务器状态的aof_buf缓冲区的末尾</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span><span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    
    sds aof_buf<span class="token punctuation">;</span>
    
    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>即将当前命令直接添加到aof_buf，跟go的append一样</p>
<p><strong>写入与同步</strong></p>
<p>首先服务器进程就是一个事件循环（loop），这个循环中的文件事件负责接收客户端的命令请求，以及命令回复，而时间事件就负责执行类似 serverCron函数</p>
<p>在服务器每次结束一个循环事件之前，它就会调用 flushAppendOnlyFile 函数，并考虑是否要将 aof_buf 写入</p>
<p>伪代码实现：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        <span class="token comment"># 除了文件事件，并将请求时可能的新内容追加到 aof_buf 中</span>
        processFileEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>
        
        <span class="token comment"># 处理时间事件</span>
        processTimeEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>
        
        <span class="token comment"># 考虑是否要将 aof_buf 中的内容写入和保存到 AOF 文件中</span>
        flushAppendOnlyFile<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>flushAppednOnlyFile函数由服务器配置的 appendfsync 选项来决定</p>
<ul>
<li>always：总是同步</li>
<li>everysec：每1s同步，这个由一个线程专门负责</li>
<li>no：由操作系统决定，何时同步</li>
</ul>
<p>默认为everysec</p>
<p>注意：操作系统，在写时会先将要写入的数据放入缓存区，等其填满或者超时时，才会写入磁盘，因此，系统提供了 fsync 和 fdatasync 两个同步函数，强制将操作系统的缓冲区的数据写入到磁盘中</p>
<blockquote>
<p>AOF 的三种写入的效率和安全性如何？</p>
</blockquote>
<p>根据 appendfsync 的配置的，always 最安全，但效率不行；everysec 则折中，最多丢失1s的数据；no 则无需调用 flushAppendOnlyFile 执行同步，其效率最快，不过会累计数据</p>
<blockquote>
<p>AOF 如何载入和数据还原？</p>
</blockquote>
<ol>
<li>创建一个不带网络连接的伪客户端（fake client）：因为 Redis 的命令只能在客户端上下文中执行，而载入AOF文件时所用的命令直接来源于 AOF 文件，而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端</li>
<li>从AOF文件中分析并读取一条写命令</li>
<li>使用伪客户端执行读出的命令</li>
<li>直到 AOF 文件读取完毕</li>
</ol>
<h2 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h2><p>目的是减少当前 AOF 文件的体积</p>
<p>原理是，读取当前数据库的状态，而不是每个写入命令</p>
<p>伪代码实现：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">aof_rewrite</span><span class="token punctuation">(</span>new_aof_file_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 创建新的 AOF 文件</span>
    f<span class="token operator">=</span>create_file<span class="token punctuation">(</span>new_aof_file_name<span class="token punctuation">)</span>
    <span class="token comment"># 遍历数据库</span>
    <span class="token keyword">for</span> db <span class="token keyword">in</span> redisServer<span class="token punctuation">.</span>db<span class="token punctuation">:</span>
        <span class="token comment"># 忽略空数据库</span>
        <span class="token keyword">if</span> db<span class="token punctuation">.</span>is_empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">continue</span>
        
        f<span class="token punctuation">.</span>write_command<span class="token punctuation">(</span><span class="token string">"SELECT"</span><span class="token operator">+</span>db<span class="token punctuation">.</span><span class="token builtin">id</span><span class="token punctuation">)</span>
        
        <span class="token keyword">for</span> key <span class="token keyword">in</span> db<span class="token punctuation">:</span>
            <span class="token keyword">if</span> key<span class="token punctuation">.</span>is_expired<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">continue</span>
            <span class="token keyword">if</span> key<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token operator">==</span>String<span class="token punctuation">:</span>
                rewrite_string<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
            <span class="token keyword">elif</span> key<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token operator">==</span>List<span class="token punctuation">:</span>
                rewrite_list<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
            <span class="token keyword">elif</span> key<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token operator">==</span>Hash<span class="token punctuation">:</span>
                rewrite_hash<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
            <span class="token keyword">elif</span> key<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token operator">==</span>Set<span class="token punctuation">:</span>
                rewrite_set<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
            <span class="token keyword">elif</span> key<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token operator">==</span>SortedSet<span class="token punctuation">:</span>
                rewrite_sorted_set<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
            
            <span class="token keyword">if</span> key<span class="token punctuation">.</span>have_expire_time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                rewrite_expire_time<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
     f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>           
<span class="token keyword">def</span> <span class="token function">rewrite_string</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>
    value<span class="token operator">=</span>GET<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    f<span class="token punctuation">.</span>write_command<span class="token punctuation">(</span>SET<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>
<span class="token comment">#...</span>
<span class="token keyword">def</span> <span class="token function">rewrite_expire_time</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>
    timestamp<span class="token operator">=</span>get_expire_time_in_unixstamp<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    f<span class="token punctuation">.</span>write_command<span class="token punctuation">(</span>PEXPIREAT<span class="token punctuation">,</span>key<span class="token punctuation">,</span>timestamp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意：当一个列表、哈希表、集合、有序集合过长时，肯定不会直接一条命令写入也是为了避免客户端输入缓冲区溢出，会先检查键所包含的元素数量，如果超过了 redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD 常量的值，那么就会用多条命令来记录键的值</p>
<blockquote>
<p>为什么使用子进程重写？</p>
</blockquote>
<ul>
<li>方便父进程继续处理命令</li>
<li>子进程带有服务器进程的副本，不使用线程，避免了锁，保证了数据安全</li>
</ul>
<blockquote>
<p>在重写时，新写入 AOF 命令如何处理？</p>
</blockquote>
<p>Redis 服务器设置了一个 AOF 重写缓冲区，这个缓冲区在服务器创建子进程后开始使用。就是重写时，对于客户端发来的命令，既要写入 AOF 缓冲区，也要写入 AOF 重写缓冲区</p>
<p>这样就可以保证：</p>
<ul>
<li>AOF 缓冲区的内容会定期写入和同步至AOF文件，并对现有的 AOF 文件的处理工作照常</li>
<li>重写时的命令都会被写入到重写缓冲区</li>
</ul>
<p>当子进程完成 AOF 重写后，会发送一个信号给父进程，然后父进程会将当前重写缓冲区的内容添加至一个新的 AOF 文件 （这个 AOF 文件保存的数据库状态跟当前服务器一样），然后再对该新 AOF 文件改名。原子地（atomic）的覆盖原AOF文件，实现新旧替换</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>Redis 服务器为一个事件驱动的程序，分为下面两类事件：</p>
<ul>
<li>文件事件（file event）：Redis 服务器通过套接字与客户端（或其它服务器）进行连接，而文件事件就是服务器对套接字操作的抽象</li>
<li>时间时间（time event）：Redis 服务器中的一些操作（如 serverCron）需要在给定时间点执行，而时间事件就是服务器对这类定时操作的抽象</li>
</ul>
<h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>基于 Reactor 模式开发了自己的网络事件处理器，即 文件事件处理器（file event handler）</p>
<ul>
<li>使用IO多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来关联不同的事件处理器</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件</li>
</ul>
<p>虽然文件事件处理器以单线程方式运行，但通过IO多路复用程序来监听多个套接字，既实现了高性能网络通信模型，又能很好地与 Redis 服务器中其它同样以单线程方式运行的模块对接，保存了 Redis 内部单线程设计的简单性</p>
<p><strong>组成</strong></p>
<p>文件事件处理器由四个部分组成，分别为套接字、IO多路复用程序、文件事件分派器（dispatcher），以及事件处理器</p>
<img src="C:/Users/yan/AppData/Roaming/Typora/typora-user-images/image-20220401140110859.png" alt="image-20220401140110859" style="zoom:50%;">

<p>一个服务器肯定会出现多个套接字，那么多个文件事件就有可能并发的出现，所以IO多路复用程序会监听多个套接字，并将所有产生事件的套接字都放入一个队列中，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。</p>
<p>当一个套接字被关联的处理器处理完之后，IO多路复用才会传递下一个</p>
<blockquote>
<p>IO多路复用怎么实现的？</p>
</blockquote>
<p>Redis的IO多路复用程序都是通过包装常见的 select、epoll、evport和kquque这些IO多路复用函数库实现的，每个函数库在Redis源码中都是一个单独的文件，如 ae_select.c、ae_epoll.c等，所以IO多路复用的底层事可以互换的</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">ifdef</span> <span class="token expression">HAVE_EVPORT</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span> <span class="token string">"ae_evport"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">else</span></span>
	<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">ifdef</span> <span class="token expression">HAVE_EPOLL</span></span>
	<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span> <span class="token string">"ae_epoll.c"</span></span>
	<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">else</span></span>
		<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">ifdef</span> <span class="token expression">HAVE_KQUEUE</span></span>
		<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span> <span class="token string">"ae_kqueue.c"</span></span>
		<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">else</span></span>
		<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">include</span> <span class="token string">"ae_select.c"</span></span>
		<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">endif</span></span>
	<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>如果一个套接字，既可读也可写，先后顺序如何？</p>
</blockquote>
<p>服务器会选读套接字，后写</p>
<p>IO多路复用程序可以监听多个套接字的 ae.h/AE_READABLE 事件和 ae.h/AE_WRITABLE 事件，并且允许同时监听</p>
<ul>
<li>AE_READABLE 事件：当套接字变得可读时，即客户端对套接字执行write操作，或 close操作，再或者有新的可应答（acceptable）套接字出现时（客户端对服务器监听的套接字执行 connect 操作）</li>
<li>AE_WRITABLE 事件：当套接字变得可写时，客户端对套接字执行 read 操作</li>
</ul>
<p>对应的 API：</p>
<ul>
<li>aeCreateFileEvent：接受一个套接字描述符、一个事件类型，还有一个事件处理器。将给定套接字的事件加入到IO多路复用程序的监听范围之内，并对事件以及处理器进行关联</li>
<li>aeDeleteFileEvent：接受一个套接字描述符和一个事件类型，取消其监听和事件与处理器之间的关联</li>
<li>aeGetFileEvents：接受一个套接字描述符，返回监听的事件类型</li>
<li>aeWait：接受一个套接字描述符、一个事件类型和ms数，在给定时间内阻塞套接字，直到产生对应类型的时间返回，或者超时返回</li>
<li>aeApiPoll：接受一个 sys/time.h/struct timeval 结构作为参数，并在指定时间内，阻塞并等待所有被 aeCreateFileEvent 函数设置为监听状态的套接字产生的文件事件，直到至少一个事件产生，或超时后，函数返回</li>
<li>aeProcessEvents：文件事件分派器，会先调用 aeApiPoll 函数来等待事件，然后遍历所有已经产生的事件，并调用相应的事件处理器来处理这些事件</li>
<li>aeGetApiName：返回IO复用底层调用的函数库名，如”epoll”、”select”等</li>
</ul>
<h3 id="文件事件的处理器"><a href="#文件事件的处理器" class="headerlink" title="文件事件的处理器"></a>文件事件的处理器</h3><p>全是针对服务器而言，连接应答、命令请求和命令回复</p>
<p><strong>连接应答处理器</strong></p>
<p>networking.c/acceptTcpHandler 函数，Redis的连接应答处理器，用于监听套接字的客户端进行应答</p>
<p>当Redis服务器进行初始化时，程序会将这个连接应答处理器和服务器监听套接字的 AE_READABLE 事件关联起来，当有客户端使用 sys/socket.h/connect 函数连接服务器监听套接字的时候，套接字就会产生 AE_READABLE事件，进而引发连接应答处理器</p>
<p><strong>命令请求处理器</strong></p>
<p>networking.c/readQueryFromClient 函数，Redis的命令请求处理器，负责从套接字读入客户端发送的命令请求内容  </p>
<p><strong>命令回复处理器</strong></p>
<p>networking.c/sendReplyToClient 函数，将服务器执行后得到的命令通过套接字回复 </p>
<p>当客户端准备好接收回复时，会产生 AE_WRITEABLE 事件，引发处理器执行，当回复完后，服务器又会解除处理器与客户端套接字AE_WRITEABLE 事件的关联、</p>
<p><strong>一次完整的客户端和服务器连接事件</strong></p>
<ol>
<li>服务器监听套接字的 AE_READABLE 事件，并且关系的处理器为连接应答处理器</li>
<li>Redis 客户端发起连接，监听套接字将产生 AE_READABLE 事件，触发连接应答处理器执行</li>
<li>处理器对客户端的连接请求进行应答，然后创建客户端套接字，以及客户端状态，并将客户端套接字的 AE_READABLE 事件与命令请求处理器关联，使得客户端可以发送请求</li>
<li>客户端发送一个命令请求，将产生 AE_READABLE 事件，引发请求命令处理器</li>
<li>执行完之后，服务器将客户端套接字的AE_WRITABLE 事件与命令回复处理器进行关联，然后客户端尝试读取命令回复，并触发相关处理器执行，写入完后，服务器解除关联</li>
</ol>
<img src="C:/Users/yan/AppData/Roaming/Typora/typora-user-images/image-20220401231043326.png" alt="image-20220401231043326" style="zoom:50%;">

<h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>主要分为：</p>
<ul>
<li>定时事件：让一段程序在指定的时间之后执行一次</li>
<li>周期事件：让一段程序每隔一段时间就执行一次</li>
</ul>
<p>一个时间事件主要由下面三个属性组成：</p>
<ul>
<li>id：uuid，按号从小到大递增</li>
<li>when：事件的到达时间，毫秒精度的UNIX时间戳</li>
<li>timeProc：时间处理器，一个函数</li>
</ul>
<blockquote>
<p>什么时候为定时事件？或者什么时候为周期事件？</p>
</blockquote>
<p>取决于时间事件处理器的返回值</p>
<ul>
<li>如果事件处理器返回 ae.h/AE_NOMORE，那么这个事件就是定时事件，到达一次之后就会被删除，之后不会再到达</li>
<li>如果返回的为一个非 AE_NOMORE 的整数值，那么这个事件就是周期事件，到达之后，会更新其when。</li>
</ul>
<p>目前，Redis只有周期事件</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>所有的时间事件都被放入了一个无序链表中，每当时间事件执行器运行时，它会遍历整个链表，查找已到达的事件，并调用相应的事件处理器</p>
<p>注意：因为是头插入法，所以链表的ID为逆序，而且这个的无序说的是没有按when属性排序，它必须遍历所有</p>
<blockquote>
<p>为什么无序链表不会影响性能？</p>
</blockquote>
<p>因为Redis只有 serverCron 一个时间事件，而在 benchmark 模式下，也只有两个时间事件。这种情况下，无序链表就相当于一个指针</p>
<blockquote>
<p>serverCron 函数的主要工作是什么？</p>
</blockquote>
<ul>
<li>更新服务器的各类统计信息，比如：时间、内存占用、数据库占用情况等</li>
<li>清空过期的键值对</li>
<li>关闭和清理连接失效的客户端</li>
<li>尝试进行 AOF 或 RDB 持久化</li>
<li>如果服务器为主服务器，负责对从服务器进行定期同步</li>
<li>如果处于集群模式，对集群进行定期同步和连接测试</li>
</ul>
<p>一般为每秒运行10次，当然也可更改配置文件</p>
<h2 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h2><p>何时处理文件事件，何时处理时间事件，由aeProcessEvents函数实现</p>
<p>伪代码实现：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 距离当前时间最近的时间事件</span>
    time_event<span class="token operator">=</span>aeSearchNearestTimer<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 距离当前事件还有多少时间</span>
    remaind_ms<span class="token operator">=</span>time_event<span class="token punctuation">.</span>when<span class="token operator">-</span>unix_ts_now<span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    <span class="token keyword">if</span> remaind_ms<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>
        remaind_ms<span class="token operator">=</span><span class="token number">0</span>
    <span class="token comment"># timeval 有个上限的</span>
    timeval<span class="token operator">=</span>Create_timeval_with_ms<span class="token punctuation">(</span>remaind_ms<span class="token punctuation">)</span>
    <span class="token comment"># 阻塞，等待文件事件产生</span>
    <span class="token comment"># 如果timeval为0。就不阻塞</span>
    aeApiPoll<span class="token punctuation">(</span>timeval<span class="token punctuation">)</span>
    
    processFileEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>
    processTimeEvents<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>并且aeProcessEvents函数置于一个循环里面</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 初始化服务器</span>
    init_server<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># z</span>
    <span class="token keyword">while</span> server_is_not_shutdown<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        aeProcessEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    clean_server<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>事件的调度和执行规则：</p>
<ul>
<li>aeApiPoll 函数的最大阻塞事件由最近的时间事件决定，避免了忙等待，也确保 aeApiPoll函数不会阻塞过长事件</li>
<li>因为文件事件肯定是随机出现的（连接、请求、回复），如果处理完文件事件后，时间事件还未到达，那么会进行下一次轮询，时间事件就会逐渐逼近</li>
<li>对文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，各自的处理器都要尽可能地减少程序地阻塞时间，并在有需要时主动让出执行权。比如：在命令回复处理器中，当写入的字节数超过了预设常量的话，其处理器就会主动 break 跳出写入循环，将余下的数据留到下次再写；再比如，较为耗时的持久化操作，也是使用子线程或子进程执行的</li>
<li>时间事件会比文件事件晚执行，那么时间事件的实际处理时间会比设定的时间晚一些</li>
</ul>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>Redis的一个服务器可以与多个客户端建立网络连接</p>
<p>通过使用IO多路复用技术实现的文件时间处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信</p>
<p>对于每个客户端，都使用 redis.h/redisClient 结构保存了客户端的状态，其中包含：</p>
<ul>
<li>客户端的套接字描述符</li>
<li>客户端的name</li>
<li>客户端的标志值（flag）</li>
<li>指向客户端正在使用的数据库的指针，以及该数据库的号码</li>
<li>客户端当前要执行的命令、命令的参数、参数的个数，以及指向命令实现函数的指针</li>
<li>客户端的输入缓冲区和输出缓冲区</li>
<li>客户端的复制状态信息，以及进行复制所需的数据结构</li>
<li>客户端执行 BRPOP、BLPOP 等列表阻塞命令时使用的数据结构</li>
<li>客户端的事务状态，以及状态 WATCH 命令时用到的数据结构</li>
<li>客户端执行发布与订阅功能时用到的数据结构</li>
<li>客户端的身份验证标志</li>
<li>客户端的创建时间，与服务器最后一次通信的时间，以及客户端的输出缓冲区大小超出软性限制（soft limit）的时间</li>
</ul>
<p>对于服务器而言，clients 属性就是一个链表</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span><span class="token punctuation">{</span>
	<span class="token comment">//...</span>
    
    list <span class="token operator">*</span>clients<span class="token punctuation">;</span>
    
    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h2><p>客户端的属性大致可以分为两类：</p>
<ul>
<li>比较通用的属性：很少与特定功能相关，无论客户端执行什么工作，都会用到这类属性</li>
<li>与特定功能相关的属性：比如操作数据库时需要用到的db属性和ditcid属性，执行事务时需要用到的matate属性</li>
</ul>
<p><strong>套接字描述符</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span><span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>redisClient<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>根据客户端类型的不同，fd属性的值可以为-1，或者是大于-1的整数</p>
<ul>
<li>伪客户端（fake client）：fd为-1，其请求来源于 AOF 脚本 或 Lur 脚本，而不是网络，所以这种客户端是不需要套接字连接的，自然也就不许要套接字描述符</li>
<li>普通客户端：fd&gt;-1，记录客户端套接字的描述符</li>
</ul>
<p><strong>名字</strong></p>
<p>默认情况下，一个连接到服务器的客户端是没有name的</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">127.0.0.1:6379&gt; CLIENT list
id=4 addr=127.0.0.1:51168 fd=7 name= <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>使用 CLIENT setname 可以为客户端设置一个名字，让客户端的身份变得更加的清晰</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">127.0.0.1:6379&gt; CLIENT setname as
OK
127.0.0.1:6379&gt; CLIENT list
id=4 addr=127.0.0.1:51168 fd=7 name=as<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在代码中，name为一个结构体指针</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span><span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    robj <span class="token operator">*</span>name<span class="token punctuation">;</span> <span class="token comment">// 字符串对象</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>redisClient<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>标志</strong></p>
<p>客户端的标志属性（flags）记录了客户端的角色（role），以及客户端目前所处的状态</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span><span class="token punctuation">{</span>
	<span class="token comment">//...</span>
    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>
    
    <span class="token comment">//...</span>
<span class="token punctuation">}</span>redisClient<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>表示角色的：</p>
<ul>
<li>REDIS_MASTER：主服务器，因为在主从同步时，主服务器就像从服务器的客户端</li>
<li>REDIS_SLAVE：从服务器</li>
<li>REDIS_PRE_PSYNC：表示一个低于 Redis 2.8 的从服务器，主服务器不能使用 PSYNC 命令与这个从服务器进行同步</li>
<li>REDIS_LUA_CLIENT：表示客户端是专门用于处理 Lua 脚本里面包含的 Redis 命令的伪客户端</li>
</ul>
<p>标志状态的：</p>
<ul>
<li><p>REDIS_MONITOR：表示客户端正在执行 MONITOR 命令</p>
</li>
<li><p>REDIS_UNIX_SOCKET：表示服务器使用UNIX套接字来连接客户端</p>
</li>
<li><p>REDIS_BLOCKEN：客户端正在被 BRPOP、BLPOP 等命令阻塞</p>
</li>
<li><p>REDIS_UNBLOCKEN：客户端已经从 REDIS_BLOCKED 标志所表示的阻塞状态中脱离出来，不再阻塞</p>
</li>
<li><p>REDIS_MULTI：表示客户端正在执行事务</p>
</li>
<li><p>REDIS_DIRTY_CAS：表示事务使用WATCH 命令监视的数据库键已经被修改；</p>
<p>REDIS_DIRTY_EXEC表示命令入队时出现了错误，这两个标志都表示事务的安全性已经被破坏，只要任意一个被打开，EXEC命令必定会执行失败。注意，这两个标志只能在 Redis 客户端打开了 REDIS_MULTI 标志的情况下使用</p>
</li>
<li><p>REDIS_CLOSE_ASAP：表示客户端的输出缓冲区大小超出了服务器允许的范围。服务器会在下一次serverCron时关闭这个客户端，以免其影响性能，而积累在缓冲区的所以内容都会被释放掉</p>
</li>
<li><p>REDIS_CLOSE_AFTER_REPLY：表示有用户对这个客户端执行了 CLIENT KILL 命令，或者客户端发送给服务器的命令请求中包含了错误的协议内容。服务器会将输出缓冲区的内容发送给客户端，然后关闭客户端</p>
</li>
<li><p>REDIS_ASKING：客户端向集群节点发送了 ASKING 命令</p>
</li>
<li><p>REDIS_FORCE_AOF：标识强制服务器将当前执行的命令写入到 AOF 文件里面</p>
<p>REDIS_FORCE_REPL 标识强制主服务器将当前执行的命令复制给所有从服务器</p>
<p>执行 PUBSUB 命令会使客户端打开 REDIS_FORCE_AOF，执行 SCRIPT LOAD 命令会使客户端打开 REDIS_FORCE_AOF 标志和 REDIS_FORCE_REPL 标志</p>
</li>
<li><p>在主从服务器进行命令传播期间，从服务器需要向主服务器发送 REPLICATION ACK命令，在这个命令发送之前，从服务器需要主服务器打开对应客户端状态的 REDIS_MASTER</p>
</li>
</ul>
<p><strong>输入缓冲区</strong></p>
<p>用于保存客户端发送的命令请求</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span><span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    sds querybuf<span class="token punctuation">;</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span>redisClient<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输入缓冲区的大小会根据输入内容动态的缩小或扩大，其最大大小不能超过1GB，否则将会关闭这个客户端</p>
<p><strong>命令和命令参数</strong></p>
<p>服务器对命令请求的内容进行分析，得出命令参数和命令参数个数保存到客户端状态的 argv属性和argc属性</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span><span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">;</span>
    <span class="token keyword">int</span> argc<span class="token punctuation">;</span>
    
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>redisClient<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>argv为一个数组，每一项都是字符串，其中 argv[0] 为要执行的命令</p>
<p>argc为argv的长度</p>
<p><strong>命令实现的函数</strong></p>
<p>对应命令的函数，使用一个dict实现的，一个k对应其一个redisCommand结构，它保存了命令的实现函数、命令的标志、给定的参数个数、总执行次数和总消耗时长等统计信息</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span><span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">struct</span> <span class="token class-name">redisCommand</span> <span class="token operator">*</span>cmd<span class="token punctuation">;</span>
    
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>redisClient<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>输出缓冲区</strong></p>
<p>执行命令回复都会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用，一个大小固定的，另一个大小可变</p>
<ul>
<li>固定大小的缓冲区用于保存那些长度比较小的回复，比如 OK、简短的字符串、错误回复等</li>
<li>可变的缓冲大多用于保存那些长度比较大的回复,如较长的列表回复等</li>
</ul>
<p>固定缓冲区由 buf 和 bufpos 两个属性组成：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span><span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token comment">// REDIS_REPLY_CHUNK_BYTES 默认值为 16*1024，即 16KB</span>
    <span class="token comment">// 如 buf="+OK\r\n" bufpos=5</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>REDIS_REPLY_CHUNK_BYTES<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> bufpos<span class="token punctuation">;</span>
    
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>redisClient<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>buf 为一个大小为 REDIS_REPLY_CHUNK_BYTES 字节的字节数组，而 bufpos 属性则记录了 buf 数组目前已使用的字节数量</p>
<p>可变大小缓冲区由 reply 链表和一个或多个字符串对象组成：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span><span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    
    list <span class="token operator">*</span>reply<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>redisClient<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>而链表是用来连接多个字符串对象的，服务器就可以为客户端保存一个非常长的命令回复，不限于 16KB</p>
<p><strong>身份验证</strong></p>
<p>客户端状态的authenticated用于记录客户端是否通过身份验证</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span><span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    
    <span class="token comment">// 0 为未通过；1 为通过</span>
    <span class="token keyword">int</span> authenticated<span class="token punctuation">;</span>
    
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>redisClient<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>时间</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisClient</span><span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token comment">// 创建客户端的时间，可用来记录客户端与服务器已经连接了多少秒</span>
    <span class="token comment">// 如： CLIENT list 返回的 age中，就用了这个属性</span>
    time_t ctime<span class="token punctuation">;</span>
    <span class="token comment">// 最后一次与客户端互动的时间，用来计算空转的时间</span>
    <span class="token comment">// 如：idle</span>
    time_t lastinteration<span class="token punctuation">;</span>
    <span class="token comment">// 输出缓冲区第一次到达软性限制的时间</span>
    time_t obuf_soft_limit_reached_time<span class="token punctuation">;</span>
    
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>redisClient<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>服务器对客户端输出缓冲区的两种限制：</p>
<ul>
<li>硬性限制（hard limit）：如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器就会立即关闭客户端</li>
<li>软性限制（soft limit）：如果输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制的，那么服务器使用服务器状态的 obuf_soft_limit_reached_time 记录当前时间，如果客户端在一段时间内，一直超出软性限制，那么就会关闭客户端连接；反之就将记录的时间清零</li>
</ul>
<blockquote>
<p>如何设置软性限制和硬性限制？</p>
</blockquote>
<p>使用 client-output-buffer-limit 选项，可为普通客户端、从服务器客户端、执行发布和订阅功能的客户端分别设置不同的软性限制和硬性限制</p>
<p>语法：<code>client-output-buffer-limit  &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</code></p>
<p>如：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 普通客户端，软硬都为0，不限客户端的输出缓冲区大小
client-output-buffer-limit normal 0 0 0 
# 从服务器客户端，软为256mb，硬为64mb，软性限制时长为60s
client-output-buffer-limit slave 256mb 64mb 60
# 执行发布和订阅功能的客户端，硬为32mb，软为8mb，60s
client-output-buffer-limit pubsub 32mb 8mb 60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="两个伪客户端"><a href="#两个伪客户端" class="headerlink" title="两个伪客户端"></a>两个伪客户端</h2><p><strong>Lua脚本的伪客户端</strong></p>
<p>redis初始化时，创建负责执行 Lua 脚本中包含的 Redis 命令的伪命令，并将这个伪客户端关联在服务器状态结构的 lua_client 属性中</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span><span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    
    redisClient <span class="token operator">*</span>lua_client<span class="token punctuation">;</span>
    
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个伪客户端会一直存在，直到服务器关闭</p>
<p><strong>AOF 文件的伪客户端</strong></p>
<p>其fd为-1，AOF 载入完毕后就会关闭</p>
<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><p>服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并管理资源来维护自身的运转</p>
<h2 id="命令请求的执行过程"><a href="#命令请求的执行过程" class="headerlink" title="命令请求的执行过程"></a>命令请求的执行过程</h2><p>一个命令请求从发送到回复的过程</p>
<ol>
<li><p>发送命令请求：客户端将用户输入的命令请求转换为协议格式，然后通过连接到服务器的套接字，将协议格式的请求发送给服务器</p>
<p>如：<code>SET KEY VALUE</code> 转化为<code>*3\r\n$3\r\nSET\r\n$3\r\nKEY\r\n$5\r\nVALUE\r\n</code></p>
</li>
<li><p>读取命令请求：服务器与客户端之间连接的套接字因为客户端的写入变得可读，然后执行如下操作：</p>
<ol>
<li>读取套接字协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里</li>
<li>对输入缓冲区里的命令进行解析，提取出 agrv和argc</li>
<li>调用命令执行器，执行指定命令</li>
</ol>
<p>当然，执行前则是根据redisCommand调用</p>
<p>命令执行时，会有一系列的预备操作，如内存占用、是否身份验证、cmd指针是否指向 NULL等，</p>
<p>执行后续工作，如：服务器开启慢查询日志功能时，是否需要将其添加进慢查询日志；根据刚刚执行命令所耗费的时长，更新redisCommand结构的milliisecods 属性，并将其 calls计数器+1；写入AOF缓冲区（开启了 AOF 持久化功能的情况下）；传至从服务器（如果从服务器正在复制）</p>
</li>
<li><p>将命令回复发送给客户端</p>
<p>命令实现函数将命令回复保存到客户端的输出缓冲区中，并为客户端套接字关联命令回复处理器，当客户端套接字变得可写时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端。发送完后，清空缓冲区，为下一个做准备</p>
</li>
<li><p>客户端接受并打印命令回复</p>
</li>
</ol>
<h2 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h2><p> 默认每 100ms执行一次，负责管理服务器的资源</p>
<p><strong>更新服务器时间缓存</strong></p>
<p>因为有不少功能都需要获取到系统的当前时间，而每次获取都会涉及到系统调用，为了减少调用次数，redis在服务器状态中设置了unixtime 属性和mstime属性当作当前时间的缓存</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span><span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token comment">// 秒精度</span>
    time_t unixtime<span class="token punctuation">;</span>
    <span class="token comment">// 毫秒精度</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> mstime<span class="token punctuation">;</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>默认每100ms会更新这两个属性，所有其精度不会很高</p>
<blockquote>
<p>什么时候需要使用缓存时间？</p>
</blockquote>
<p>打印日志、更新服务器的LRU时钟、决定是否执行持久化任务、计算服务器上线时间（uptime）这类对时间精度要求不高的功能上</p>
<blockquote>
<p>什么时候还是得执行系统调用？</p>
</blockquote>
<p>为键设置过期时间、添加慢查询日志等需要高精度的时间功能来说</p>
<p><strong>更新LRU时钟</strong></p>
<p>保存着服务器的LRU时钟</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span><span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    
    <span class="token comment">// 默认每10s更新一次的时钟缓存</span>
    <span class="token comment">// 用于计算键的空转（idle）时长</span>
    <span class="token keyword">unsigned</span> lruclock<span class="token operator">:</span><span class="token number">22</span><span class="token punctuation">;</span>
    
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>每个 redisObject 都会保存一个 lru属性，这个属性保存了对象最后一次被命令访问的时间</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span><span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    
    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span><span class="token number">22</span><span class="token punctuation">;</span>
    
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>robj<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当服务器要计算一个数据库键的空转时间时，程序会用服务器的lruclock属性记录的时间减去对象的lru记录的时间</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis&gt; OBJECT IDLETIME msg
(integer) 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>更新服务器每秒执行命令次数</strong></p>
<p>serverCron 函数中的 trackOperationPerSecond 会以每 100ms 一次的执行，这个函数的功能是以抽样计算的方式，估算并记录服务器在最近一秒处理的命令请求数量。</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis&gt; INFO stats
# Stats
...
instantaneous_ops_per_sec:6
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以使用 INFO status 查看，其 instantaneous_ops_per_sec 域就是对应的</p>
<p>trackOperationPerSecond 函数跟服务器状态中的四个 ops_sec_开头的属性都有关：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span><span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token comment">// 上次抽样时间</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> ops_sec_last_sample_time<span class="token punctuation">;</span>
    <span class="token comment">// 上次抽象时，服务器已执行命令的数量</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> ops_sec_last_sample_ops<span class="token punctuation">;</span>
    
    <span class="token comment">// REDIS_OPS_SEC_SAMPLES 大小（默认值16）的环形数组，</span>
    <span class="token comment">// 数组中的每个项都记录了一次抽象结果</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> ops_sec_samples<span class="token punctuation">[</span>REDIS_OPS_SEC_SAMPLES<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token comment">// ops_sec_samples 数组的索引值，</span>
    <span class="token comment">// 每次抽样后将值自增1</span>
    <span class="token comment">// 在值等于16时重置为0</span>
    <span class="token comment">// 让 ops_sec_samples 数组构成一个环形数组</span>
    <span class="token keyword">int</span> ops_sec_idx<span class="token punctuation">;</span>
    
    <span class="token comment">// ...</span>
        
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>trackOperationPerSecond 函数每次运行，都会根据 ops_sec_last_sample_time 记录的上一次抽样时间和服务器的当前时间，以及上次执行的命令数量和当前已执行的命令数量，计算出两次trackOperationPerSecond 函数调用之间，平均每ms处理了多少个请求，然后再将该值乘以1000，就得到了服务器每s处理了多少个请求的估计值，然后放入 ops_sec_samples 数组里</p>
<p>伪代码实现 getOperationsPerSecond 函数,，其值对应为 instantaneous_ops_per_sec：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">getOperationsPerSecond</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> j<span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 计算所有取样值的总和</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>REDIS_OPS_SEC_SAMPLES<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        sum<span class="token operator">+=</span>server<span class="token punctuation">.</span>ops_sec_samples<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 计算取样的平均值</span>
    <span class="token keyword">return</span> sum<span class="token operator">/</span>RESID_OPS_SEC_SAMPLES<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>更新服务器内存峰值记录</strong></p>
<p>每次执行 serverCron 函数时，都会查看服务器当前使用的内存数量，并与以前的比较，取max</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span><span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    
    <span class="token comment">// 已使用的内存峰值</span>
    size_t stat_peak_memory<span class="token punctuation">;</span>
    
    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>INFO memory的两个状态记录着内存的峰值</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">redis&gt; INFO memory
# MEMORY
...
used_memory_peak:689464
used_memory_peak_human:673.30K
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>处理 SIGTERM 信号</strong> </p>
<p>启动服务器时，服务器进程的 SIGTERM 信号关联处理器 sigtermHandler 函数，这个函数负责在服务器接到 SIGTERM 信号时，打开服务器状态的 shutdown_asap 标识</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sigtermHandler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">{</span>
    
    <span class="token comment">// 打印日志</span>
    <span class="token function">redisLogFromHandler</span><span class="token punctuation">(</span>REDIS_WARNING<span class="token punctuation">,</span><span class="token string">"Received SIGTERM, scheduling shutdown..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 打开关闭标识</span>
    server<span class="token punctuation">.</span>shutdown_asap<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>每次serverCron 函数运行时，程序都会对服务器状态的 shutdown_asap 属性进行检查，并根据其值决定是否关闭服务器</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span><span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    
    <span class="token comment">// 关闭服务器标识</span>
    <span class="token keyword">int</span> shutdown_asap<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>并且在关闭前，需要 DB saved on dist</p>
<p><strong>管理客户端资源</strong></p>
<p>serverCron 函数还会调用 clientsCron 函数，clientsCron 函数会对一定数量的客户端进行下面两个查询：</p>
<ul>
<li>如果客户端与服务器之间的连接已经超时（很长一段时间没有互动），那么就会释放这个客户端</li>
<li>如果客户端上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序就会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存</li>
</ul>
<p><strong>管理数据库资源</strong></p>
<p>定期删除</p>
<p><strong>执行被延迟的 BGREWRITEAOF</strong></p>
<p>在服务器执行 BGSAVE 命令的期间，如果客户端向服务器发来 BGREWRITEAOF 命令，那么其命令就会等到BGSAVE 命令执行完毕后再执行</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span><span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    
    <span class="token comment">// 如果值为1，则表示有 BGREWRITEAOF 命令被延迟</span>
    <span class="token keyword">int</span> aof_rewrite_scheduled<span class="token punctuation">;</span>
    
    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>每次 serverCron 时，都会判断当前 BGSAVE 或者 BGREWRITEAOF 命令是否执行，若没，则判断 aof_rewrite_scheduled 的值</p>
<p><strong>检查持久化操作的运行状态</strong></p>
<p>记录 BGSAVE命令和 BGREWRITEAOF命令的子进程ID，用于检查其是否正在执行</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span><span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    
    <span class="token comment">// 记录执行 BGSAVE命令子进程的ID</span>
    <span class="token comment">// 如果服务器没有执行这个子进程，其值为-1</span>
    pid_t rdb_child_pid<span class="token punctuation">;</span>
    
    <span class="token comment">// 记录 BGREWRITEAOF命令子进程的ID</span>
    pid_t aof_child_pid<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>每次执行 serverCron 函数时，会检查 rdb_child_pid 和 aof_child_pid 两个属性的值。</p>
<p>若其中一个不为-1，则执行 wait3 函数，检查子进程是否有信号发来服务器进程：</p>
<ul>
<li>如果有，证明 RDB 文件或者 AOF 文件已经新生成，需要进行后续操作，如替换老文件等</li>
<li>如果没有，就表明未完成，不做处理</li>
</ul>
<p>若两个都不为-1，则表明服务器没有在进行持久化操作，那么就会做下面三个检查：</p>
<ul>
<li>查看是否有 BGREWRITEAOF 被延迟了，如果有就执行</li>
<li>检查服务器自动保存条件是否满足，如果满足，并没有执行其它持久化操作（因为上一个检查中，可能会执行 BGREWRITEAOF，所以这里会再检查一次），那么就会开始一次新的 BGSAVE 操作</li>
<li>检查服务器设置的AOF重写条件是否满足。如果满足，并没有执行其它持久化操作，就会执行一次新的 BGREWRITEAOF 操作</li>
</ul>
<p><strong>将AOF缓冲区中的内容写入AOF文件</strong></p>
<p><strong>关闭异步客户端</strong></p>
<p>关闭输出缓冲区超出大小限制的客户端</p>
<p><strong>增加 cronloops 计数器的值</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span><span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token comment">// 记录 serverCron 函数的运行次数计数器</span>
    <span class="token keyword">int</span> cronloops<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其作用为复制模块的每N次就执行一次指定代码</p>
<h2 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h2><p>一个服务器从启动到能接受客户端端命令请求的过程</p>
<h3 id="初始化服务器状态结构"><a href="#初始化服务器状态结构" class="headerlink" title="初始化服务器状态结构"></a>初始化服务器状态结构</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">initServerConfig</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 设置服务器的运行id</span>
    <span class="token function">getRandomHexchars</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>runid<span class="token punctuation">,</span>REDIS_RUN_ID_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 为运行id加上结尾字符</span>
    server<span class="token punctuation">.</span>runid<span class="token punctuation">[</span>REDIS_RUN_ID_SIZE<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'\0'</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 设置默认配置文件路径</span>
    server<span class="token punctuation">.</span>configfile<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 设置默认服务器频率</span>
    server<span class="token punctuation">.</span>hz<span class="token operator">=</span>REDIS_DEFAULT_HZ<span class="token punctuation">;</span>
    
    <span class="token comment">// 设置服务器的运行架构</span>
    server<span class="token punctuation">.</span>arch_bits<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token number">64</span><span class="token operator">:</span><span class="token number">32</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 设置默认服务器端口号</span>
    server<span class="token punctuation">.</span>port<span class="token operator">=</span>REDIS_SERVERPORT<span class="token punctuation">;</span>
    
    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>initServerConfig 函数的主要工作：</p>
<ul>
<li>设置服务器运行的ID</li>
<li>设置服务器的默认运行频率</li>
<li>设置默认配置文件</li>
<li>设置运行架构</li>
<li>设置默认端口号</li>
<li>设置默认RDB持久化条件和AOF持久化条件</li>
<li>初始化服务器的LRU时钟</li>
<li>创建命令表</li>
</ul>
<p>initServerConfig函数设置的服务器状态属性基本都是一些整数、浮点数、或者字符串等属性，除命令表外，该函数没有创建服务器状态的其他数据结构，数据库、慢查询日志、Lua环境、共享对象等</p>
<h3 id="载入配置选项"><a href="#载入配置选项" class="headerlink" title="载入配置选项"></a>载入配置选项</h3><p>在启动服务器时，用户可以通过配置参数或者指定配置文件来修改服务器的默认配置</p>
<p>如：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ redis-server --port 10086<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>载入配置文件</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 服务器的数据库数量设置为 32 个</span>
database 32
<span class="token comment"># 关闭 RDB 文件压缩功能</span>
rdbcompression no<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">$ redis-server redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>initServerConfig 函数初始化完 server变量后，就会载入用户给定的配置参数和配置文件，并对相关属性进行修改</p>
<h3 id="初始化服务器数据结构"><a href="#初始化服务器数据结构" class="headerlink" title="初始化服务器数据结构"></a>初始化服务器数据结构</h3><p>除了命令表，服务器状态还包含了其他数据结构，如：</p>
<ul>
<li>server.clients 链表：记录所有与服务器连接的客户端状态</li>
<li>server.db 数组：所有数据库</li>
<li>server.pubsub_channels 字典：频道的订阅信息</li>
<li>server.pubsub_patterns 链表：模式订阅信息</li>
<li>server.lua：用于执行 Lua 脚本的Lua环境</li>
<li>server.slowlog：保存慢查询日志的属性</li>
</ul>
<p>配置好这些后，服务器又会调用 initServer 函数，为以上数据分配内存，并在有需要时进行数据结构设置或关联初始值</p>
<p>initServerConfig 函数主要负责初始化一般属性，initServer 负责数据结构</p>
<p>initServer 除了数据结构之外，还包括以下操作：</p>
<ul>
<li>为服务器设置进程信号处理器</li>
<li>创建共享对象：如 “OK”和”ERR”等回复的字符串对象，整数1~10000的字符串对象等</li>
<li>打开服务器监听端口，并为监听套接字关联连接应答事件处理器</li>
<li>为serverCron 函数创建事件时间</li>
<li>如果AOF持续化开启，则打开AOF文件，没有就创建一个新的</li>
<li>初始化服务器后台的IO模块</li>
</ul>
<p>initServer 函数执行完毕后，就会在终端打印出 Redis 图标和版本信息等</p>
<h3 id="还原数据库状态"><a href="#还原数据库状态" class="headerlink" title="还原数据库状态"></a>还原数据库状态</h3><p>完成了对服务器状态的初始化后，根据需要载入的 RDB 文件或AOF 文件，还原数据库状态</p>
<p>载入完毕后，会打印 “DB loaded from disk: 0.068 seconds”</p>
<h3 id="执行事件循环"><a href="#执行事件循环" class="headerlink" title="执行事件循环"></a>执行事件循环</h3><p>初始化最后一步，打印出 “The server is now ready”</p>
<p>并开始执行事件循环（loop）</p>
<p>至此服务器的初始化就算完成</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Noodles2hg</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://github.com/z-anshun/2022/04/03/dan-ji-shu-ju-ku-de-shi-xian/">https://github.com/z-anshun/2022/04/03/dan-ji-shu-ju-ku-de-shi-xian/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Noodles2hg</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/books/">
                                    <span class="chip bg-color">books</span>
                                </a>
                            
                                <a href="/tags/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">
                                    <span class="chip bg-color">redis设计与实现</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/04/09/duo-ji-shu-ju-ku/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="多机数据库">
                        
                        <span class="card-title">多机数据库</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-04-09
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/redis/" class="post-category">
                                    redis
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/books/">
                        <span class="chip bg-color">books</span>
                    </a>
                    
                    <a href="/tags/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">
                        <span class="chip bg-color">redis设计与实现</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/03/28/di-ceng-jie-gou/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="底层结构">
                        
                        <span class="card-title">底层结构</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-03-28
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/redis/" class="post-category">
                                    redis
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/books/">
                        <span class="chip bg-color">books</span>
                    </a>
                    
                    <a href="/tags/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">
                        <span class="chip bg-color">redis设计与实现</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2020-2022</span>
            
            <span id="year">2020</span>
            <a href="/about" target="_blank">Noodles2hg</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/z-anshun" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1179798460@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1179798460" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1179798460" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
