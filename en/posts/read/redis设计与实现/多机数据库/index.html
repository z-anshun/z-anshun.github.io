<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/z-anshun/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=z-anshun/livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>多机数据库 | Noodles2hg的博客</title>
<meta name="keywords" content="redis设计与实现, Books">
<meta name="description" content="复制 用户通过执行 SLAVEOF 命令或设置 slaveof 选项，会让一个服务器成为另一个服务器的从服务器 如： 1 127.0.0.1:12345&gt; SLAVEOF 127.0.0.1 6379 127.0.0.1:12345 就会成为 127.0.0.1:6379 的从服务器 旧版复制功能的实现 Redis 的复制分">
<meta name="author" content="Noodles2hg">
<link rel="canonical" href="http://localhost:1313/z-anshun/en/posts/read/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/">
<link crossorigin="anonymous" href="/z-anshun/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/z-anshun/img/Q.gif">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/z-anshun/img/Q.gif">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/z-anshun/img/Q.gif">
<link rel="apple-touch-icon" href="http://localhost:1313/z-anshun/Q.gif">
<link rel="mask-icon" href="http://localhost:1313/z-anshun/Q.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/z-anshun/en/posts/read/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="多机数据库" />
<meta property="og:description" content="复制 用户通过执行 SLAVEOF 命令或设置 slaveof 选项，会让一个服务器成为另一个服务器的从服务器 如： 1 127.0.0.1:12345&gt; SLAVEOF 127.0.0.1 6379 127.0.0.1:12345 就会成为 127.0.0.1:6379 的从服务器 旧版复制功能的实现 Redis 的复制分" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/z-anshun/en/posts/read/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-09T01:22:12+00:00" />
<meta property="article:modified_time" content="2022-04-09T01:22:12+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="多机数据库"/>
<meta name="twitter:description" content="复制 用户通过执行 SLAVEOF 命令或设置 slaveof 选项，会让一个服务器成为另一个服务器的从服务器 如： 1 127.0.0.1:12345&gt; SLAVEOF 127.0.0.1 6379 127.0.0.1:12345 就会成为 127.0.0.1:6379 的从服务器 旧版复制功能的实现 Redis 的复制分"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/z-anshun/en/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📕阅读",
      "item": "http://localhost:1313/z-anshun/en/posts/read/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "多机数据库",
      "item": "http://localhost:1313/z-anshun/en/posts/read/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "多机数据库",
  "name": "多机数据库",
  "description": "复制 用户通过执行 SLAVEOF 命令或设置 slaveof 选项，会让一个服务器成为另一个服务器的从服务器 如： 1 127.0.0.1:12345\u0026gt; SLAVEOF 127.0.0.1 6379 127.0.0.1:12345 就会成为 127.0.0.1:6379 的从服务器 旧版复制功能的实现 Redis 的复制分",
  "keywords": [
    "redis设计与实现", "Books"
  ],
  "articleBody": "复制 用户通过执行 SLAVEOF 命令或设置 slaveof 选项，会让一个服务器成为另一个服务器的从服务器\n如：\n1 127.0.0.1:12345\u003e SLAVEOF 127.0.0.1 6379 127.0.0.1:12345 就会成为 127.0.0.1:6379 的从服务器\n旧版复制功能的实现 Redis 的复制分为同步（sync）和命令传播（command propagate）两个操作：\n同步用于将从更新至主服务得状态 命令传播用于主给从传播命令，达到状态更新 同步\n当客户端向从服务器发送 SLAVEOF 命令，要求从服务器复制主服务器时，会首先向主服务器进行同步\n步骤：\n从向主发送SYNC命令 主收到SYNC后，执行 BGSAVE 命令，生成RDB文件，并使用一个缓冲区记录从现在开始得写命令 当主执行完BGSAVE命令后，将生成RDB发送给从，然后从载入对应的RDB文件 主将缓冲区的命令发送给从 命令传播\n主从服务器为了保持一致性，主服务器会将写入的新命令发给从服务器\n旧版复制功能的缺陷 从对主的SYNC只有下面两种情况：\n初次复制：从以前从未复制过任何主，或者从当前要复制的主和上一次的不同 断线后重复制：从断线后，自动又连上主服务器 很明显，初次复制使用SYNC还行，但是断线后重复制来说，效率就显得很低了\n新版复制功能的实现 为了解决旧版断线后复制的缺陷，后续版本使用 PSYNC 代替 SYNC 命令来执行复制时的同步操作\nPSYNC 具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式：\n完整同步用于处理初次复制的情况，跟SYNC命令的执行步骤基本一样 部分同步用于处理断线后重复制的情况，将断开连接期间执行的写命令发送给从服务器，那么从服务器只用接收并执行这些写命令即可 部分重同步的实现 部分重同步功能主要由下面三个部分组成：\n主的复制偏移量（replication offset）和从的复制偏移量 主的复制积压缓冲区（replication backlog） 服务器的运行ID（run ID） 复制偏移量\n执行复制的双方，即主从都会维护一个偏移量：\n主每次向从传播N个字节的数据时，就会将自己的偏移量的值加上N 从收到主传播来的N个字节的数据时，也会将自己的复制偏移量加上N 那么，通过对比主从的偏移量，就能知道当前两个服务器的状态是否处于一致了\n复制积压缓冲区\n由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB\n当服务器进行命令传播时，不仅会将写命令发送给所有从服务器，还会将其入队到复制积压缓冲区里\n因此，主服务器就会保存着一部分最近传播的写命令，并且复制积压缓冲区还会为队列中的每个字节记录相应的复制偏移量\n因此，当从重新连接上主时，从会通过 PSYNC 命令将自己的offset发送给主，主服务器会根据这个offset来判断执行何种操作：\n如果offset之后的数据在复制积压缓冲区里，那么就执行部分同步操作 如果不在，就全同步 注意：复制积压缓冲区的默认为1MB，但如果主服务器执行的写操作过多，而且从断开的时间过长，那么这个显然时不恰当的，需要进行调整，一般设置为 2*second*write_size_per_second，这里的second为重连的平均时间，write_size_per_second为主服务器平均每秒产生写命令的数据量（协议格式的些命令的长度）,这样绝大多数都能实现部分同步\n服务器运行ID\n除了复制偏移量和复制积压缓冲区之外，实现部分重同步还需要用到服务器运行ID（run ID）:\n每个服务器，无论主从，都会有自己运行的ID 运行的ID会在运行时自动生成，由40个随机的16进制字符组成 当从对主进行初次复制时，主服务器会将自己运行ID传送给从服务器，而从则会将这个运行ID保存起来\n那么在重连时，从服务器则会将这个ID发送给主，如果当前主的ID与从发送过来的一样，则尝试部分复制，反之就是SYNC\nPSYNC 命令的实现 在了解了服务器运行ID、复制偏移量和复制积压缓冲区后，就能理解 PSYNC 命令的完整细节了\nPSYNC 命令的调用方法有两种：\n如果从没有复制过主，或者之前执行过 SLAVEOF no one命令，那么从会开始一次新的复制时将向主发送PSYNC ? -1命令，请求完整同步 如果从已经复制过某个主机，那么在开启一次新的复制时，将向主发送PSYNC 根据收到的 PSYNC ，主服务器会回复下面三种的某一种：\n+FULLRESYNC ：执行完整同步操作，offset为主服务器当前的复制偏移量 +CONTINUE ?：执行部分同步操作 -ERR：主服务器版本过低，无法识别PSYNC命令，进而从会再向主发送SYNC命令 复制的实现 SLAVEOF 让从复制一个主服务器\n1. 设置主服务器的地址和端口\n执行SLAVEOF 命令后，从服务器会保证设置的 ip和端口\n1 2 3 4 5 6 7 8 struct redisServer{ // ... char *masterhost; int masterport; // ... } SLAVEOF 命令为一个异步命令，在完成对应的属性设置后，服务器会向客户端返回一个OK，而真正的复制工作会在OK返回之后真正执行\n2. 建立套接字连接\nSLAVEOF 命令执行之后，从会根据ip和端口，创建与主服务器的套接字连接\n3. 发送PING命令\n从服务器成为主的客户端后，做的第一件事就是向主发送一个PING命令\nPING有两个作用：\n检查套接字的读写是否正常 检查主服务器是否正常处理命令请求 从服务器PING后会遇到下面三种情况之一：\n如果主向从返回了一个命令回复，而从不能却不能在规定时间内读出内容（即超时），那么表示当前网络状况不佳，不能继续后续工作。每当出现这种情况，从会断开连接并重新连接主的套接字 如果主返回一个错误，那么表示主服务器暂时没法处理从服务器的命令请求，不能继续执行后续步骤。这是从会断开连接，并重新创建连向主的套接字 如果从读取到了\"PONG\"回复，那么表示当前状态正常 4. 身份验证\n从收到\"PONG\" 后，就需要进行下一步，即身份验证\n如果从服务器设置了 masterauth选项，就需要进行身份验证，反之，就不需要\n那么在需要进行身份验证的情况下，从服务器会向主发送一条AUTH命令，其参数为 masterauth 选项的值\n在进行身份验证时，可能遇到下面几个情况：\n如果主没有设置 requirepass 选项，并且从也没有设置 masterauth，那么主将继续执行从服务器发送的命令，即复制工作继续执行 如果从通过AUTH命令发送的密码和主 requirepass 选项所设置的密码相同，那么主将继续执行从发送的命令；反之就返回一个 invalid password 错误 如果主设置了 requirepass 选项，但从没有设置 masterauth。那么主服务器会返回一个 NOAUTH 错误。 如果主没设置requirepass选项，而从设置了 AUTH，那么主服务器就会返回一个 no password is set错误 所有错误情况都会让从服务器中止目前的复制工作，并创立套接字，重新执行，直到验证通过\n5. 发送端口信息\n在身份验证之后，从会执行 REPLCONF listening-port ，向主服务器发送从监听的端口\n主服务器接收到之后，就将其记录在对应客户端状态中：\n1 2 3 4 5 6 7 typedef struct redisClient{ // ... // 从服务器监听的端口号 int slave_listening_port; // ... }redisClient; slave_listening_port 唯一的作用，是主服务器在执行 INFO replication 命令时，打印出从服务器监听的端口\n6. 同步\n上面的都执行完后，从服务器将发送 PSYNC 命令，这是主为从的客户端\n7. 命令传播\n心跳检测 在命令传播的阶段，从默认会以每秒一次的频率，向主发送命令：\nREPLCONF ACK 其中的replication_offset 就是从服务器当前的偏移量\n发送这个命令，主要是检测主从服务器的网络连接状态、辅助实现 min-slaves选项和检测命令丢失\n检测主从服务器的网络连接状态\n主从服务器通过发送和接收 REPLCONF ACK 命令来检查两者之间的网络连接是否正常\n如果超过1s没收到了从服务器发来的 REPLCONF ACK 命令，那么主服务器就认为主从之间的连接失效\n通过向主服务器发送INFO replication 命令，在列出的从服务器列表的lag一栏中，我们能看到距离上一次发送过了多少秒，因此值一般为0或者1\n辅助实现 min-slaves 配置选项\nRedis 的 min-slaves-to-write 和 min-slaves-max-lag 两个选项可以防止主服务器在不安全的情况下执行写命令\n如：\n1 2 min-slaves-to-write 3 min-slaves-max-lag 10 那么在从服务器少于三个，或者三个从服务器的延迟（lag）的值都大于或等于10s时，主服务器就会拒绝执行写命令\n检测命令丢失\n因为 REPLCONF ACK 命令会传递偏移值，所有命令丢失就会很快发现，进而主服务器在重新进行命令传递即可\nSentinel Sentinel（哨岗、哨兵）是Redis高可用性（high availability）解决方案：\n由一个或多个 Sentinel 实例（instance）组成的 Sentinel系统（system），可以监视多个主服务器，和它们属下的所有从服务器，并在主下线时，然后将一个从配置为主。\n具体步骤：假设当前server1为主服务器，并且下线时长超过了限制\n首先，Sentinel系统会挑选server1属下的其中一个从服务器，将其升级为主服务器 然后，Sentinel 系统会向server1属下的所有从服务器发送新的复制命令，让它们成为新的主服务器的从，当所有从都完成了复制时，故障转移操作即执行完毕 另外，当server1重新上线时，它将会被设置为新当选的从服务器 启动并初始化Sentinel 如何启动一个Sentinel？\nredis-sentinel sentinel.conf 或者 redis-server sentinel.conf --sentinel\n一个Sentinel启动时，大致需要执行哪些步骤？\n初始化服务器 将Redis服务器使用的代码替换为 Sentinel 专用的代码 初始化 Sentinel 状态 根据给定的配置文件，初始化Sentinel 监视的主服务器列表 创建与主之间的网络连接 初始化服务器\nSentinel本质上也是一个特殊的Redis服务器，所有很多部分都跟Redis服务器初始化相同。\n比如：Sentinel不需要数据库，因此就不需要加载RDB或者AOF，也不需要 BGSAVE或SAVE等命令；或者都需要时间事件处理器，只是sentinel的serverCron会执行 sentinel.c/sentinelTimer 函数\n使用Sentinel专用代码\n将一部份普通Redis服务器使用的代码替换为 Sentinel 专用代码\n如：将redis.h/REDIS_SERVERPORT 常量替换为 sentinel.c/REDIS_SENTINEL_PORT\n1 #define REDIS_SERVERPORT 6379 1 #define REDIS_SENTINEL_PORT 26379 并且，在加载命令方面，Sentinel模式下使用 sentinel.c/sentinelInfoCommand函数，因此根本没载入SET、DEL等命令，只有 PING、SENTINEL、INFO、SUBSCRIBE、UNSUBSCRIBE、PSUBSCRIBE、PUNSUBSCRIBE七个命令\n初始化 Sentinel 状态\n应用专用代码后，跟 redisServer结构体一样，sentinel也有一个结构体用来保存状态\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct sentinelState{ // 当前纪元，用于故障转移 uint64_t current_epoch; // 保存所有被监视的服务器 // 字典键为主服务器的名 // 值为指向 sentinelRedisInstance 结构的指针 dict *master; // 是否进入 TILT 模式 int tilt; // 当前正在执行的脚本数 int running_scripts; // 进入 TILT 模式的时间 mstime_t tilt_start_time; // 最后一次执行时间处理器的时间 mstime_t previous_time; // 一个FIFO队列，包含所有需要执行的脚本 list *scripts_queuq; }sentinel; 初始化 Sentinel 状态的 masters 属性\nSentinel状态的 master 字典记录了所有被 Sentinel 监视的主服务器的相关属性\n其字典保存的值就为实例结构，即 sentinelRedisInstance\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 typedef struct sentinelRedisInstance{ // 记录实例的类型，以及当前实例的状态 int flags; // 实例名字 // 主服务器的名字由用户在配置文件进行配置 // 从以及Sentinel的名字由Sentinel自动配置 // 格式为 ip:port, 如\"127.0.0.1:12345\" char *name; // 实例的运行ID char *runid; // 配置纪元，用于实现故障转移 uint64_t config_epoch; // 实例的地址 sentinelAddr *addr; // SENTINEL down-after-milliseconds 选择设置的值 // 实例无响应多少ms后被判断为主观下线（subjectively down） mstime_t down_after_period; // SENTINEL monitor 选项中的 quorum 参数 // 判断这个实例为客户下线（objectively down）所需要支持的投票数 int quorum; // SENTINEL parallel-syncs 选项的值 // 在执行故障操作时，可以同时对新的主服务器进行同步的从服务器数量 int parallel_syncs; // SENTINEL failover-timeout // 刷新故障转移状态的最大时间 mstime_t failover_timeout; // ... }sentinelRedisInstance; 1 2 3 4 typedef struct sentinelAddr{ char *ip; int port; }sentinelAddr; 初始连接向主服务器的网络连接\n最后一步就是创建连向被监视的主机服务器的网络连接，Sentinel 在此时做客户端的职责，可以向主服务器发送命令\n对于被监视的主服务器，Sentinel 会创建两个连向主服务器的异步网络：\n命令连接：专门用于向主服务器发送命令，并接收命令回复 订阅连接：专门用于订阅主服务器的 __sentinel__:hello频道 为什么是两个连接？\n因为Redis的发布和订阅中，被发送的消息都不会存在Redis服务器中。如果在信息发送时因为接收端断线，导致信息丢失，因此为了不丢失信息，所以需要一个专门的连接，来接收__sentinel__:hello频道的信息 处理订阅频道之外，还有命令的传递，所以还必须向主服务器创建命令连接 因为Sentinel会与多个实例相连，所以这里使用异步连接 获取主服务器信息 Sentinel 会默认每10s一次，通过命令连接向被监视的主服务器发送INFO命令，并通过分析回复来获取但主服务器当前的信息\n通过分析INFO命令的回复，Sentinel 可以获取下面两个方面的信息：\n关于主服务器本身的信息：包括run_id 域记录的服务器运行ID，role域记录的服务器角色 关于主服务器下所有从服务器的信息：每个从都由一个\"salve\"字符串开头的行记录，包括ip、port等。因此根据这些IP和端口号，Sentinel 就无须用户提供从服务器的地址信息 又因为得到了主服务器的run_id 和 role等信息，Sentinel 将对主服务器的实例结构进行更新。如主服务器重重启之后，它的ID会与之间的保存不同，这时候就需要进行更新\n对于返回的从服务器状态，则会用于更新主服务器实例结构的 slaves 字典，这个字典记录了主服务器属下的从服务器名单：\n键：Sentinel 自动设置的名字，格式为IP:port 值：从服务器对对应的实例结构，即 sentinelRedisInstance 获取从服务器信息 当 Sentinel 发现主有新的从服务器时，Sentinel 除了会为它创建新的实例之外，还会创建连接到从服务器的命令连接和订阅连接\nSentinel 默认情况下，向从发送 INFO 命令，获得以下内容的回复：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Server ... run_id: ... ... # Replication role:slave master_host:127.0.0.1 master_port:6379 master_link_status:up slave_repl_offset:11887 slave_priority:100 # Other sections ... 根据INFO，Sentinel 会提取出下面信息：\n从服务器的运行ID： run_id 从服务器的角色：role 主服务器的IP地址 master_host，主服务器的端口号 master_port 主从服务器的连接状态 master_link_status 从服务器的优先级 slave_priority 从服务器的复制偏移量 slave_repl_offset 向主从服务器发送信息 默认情况下，Sentinel 会以2s一次的频率，通过命令连接向所有被监视的主服务器和从发送下面格式的命令：\nPUBLISH __sentinel__:hello \",,,,,,,\"\n其中,s_开头的为 Sentinel的信息，而m_开头的参数记录的为主机服务器的信息，如果监视的为主，那就是主的信息，如果是从，那就是从所属主的信息\n接收来自主从服务器的频道信息 当Sentinel与一个主或从连接起连接订阅连接后，Sentinel 就会通过订阅连接，也订阅频道 SUBSCRIBE __sentinel__:hello\n这个订阅会一直持续到Sentinel与服务器的连接断开为止\n也就是说，Sentinel 既通过这个频道发布信息，也接受信息。\n那么，对于监视同一个服务器的多个Sentinel而言，一个Sentinel 发送的信息也就会被其他 Sentinel 接收到，这些信息会被用于更新其它Sentinel 的认知\n当 Sentinel 从 __sentinel__:hello频道收到一条信息时，会对这条信息进行分析，提取出其 Sentinel 的IP、端口号、运行ID等八个参数\n如果信息中的运行ID和本机的一样，那么就是自己发送的，直接丢弃 如果不同，就证明是其它其它Sentinel发送来的，更新对应主服务器的实例结构 更新 sentinels 字典\nSentinel 为主服务器创建的实例结构中的 sentinels 字典保存了除了 Sentinel 本身之外，还有监视这个服务器的其它 Sentinel 的资料：\n键：Sentinel的名字，格式为 ip:port 值：对应的 Sentinel 实例结构 Sentinel会从其它Sentinel收到的信息分析并提取出下面两方面的参数：\n与Sentinel 有关的参数：源 Sentinel 的ip、端口、运行ID和配置纪元 与主服务有关的参数：源 Sentinel 正在监视的主服务器的名字、Ip、端口号和配置纪元 根据提取到的参数，Sentinel 就会再自己的 masters字典中查询相应的实例结构，然后再根据查询到的主服务器实例查询相应的 sentinels 字典，判断源 Sentinel 实例是否存在。\n如果没存在，就创建，再更新字典，如果存在就更新\n为什么对应的主机实例，还需要创建 sentinels 字段？\n用于让一个 Sentinel 知道其它 Sentinel的存在，而且不需要用户提供其它 Sentinel 的地址信息，可以自动发现\n创建连向其它 Sentinel 的命令连接\n当一个 Sentinel 发现其它新的 Sentinel 时，不止会在相应的主机实例中更新字典，还会创建一个连向新 Sentinel 的命令连接\n注意：这里只用与其它 Sentinel 创建命令连接就行了，不需要订阅连接，因为之前的订阅是接收主从发来的频道信息发现未知的新 Sentinel，而这里就不需要了\n检测主观下线状态 默认情况下，Sentinel 会以1s一次的频率向所有与它创建了命令连接的实例（包括主从、其它 Sentinel）发送PING，并通过返回的命令，判断是否在线\n对应PING命令的回复可以分为下面两种情况：\n有效回复：实例返回 +PONG、-LOADING、-MASTERDOWN 三种中的某一个 无效回复：返回有效回复之外的回复，或者超时 Sentinel 配置文件中的 down-after-milliseconds 选项指定了判断主观下线的时间，也就是如果一个实例如果返回了无效返回，那么 Sentinel 会修改其对应的实例结构，即在其 flags 属性中打开 SRI_S_DOWN 标识，表示其已经主观下线\n注意：多个 Sentinel 设置的主观下线时长可能不同\n检测客观下线状态 当一个主服务器判断为主观下线后，为了确认这个主服务器是否是真的下线，它会对同样监视它的其它 Sentinel 进行询问，看它们是否为下线状态（即客观下线或主观下线），收到足够数量的已下线判断后，就将其认为客观下线状态，并进行故障转移\n发送 SENTINEL is-master-down-by-addr 命令\nSentinel 使用 SENTINEL is-master-down-by-addr 命令询问其它 Sentinel 是否同意主服务器已下线。\nip、port、current 都为主服务器的属性；runid可以为 * 或者 Sentinel 的运行id（*代表检查客观下线，Sentinel的运行id用来选举头领 Sentinel）\n接收 SENTINEL is-master-down-by-addr 命令\n当一个Sentinel 收到 SENTINEL 命令时，会分析其中包含的各个参数，根据其中的IP和端口，检查主是否已经下线，然后返回一条包含三个参数的 Multi Bulk 回复：\n1 2 3 1) 2) 3) down_state：返回主服务器的检查结果，1为已下线，0为未下线 leader_runid：可以是*符号或者为 Sentinel 的局部领头的runid leader_epoch：Sentinel 的局部领头 Sentinel 的配置纪元，用于选举领头，只有在 leader_runid 不为*是有用，否则就为0 如：\n1 2 3 1) 1 2) * 3) 0 则表明同意下线\n接收 SENTINEL is-master-down-by-addr 命令的回复\n当同一下线的 Sentinel 超过配置的 quorum 参数的值后，就会被认定为客观下线，将主服务器的 flags 属性的 SRI_O_DOWN 标识打开。\n注意：不同Sentinel 判断某个 主服务器为客观下线的条件是不同\n选举领头 Sentinel 当主服务器被判断为客观下线时，监视这个下线主服务器的各个 Sentinel会进行协商，选举一个头领，并由领头的进行故障转移\n如何选举？\n所有 Sentinel 都有被选举为临头的资格 每次临头选举之后，不论选举成功与否，所有 Sentinel 的配置纪元（configuration epoch）的值都会自增一次（配置纪元就是一个计数器） 一个配置纪元里面，所有 Sentinel 都有将某个 Sentinel 设置为局部领头的机会，而且一旦设置，在这个配置纪元里面就无法进行更改 每个发现主服务器进入客观下线的 Sentinel 都会请求其它的 Sentinel 将自己设置为局部领头 Sentinel 当Sentinel 发送的为 SENTINEL is-master-down-by-addr命令时，并且runid不为*,为自己的runid，就表明要求自己成为局部的领头 Sentinel 目标Sentinel回复收到的 SENTINEL命令，回复中leader_runid和leader_epoch 参数分别记录了目标 Sentinel 的局部领头的运行ID和配置纪元（如果当前还未配置局部领头，那么先来就会成为） 源 Sentinel 收到目标 Sentinel 对于 SENTINEL 的回复后，首先判断回复的 leader_epoch 参数是否跟自己的配置纪元，如果相同，就会进行判断 leader_runid 参数是否跟自己的运行id，如果相同，则表示目标已经认位源为局部领头 如果超过半数的 Sentinel 认为这个为局部领头，那么这个Sentinel就成为领头 如果该配置纪元在给定时间内未选出领头，那么各个 Sentinel 将在隔一段时间后，再次进行选举，直到选出 Sentinel 为止 故障转移 在选举出领头 Sentinel 后，其领头将会对已下线的主服务器执行故障转移操作\n在已下线的主服务器中选择一个从服务器，并将其转化为主服务器 让已下线主服务器属下的所有从服务器都改为复制新的主服务器 将已下线的主服务器设置为新的主的从，即，当以前的主服务器重连后，它会成为新的从服务器 选出新的主服务器\n选择一个状态良好、数据完整的从服务器，然后向这个从服务器发送 SLAVEOF no one 命令，将其转化为主服务\n这个新的主服务器是怎么选出来的？\n将已下线的主服务器的所有从服务器保存到一个列表中 删除已下线或者断线状态的从服务器，保证列表中剩余的从服务器都是正常在线的 删除列表中所有最近5s内没有回复过领头 Sentinel 的INFO命令的从服务器，保证剩余的都是最近成功进行通信过的 删除所有与已下线主服务器连接断开超过 down-after-milliseconds*10 ms的，保证数据较新 根据优先级、偏移量排序，选择最大的，如果都一样，则根据ID排序，选择最小的ID 然后，Sentinel 会向被选中的从服务器发送 SLAVEOF no one 命令，并且每1s都会向被升级的从服务器发送 INFO 命令（平时为每10s一次），当被升级的 role 从原来的 slave 变成 master 时，领头的就知道已经完成了升级\n修改从服务器的复制目标\n下一步就是剩下的从服务器去复制新的主服务器，即SLAVEOF命令\n将旧的主服务器变为从服务器\n因为旧的主已经下线，所以设置保存在了 server1 对应的实例结构里，当server1重新上线时，Sentinel 就会通过命令连接向它发送SLAVEOF命令\n集群 redis集群是redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供故障转移功能\n节点 CLUSTER MEET 命令用来连接各个节点，该node节点会与IP:port所指定的节点进行握手（handshake），当握手成功时，node节点就会将ip和port指定的节点加入当前node所在的集群中\n另外，CLUSTER NODES能查看当前集群里的所有节点\n启动节点\nRedis 服务器在启动时会根据 cluster-enabled 配置选项是否为yes来决定是否开启服务器的集群模式，反之就为单机（stand alone）模式\n节点也会继续使用所有在单机模式中的服务器组件，如：\n文件时间来处理命令请求和回复 时间事件处理器来执行 serverCron 函数，而serverCron函数也会调用集群特有的 clusterCron函数 数据库来保存键值对 RBD和AOF 另外，也会使用redisServer和redisClient。对于只有集群模式下才会用到的数据，节点将其保存到了 cluster.h/clusterNode 、clusterLink、clusterState结构里面\n集群的数据结构\n每个节点都会使用一个 clusterNode 来保存自己的状态，为集群中的其它节点（包括主从节点）都创建一个 clusterNode 结构，以此来记录其它节点的状态：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct clusterNode{ // 创建时间 mstime_t ctime; // 节点的名字，由40个十六进制字符组成 char name[REDIS_CLUSTER_NAMELEN]; // 节点标识 // 记录当前节点的角色（主从） // 以及当前所处的状态（是否下线） int flags; // 节点当前的配置纪元，用于实现故障转移 uint64_t configEpoch; // 节点的IP char ip[REDIS_IP_STR_LEN]; // 节点的端口号 int port; // 保存连接节点所需的有关信息 clusterLink *link; //... }; link属性为一个 clusterLink 结构，该结构保存了连接节点的有关信息：\n1 2 3 4 5 6 7 8 9 10 11 12 typedef struct clusterLink{ // 连接创建的时间 mstime_t ctime; // TCP 套接字描述符 int fd; // 输出缓冲区 sds sndbuf; // 输入缓冲区 sds rcvbuf; // 与这个连接相关联的节点，如果没有就为NULL struct clusterNode *node; }clusterLink; redisClient 和 clusterLink 的异同？\n同：都有自己的输入输出缓冲区和套接字描述符\n异：redisClient 中的缓冲区和套接字是用于与客户端之间的连接，而clusterLink为用于节点之间的连接\n最后，每个节点都保存着一个 clusterState结构，这个结构记录了在当前节点的视角下，集群目前所处的状态\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 typedef struct clusterState{ // 指向当前节点的指针 clusterNode *myself; // 集群当前的配置纪元 uint64_t currentEpoch; // 集群当前的状态 int state; // 集群中至少处理着一个槽的节点的数量 int size; // 集群节点的名单（包括myself） // 键位节点名字，值位 clusterNode 结构 dict *node; // ... }clusterState; CLUSTER MEET 命令的实现\n假设节点A像B发送CLUSTER MEET 命令，那么节点之间会进行握手（handshake），来确认彼此的存在，并为后续的通信打好基础：\n节点A会为B创建一个 clusterNode 结构，并将该结构添加到自己的 clusterState.nodes 字典里 节点A根据 CLUSTER MEET 给定的IP和端口号，向B发送一条MEET消息（message） 节点B收到A发送的MEET消息，节点B会为A创建一个 clusterNode 结构，然后将其加入到自己的 clusterState.nodes 字典里 节点B向A返回一条PONG消息 A节点通过这条PONG信息，确认B已经收到A的发送的MEET信息 然后，A又会向B发送一条PING消息 B收到A发送的PING，确认A已经收到自己的PONG，握手完成 最后，A会将B的信息通过 Gossip 协议传播给集群中的其它节点，让其它节点与B握手，最终，一段时候后，节点B就会被集群中的所有节点认识\n槽指派 Redis 集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽（slot），而数据库的每个键都属于这 16384 槽中的一个，集群中的每个节点可以处理0个或最多16384个槽\n只有当数据库中的16384个槽都有节点在处理时，集群才处于上线状态（ok），反之，则为下线状态（fail）\n通过向节点发送CLUSTER ADDSLOTS命令，可以将一个或多个槽指派（assign）给节点负责，如：\n1 2 # CLUSTER ADDSLOTS [slot ...] redis\u003e CLUSTER ADDSLOTS 0 1 2 3 4 ... 5000 记录节点的槽指派信息\nclusterNode 结构的 slots 属性和 numslot 属性记录了节点负责处理哪些槽：\n1 2 3 4 5 6 7 8 struct clusterNode{ // ... unsigned char slots[16384/8]; int numslots; // ... }; slots 属性为一个二进制数组（bit array），这个数组的长度为 2048 个字节，共 16384 个二进制位\n如果对应的 slots 位上的值为1，那边就代表负责处理槽i；反之为0，就不处理。\n那么，对于一个给定节点的 slots数组来说，检查是否负责处理某个槽或者指派某个槽给节点的时间复杂度为O(1)\n传播节点的槽指派信息\n一个节点不仅会记录自己的槽信息，还会将自己的slots数组通过消息发送给集群中的其它节点，以此来告知其它节点自己负责了哪些槽\n并且每个节点收到之后，还会在自己的 clusterState.nodes 找到相应的 clusterNode结构，并对结构中的 slots 数组进行保存或更新，这样每个节点都会知道整个集群分配的槽了\n记录集群所有槽的指派信息\nclusterState 结构中的 slots 数组记录了集群中所有 16384 个槽的指派信息：\n1 2 3 4 5 6 typedef struct clusterState{ // .. clusterNode *slots[16384]; // ... }; slots 数组包含 16384 个项，每项都指向一个 clusterNode 结构的指针：\n如果 slots[i] 指针指向 NULL，那么就表示槽 i 尚未指派给任何节点 反之就指向对应的节点 为什么需要 clusterNode.slots 数组 和 clusterState.slots 数组？\n如果节点只使用 clusterNode.slots 数组来记录槽的指派信息，那么当需要知道i是否被指派，或者i被谁指派时，就需要遍历 clusterState.nodes字典中的所有 clusterNode结构，并检查这些结构的 slots数组，时间复杂度为 O(n)；而对于 clusterState.slots 数组，只需要 O(1)的时间复杂度即可 当程序需要将某个节点的槽指派信息通过消息发送给其它信息时，程序只需要将相应节点的 clusterNode.slots 数组整个发送过去即可 CLUSTER ADDSLOTS 命令的实现\n伪代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 def CLUSTER_ADDSLOTS(*all_input_slots): # 遍历所有输入槽，检查是否未指派 for i in all_input_slots: # 如果有一个已经指派了，就返回错误，并终止命令 if clusterState.slots[i]!=NULL: reply_error() return # 都是未指派的 for i in all_input_slots: clusterState.slots[i]=clusterState.myself setSlotBit(clusterState.myself.slots,i) 在集群中执行命令 在数据库的 16384个槽都进行了指派后，集群就会进行上线状态，这时候客户端就可以向集群中的节点发送数据命令了\n当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，如果这个槽正好就指派给了当前节点，那么节点直接执行这个命令；如果没有指派给当前节点，那么就会返回一个 MOVED 错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令\n计算键属于哪个槽\n伪代码实现：\n1 2 def slot_number(key): return CYC16(key) \u0026 16383 使用 CYC16计算key的 CYC-16 校验和\n对于命令CLUSTER KEYSLOT ，可以查看给定键属于哪个槽：\n1 2 redis\u003e CLUSTER KEYSLOT \"date\" (integer) 2022 判断槽是否由当前节点负责处理\n在计算出键所属的槽i后，节点检查自己的 clusterState.slots 数组中的i项，判断其是否由自己负责\n如果是，就自己处理，反之就根据指针指向的 clusterNode结构所记录的IP和端口，向客户端返回 MOVED 错误\nMOVED 错误\n当节点发现该键并非自己处理时，就会向客户端返回一个 MOVED 错误，指引客户端转向至正在负责槽的节点。\nMOVED 错误格式为：MOVED :\n如：MOVED 10086 127.0.0.1:7002\n每次切换客户端不会造成开销？\n一个集群客户端通常会与集群中的多个节点创建套接字连接，所以实际上切换客户端，只是换一个套接字来发送命令。如果尚未连接，创建连接即可\n注意：集群模式下的 redis-cli 客户端在接收 MOVED 错误时，会自动切换，再打印出日志。只有在单机模式下，会将MOVED 错误打印出来，因为它不知道MOVED错误是什么\n节点数据库的实现\n节点对过期键的保存跟单机一样\n节点和单机在数据库方面的一个区别是，节点只能用0号数据库\n另外，除了将键值对保存在数据库里面之外，节点还会用 clusterState结构中的 slots_to_keys 跳跃表来保存槽和键之间的关系：\n1 2 3 4 5 6 7 typedef struct clusterState{ // ... zskiplist *slots_to_keys; // ... }clusterState; slots_to_keys 跳跃表每个节点的分值（score）都是一个编号，每个节点的成员都是一个数据库键\n那么，通过 slots_to_keys 跳跃表中记录的各个数据库键所属槽，就能方便对某个或某些槽的所有数据库键进行操作，如：CLUSTER GETKEYSINSLOT 返回最多count个属于槽slot的数据库键\n重新分片 重新分片：将任意数量个已经分派给某个节点的槽，分配给另一个节点，并且相关槽所属的键值对也会被移动到另一个节点\n重新分片可为在线进行，并且在重新分配过程中，集群不用下线，对应的节点也可以继续处理命令请求\n重新分片的实现原理\n由 Redis 的集群管理软件 redis-trib 负责执行，它通过向源节点和目标节点发送命令来重新分片操作\n对集群的单个槽 slot 进行重新分片的操作如下：\n对目标节点发送 CLUSTER SETSLOT IMPORTING 命令，让目标节点准备好从源节点导入（import）属于槽 slot 的键值对 对源节点发送 CLUSTER SETSLOT MIGRATING 命令，让源节点准备好将属于槽 slot 的键值对迁移（migrate）至目标节点 向源节点发送CLUSTER GETKEYSINSLOT 命令，获取最多 count个属于槽 slot 的键值对的键名 将步骤3获取的所有键名，遍历，并将每一个都向源节点发送一个MIGRATE 0 命令，即将被选中的键原子地从源迁移至目标 重复34步骤，直到所有键都被迁移 redis-trib 向集群中的任意一个节点发送 CLUSTER SETSLOT NODE 命令，即将槽 slot 指派给了目标节点，然后再发送给整个集群 ASK 错误 在进行重新分片的过程中，可能存在一部分键值对在源节点里面，而另一部分键值对则保存在目标节点里。\n那么，当这时用户查找某个键时，如果正在迁移过程中，且正好迁移到了目标节点，就会返回一个 ASK 错误，指引客户端转向正在导入的槽，并再次发送之前想要执行的命令\n注意：在群集下的 redis-cli 接到 ASK 错误时，也会跟 MOVED 一样，进行转向，也不会打印出错误\nCLUSTER SETSLOT IMPORTING 命令的实现\nclusterState 结构的 importing_slots_from 数组记录了当前节点正从其它节点导入的槽：\n1 2 3 4 5 6 7 typedef struct clusterState{ // ... clusterNode *importing_slots_from[16384]; // ... }clusterState; 在对集群重新进行分片时，会向目标节点发送：CLUSTER SETSLOT IMPORTING 如：\nCLUSTER SETSLOT 16198 IMPORTING 9df3...\nCLUSTER SETSLOT MIGRATING 命令的实现\nclusterState 结构的 migrating_slots_to 数组记录了当前节点正在迁移其它节点的槽：\n1 2 3 4 5 6 typedef struct clusterState{ // ... clusterNode *migrating_slots_to[16384]; // ... }clusterState; 在集群重新分片时，向源节点发送：ClUSTER SETLOT MIGRATING ASK 错误\n当节点未查找自己数据库中的键时，会查看 clusterState.migrating_slots_to[i] ，其i是否正在进行迁移，如果时，就会返回一个对应的ASK错误\n接收到ASK错误的客户端，会向目标节点发送一个ASKING 命令，之后再执行原本想执行的命令\nASKING 命令\nASKING 命令唯一要做的就是打开客户端的 REDIS_ASKING 标识\n伪代码实现：\n1 2 3 4 5 def ASKING(): # 打开标识 client.flags |= REDIS_ASKING # 向客户端返回 OK reply(\"OK\") 因为，若该节点判断没有改键时，会执行 MOVED 错误，\n然而，如果带有 ASKING 标识，节点就会继续执行客户端发送的命令\n注意：REDIS_ASKING 标识只能用一次，用一次之后便会被移除\n复制和故障转移 集群中的节点也分为主节点和从节点，主节点用于处理槽，而从节点用于复制某个主节点，并在被复制的主节点下线时，代替下线的主节点继续处理命令\n设置从节点\n向一个节点发送 CLUSTER REPLICATE 让接收的从节点进行对主节点的复制：\n接收到该命令的节点首先会在自己的 clusterState.nodes 字典中找到 node_id 对应的 clusterNode 结构，并将自己的 clusterState.myself.slaveof 指针指向这个结构，以此来表示该节点正在进行主节点的复制\n1 2 3 4 5 6 struct clusterNode{ // ... struct clusterNode *slaveof; // ... }; 修改自己的 clusterNode.myself.flags 中的标识，关闭原来的 REDIS_NODE_MASTER 标识，打开 REDIS_NODE_SLAVE 标识。表示这个节点已经由主变为了从\n节点调用复制代码，根据保存的主节点的IP和port，这里跟单机数据库一样，即相当于向从数据库发送SLAVEOF 另外，一个节点成为从节点，并开始复制某一个主节点这一信息会通过消息发送给集群中的其它节点，最终集群中的所有节点都会在知道某个从正在复制某个主节点\n集群中的所有节点都会在代表主节点的 clusterNode 结构的 slaves 属性和 numslaves 属性中记录正在复制这个主节点的名单：\n1 2 3 4 5 6 7 8 9 10 struct clusterNode{ // ... // 正在复制这个主节点的从节点数量 int numslaves; // 数组，指向复制该主节点的从节点名单 struct clusterNode **slaves; // ... }; 故障检测\n集群中的节点会定期向集群中其他节点发送 PING 信息，来检测对方是否在线，如果没有及时回复，就会将其标记为疑似下线（probable fail，PFAIL）\n集群中的各个节点之间还会通过互发消息的方式来交换集群中各个节点的状态信息，某个节点是处于在线状态、疑似下线状态（PFAIL）、还是已下线状态（FAIL）\n一个节点收到某个节点进入疑似下线状态时，会将节点的下线报告（failure report）添加到 clusterNode 结构的 fail_reports 链表里面：\n1 2 3 4 5 6 7 struct clusterNode{ // ... // 一个链表，记录所有其他节点对该节点的下线报告 list *fail_reports; // ... }; 每个下线报告都由 clusterNodeFailReport 结构表示：\n1 2 3 4 5 6 7 8 struct clusterNodeFailReport{ // 已下线的节点 struct clusterNode *node; // 最后一次从 node 节点收到下线报告的时间 // 用来检测这个报告是否过期，过得太久的下线报告会被删除 mstime_t time; }typedef clusterNodeFailReport; 当集群中超过半数以上负责槽的主节点都将某个主节点报告为疑似下线时，这个节点就会被标记为已下线（FAIL），并且将该节点已下线的消息广播给其他节点\n故障转移\n已下线的主所属的从节点中，选择一个 对被选中的从，执行 SLAVEOF no noe，成为主节点 将已下线的主的槽指派给自己 向集群广播一条 PONG消息，让其他节点知道自己已由从变为了主，并接管了原本主负责的槽 新主节点负责处理与槽有关的命令 选举新的主节点\n从节点向集群发送一条广播消息 CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST\n其他都跟选举主哨兵一样，超过半数、配置纪元等\n都是根据 Raft算法进行领头选举的\n消息 集群中的各个节点都是通过发送和接收消息（message）来进行通信的。由消息头（header）和消息正文（data）组成\n发送的消息主要有以下五种：\nMEET 消息：请求接收者加入到发送者当前所处的集群里 PING 消息：每个节点默认每隔1s就会从已知节点列表中随机选出五个节点，然后对五个节点中最久未发送过 PING 消息的节点发送 PING 消息，以此来检测被选中的节点是否在线。如果节点A最后一次收到节点B返回的PONG消息的时间，超过了当前节点A的 cluster-node-timeout 选项设置时长的一半，那么节点A也会向B发送PING，防止长期未选择到B而导致消息更新滞后 PONG 消息：当接收者收到发送者发来的 MEET 消息 或者 PING消息时，返回一条PONG。也可以向集群广播一条PONG，来刷新关于这个节点的认知。如：故障转移后的PONG，告知集群自己成为主节点 FAIL 消息：某个节点判断该节点已经为下线状态时，就会广播一条关于该节点的FAIL 消息 PUBLISH 消息：节点会执行这个命令，并向集群广播这个命令，让其它节点也执行 消息头\n记录消息发送者自身的一些信息，因为这些信息也会被消息接收者使用到\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 typedef struct{ // 消息的长度，包括了头和正文 uint32_t totlen; // 消息的类型 uint16_t type; // 消息正文包含的节点信息数量 // 只发送 MEET、PING、PONG三种 Gossip 协议消息时使用 uint16_t count; // 发送者的配置纪元 uint64_t currentEpoch; // 如果当前节点为主，这就是发送的配置纪元 // 如果为从，这就是发送者正在复制的主节点的配置纪元 uint64_t configEpoch; // 发送者的名字(ID) char sender[REDIS_CLUSTER_NAMELEN]; // 发送者目前的槽派信息 unsigned char myslots[REDIS_CLUSTER_SLOTS/8]; // 如果为从，就是主的名字 // 如果为主，这里记录的就是 REDIS_NODE_NULL_NAME char slaveof[REDIS_CLUSTER_NAMELEN]; // 发送者的端口号 uint16_t port; // 发送者的标识值 uint16_t flags; // 发送者所在的集群 unsigned char state; // 消息正文，也就是内容 union clusterMsgData data; }clusterMsg; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 union clusterMsgData{ // MEET、PING、PONG 消息的正文 struct { // 每条 MEET、PING、PONG 消息都包含两个 clusterMsgDataGossip 结构 clusterMsgDataGossip gossip[1]; }ping; // FAIL 消息的正文 struct{ clusterMsgDataFail about; }fail; // PUBLISH 消息的正文 struct{ clusterMsgDataPublish msg; }publish; // 其他消息的正文 }; clusterMsg 结构包含了一系列本节点的信息，那么接收者，就可以根据这些信息找到对应的 clusterNode结构并对其进行更新\nMEET、PING、PONG消息的实现\n因为这三种的正文消息都使用的 clusterMsgDataGossip 结构，所以节点通过消息头的 type 属性来判断一条消息为 MEET、PING、PONG 消息\n每次发送MEET、PING、PONG消息时，发送者都会从自己已知节点列表中随机选择两个节点（可以为主，也可以为从），并将这两个节点放到两个 clusterMsgDataGossip 结构中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 typedef struct{ // 节点的名字 char nodename[REDIS_CLUSTER_NAMELEN]; // 最后一次向该节点发送PING信息的时间戳 uint32_t ping_sent; // 最后一次从该节点收到 PONG 消息的时间戳 uint32_t pong_received; // 节点的IP地址 char ip[16]; // 节点的端口号 uint16_t port; // 节点的标识值 uint16_t flags; }clusterMsgDataGossip; 接收者会将接收到的 clusterMsgDataGossip 结构中记录的被选中的节点进行相应的操作：\n如果被选中节点不存在于已知节点列表，那么说明接收者第一次接触到被选中节点，然后根据 IP和 port等信息，进行握手 如果存在已知的节点列表，对节点信息进行更新即可 FAIL消息的实现\n当节点A认为节点B已下线时，节点A就会向集群广播一条关于节点B已经下线的FAIL消息\n在节点数量比较大的情况，单纯的使用Gossip 协议来传播节点已下线信息会给节点的信息带了一定的延迟，因为Gossip 会需要一段时间后，才会传播至整个集群，而发送 FAIL 消息，可以尽快的让集群知道，从而判断集群是否要标记为下线，或者尽快进行故障转移\nFAIL 消息的正文由 clusterMsgDataFail 结构进行表示，这个结构只包含一个 nodename 属性，记录已下线的节点名：\n1 2 3 typedef struct{ char nodename[REDIS_CLUSTER_NAMELEN]; }clusterMsgDataFail; PUBLISH 消息的实现\n当客户端向集群中的某个节点发送命令 PUBLISH 它不仅会向 channel 频道发送消息 message，还会广播一条 PUBLISH 消息，接收到的节点，也都会向 channel 频道发送 message 消息\nPUBLISH 消息的正文由 clusterMsgDataPublish 结构表示\n1 2 3 4 5 6 7 8 typedef struct{ uint32_t channel_len; uint32_t message_len; // 8字节是为对齐其它消息结构 // 实际的长度由保存的内容决定 unsigned char bulk_data[8]; }clusterMsgDataPublish; 其中，bulk_data 的 0~channel_len-1 字节保存的为 channel 参数；channel_len~channel_len+message_len+1 字节保存的为 message 参数\n为什么不直接向节点广播 PUBLISH 命令？\n这种做法不符合Redis集群的规则，即\"各节点通过发送和接收消息来进行处理通信\"\n",
  "wordCount" : "15589",
  "inLanguage": "en",
  "datePublished": "2022-04-09T01:22:12Z",
  "dateModified": "2022-04-09T01:22:12Z",
  "author":{
    "@type": "Person",
    "name": "Noodles2hg"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/z-anshun/en/posts/read/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Noodles2hg的博客",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/z-anshun/img/Q.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/z-anshun/en/" accesskey="h" title="Noodles2hg&#39;s Blog (Alt + H)">
                <img src="https://www.sulvblog.cn/Q.gif" alt="" aria-label="logo"
                    height="35">Noodles2hg&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/z-anshun/en/search/" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/z-anshun/en/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/z-anshun/en/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/z-anshun/en/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/z-anshun/en/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/z-anshun/en/links" title="🤝友链">
                    <span>🤝友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/z-anshun/en/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/z-anshun/en/posts/">Posts</a>&nbsp;»&nbsp;<a href="http://localhost:1313/z-anshun/en/posts/read/">📕阅读</a></div>
    <h1 class="post-title entry-hint-parent">
      多机数据库
    </h1>
    <div class="post-meta"><span title='2022-04-09 01:22:12 +0000 UTC'>2022-04-09</span>&nbsp;·&nbsp;32 min&nbsp;·&nbsp;Noodles2hg

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%a4%8d%e5%88%b6" aria-label="复制">复制</a><ul>
                        
                <li>
                    <a href="#%e6%97%a7%e7%89%88%e5%a4%8d%e5%88%b6%e5%8a%9f%e8%83%bd%e7%9a%84%e5%ae%9e%e7%8e%b0" aria-label="旧版复制功能的实现">旧版复制功能的实现</a></li>
                <li>
                    <a href="#%e6%97%a7%e7%89%88%e5%a4%8d%e5%88%b6%e5%8a%9f%e8%83%bd%e7%9a%84%e7%bc%ba%e9%99%b7" aria-label="旧版复制功能的缺陷">旧版复制功能的缺陷</a></li>
                <li>
                    <a href="#%e6%96%b0%e7%89%88%e5%a4%8d%e5%88%b6%e5%8a%9f%e8%83%bd%e7%9a%84%e5%ae%9e%e7%8e%b0" aria-label="新版复制功能的实现">新版复制功能的实现</a></li>
                <li>
                    <a href="#%e9%83%a8%e5%88%86%e9%87%8d%e5%90%8c%e6%ad%a5%e7%9a%84%e5%ae%9e%e7%8e%b0" aria-label="部分重同步的实现">部分重同步的实现</a></li>
                <li>
                    <a href="#psync-%e5%91%bd%e4%bb%a4%e7%9a%84%e5%ae%9e%e7%8e%b0" aria-label="PSYNC 命令的实现">PSYNC 命令的实现</a></li>
                <li>
                    <a href="#%e5%a4%8d%e5%88%b6%e7%9a%84%e5%ae%9e%e7%8e%b0" aria-label="复制的实现">复制的实现</a></li>
                <li>
                    <a href="#%e5%bf%83%e8%b7%b3%e6%a3%80%e6%b5%8b" aria-label="心跳检测">心跳检测</a></li></ul>
                </li>
                <li>
                    <a href="#sentinel" aria-label="Sentinel">Sentinel</a><ul>
                        
                <li>
                    <a href="#%e5%90%af%e5%8a%a8%e5%b9%b6%e5%88%9d%e5%a7%8b%e5%8c%96sentinel" aria-label="启动并初始化Sentinel">启动并初始化Sentinel</a></li>
                <li>
                    <a href="#%e8%8e%b7%e5%8f%96%e4%b8%bb%e6%9c%8d%e5%8a%a1%e5%99%a8%e4%bf%a1%e6%81%af" aria-label="获取主服务器信息">获取主服务器信息</a></li>
                <li>
                    <a href="#%e8%8e%b7%e5%8f%96%e4%bb%8e%e6%9c%8d%e5%8a%a1%e5%99%a8%e4%bf%a1%e6%81%af" aria-label="获取从服务器信息">获取从服务器信息</a></li>
                <li>
                    <a href="#%e5%90%91%e4%b8%bb%e4%bb%8e%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%8f%91%e9%80%81%e4%bf%a1%e6%81%af" aria-label="向主从服务器发送信息">向主从服务器发送信息</a></li>
                <li>
                    <a href="#%e6%8e%a5%e6%94%b6%e6%9d%a5%e8%87%aa%e4%b8%bb%e4%bb%8e%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84%e9%a2%91%e9%81%93%e4%bf%a1%e6%81%af" aria-label="接收来自主从服务器的频道信息">接收来自主从服务器的频道信息</a></li>
                <li>
                    <a href="#%e6%a3%80%e6%b5%8b%e4%b8%bb%e8%a7%82%e4%b8%8b%e7%ba%bf%e7%8a%b6%e6%80%81" aria-label="检测主观下线状态">检测主观下线状态</a></li>
                <li>
                    <a href="#%e6%a3%80%e6%b5%8b%e5%ae%a2%e8%a7%82%e4%b8%8b%e7%ba%bf%e7%8a%b6%e6%80%81" aria-label="检测客观下线状态">检测客观下线状态</a></li>
                <li>
                    <a href="#%e9%80%89%e4%b8%be%e9%a2%86%e5%a4%b4-sentinel" aria-label="选举领头 Sentinel">选举领头 Sentinel</a></li>
                <li>
                    <a href="#%e6%95%85%e9%9a%9c%e8%bd%ac%e7%a7%bb" aria-label="故障转移">故障转移</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%9b%86%e7%be%a4" aria-label="集群">集群</a><ul>
                        
                <li>
                    <a href="#%e8%8a%82%e7%82%b9" aria-label="节点">节点</a></li>
                <li>
                    <a href="#%e6%a7%bd%e6%8c%87%e6%b4%be" aria-label="槽指派">槽指派</a></li>
                <li>
                    <a href="#%e5%9c%a8%e9%9b%86%e7%be%a4%e4%b8%ad%e6%89%a7%e8%a1%8c%e5%91%bd%e4%bb%a4" aria-label="在集群中执行命令">在集群中执行命令</a></li>
                <li>
                    <a href="#%e9%87%8d%e6%96%b0%e5%88%86%e7%89%87" aria-label="重新分片">重新分片</a></li>
                <li>
                    <a href="#ask-%e9%94%99%e8%af%af" aria-label="ASK 错误">ASK 错误</a></li>
                <li>
                    <a href="#%e5%a4%8d%e5%88%b6%e5%92%8c%e6%95%85%e9%9a%9c%e8%bd%ac%e7%a7%bb" aria-label="复制和故障转移">复制和故障转移</a></li>
                <li>
                    <a href="#%e6%b6%88%e6%81%af" aria-label="消息">消息</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="复制">复制<a hidden class="anchor" aria-hidden="true" href="#复制">#</a></h1>
<p>用户通过执行 SLAVEOF 命令或设置 slaveof 选项，会让一个服务器成为另一个服务器的从服务器</p>
<p>如：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>127.0.0.1:12345&gt; SLAVEOF 127.0.0.1 6379
</span></span></code></pre></td></tr></table>
</div>
</div><p>127.0.0.1:12345 就会成为 127.0.0.1:6379 的从服务器</p>
<h2 id="旧版复制功能的实现">旧版复制功能的实现<a hidden class="anchor" aria-hidden="true" href="#旧版复制功能的实现">#</a></h2>
<p>Redis 的复制分为同步（sync）和命令传播（command propagate）两个操作：</p>
<ul>
<li>同步用于将从更新至主服务得状态</li>
<li>命令传播用于主给从传播命令，达到状态更新</li>
</ul>
<p><strong>同步</strong></p>
<p>当客户端向从服务器发送 SLAVEOF 命令，要求从服务器复制主服务器时，会首先向主服务器进行同步</p>
<p>步骤：</p>
<ol>
<li>从向主发送SYNC命令</li>
<li>主收到SYNC后，执行 BGSAVE 命令，生成RDB文件，并使用一个缓冲区记录从现在开始得写命令</li>
<li>当主执行完BGSAVE命令后，将生成RDB发送给从，然后从载入对应的RDB文件</li>
<li>主将缓冲区的命令发送给从</li>
</ol>
<img src="C:/Users/yan/AppData/Roaming/Typora/typora-user-images/image-20220403234815609.png" alt="image-20220403234815609" style="zoom:50%;" />
<p><strong>命令传播</strong></p>
<p>主从服务器为了保持一致性，主服务器会将写入的新命令发给从服务器</p>
<h2 id="旧版复制功能的缺陷">旧版复制功能的缺陷<a hidden class="anchor" aria-hidden="true" href="#旧版复制功能的缺陷">#</a></h2>
<p>从对主的SYNC只有下面两种情况：</p>
<ul>
<li>初次复制：从以前从未复制过任何主，或者从当前要复制的主和上一次的不同</li>
<li>断线后重复制：从断线后，自动又连上主服务器</li>
</ul>
<p>很明显，初次复制使用SYNC还行，但是断线后重复制来说，效率就显得很低了</p>
<h2 id="新版复制功能的实现">新版复制功能的实现<a hidden class="anchor" aria-hidden="true" href="#新版复制功能的实现">#</a></h2>
<p>为了解决旧版断线后复制的缺陷，后续版本使用 PSYNC 代替 SYNC 命令来执行复制时的同步操作</p>
<p>PSYNC 具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式：</p>
<ul>
<li>完整同步用于处理初次复制的情况，跟SYNC命令的执行步骤基本一样</li>
<li>部分同步用于处理断线后重复制的情况，将断开连接期间执行的写命令发送给从服务器，那么从服务器只用接收并执行这些写命令即可</li>
</ul>
<img src="C:/Users/yan/AppData/Roaming/Typora/typora-user-images/image-20220404122925807.png" alt="image-20220404122925807" style="zoom:33%;" />
<h2 id="部分重同步的实现">部分重同步的实现<a hidden class="anchor" aria-hidden="true" href="#部分重同步的实现">#</a></h2>
<p>部分重同步功能主要由下面三个部分组成：</p>
<ul>
<li>主的复制偏移量（replication offset）和从的复制偏移量</li>
<li>主的复制积压缓冲区（replication backlog）</li>
<li>服务器的运行ID（run ID）</li>
</ul>
<p><strong>复制偏移量</strong></p>
<p>执行复制的双方，即主从都会维护一个偏移量：</p>
<ul>
<li>主每次向从传播N个字节的数据时，就会将自己的偏移量的值加上N</li>
<li>从收到主传播来的N个字节的数据时，也会将自己的复制偏移量加上N</li>
</ul>
<p>那么，通过对比主从的偏移量，就能知道当前两个服务器的状态是否处于一致了</p>
<p><strong>复制积压缓冲区</strong></p>
<p>由主服务器维护的一个固定长度（fixed-size）先进先出（FIFO）队列，默认大小为1MB</p>
<p>当服务器进行命令传播时，不仅会将写命令发送给所有从服务器，还会将其入队到复制积压缓冲区里</p>
<img src="C:/Users/yan/AppData/Roaming/Typora/typora-user-images/image-20220404152104505.png" alt="image-20220404152104505" style="zoom:50%;" />
<p>因此，主服务器就会保存着一部分最近传播的写命令，并且复制积压缓冲区还会为队列中的每个字节记录相应的复制偏移量</p>
<p>因此，当从重新连接上主时，从会通过 PSYNC 命令将自己的offset发送给主，主服务器会根据这个offset来判断执行何种操作：</p>
<ul>
<li>如果offset之后的数据在复制积压缓冲区里，那么就执行部分同步操作</li>
<li>如果不在，就全同步</li>
</ul>
<p>注意：复制积压缓冲区的默认为1MB，但如果主服务器执行的写操作过多，而且从断开的时间过长，那么这个显然时不恰当的，需要进行调整，一般设置为 <code>2*second*write_size_per_second</code>，这里的second为重连的平均时间，write_size_per_second为主服务器平均每秒产生写命令的数据量（协议格式的些命令的长度）,这样绝大多数都能实现部分同步</p>
<p><strong>服务器运行ID</strong></p>
<p>除了复制偏移量和复制积压缓冲区之外，实现部分重同步还需要用到服务器运行ID（run ID）:</p>
<ul>
<li>每个服务器，无论主从，都会有自己运行的ID</li>
<li>运行的ID会在运行时自动生成，由40个随机的16进制字符组成</li>
</ul>
<p>当从对主进行初次复制时，主服务器会将自己运行ID传送给从服务器，而从则会将这个运行ID保存起来</p>
<p>那么在重连时，从服务器则会将这个ID发送给主，如果当前主的ID与从发送过来的一样，则尝试部分复制，反之就是SYNC</p>
<h2 id="psync-命令的实现">PSYNC 命令的实现<a hidden class="anchor" aria-hidden="true" href="#psync-命令的实现">#</a></h2>
<p>在了解了服务器运行ID、复制偏移量和复制积压缓冲区后，就能理解 PSYNC 命令的完整细节了</p>
<p>PSYNC 命令的调用方法有两种：</p>
<ul>
<li>如果从没有复制过主，或者之前执行过 SLAVEOF no one命令，那么从会开始一次新的复制时将向主发送<code>PSYNC ? -1</code>命令，请求完整同步</li>
<li>如果从已经复制过某个主机，那么在开启一次新的复制时，将向主发送<code>PSYNC &lt;runid&gt; &lt;offset&gt;</code></li>
</ul>
<p>根据收到的 PSYNC ，主服务器会回复下面三种的某一种：</p>
<ul>
<li><code>+FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code>：执行完整同步操作，offset为主服务器当前的复制偏移量</li>
<li><code>+CONTINUE ?</code>：执行部分同步操作</li>
<li><code>-ERR</code>：主服务器版本过低，无法识别PSYNC命令，进而从会再向主发送SYNC命令</li>
</ul>
<h2 id="复制的实现">复制的实现<a hidden class="anchor" aria-hidden="true" href="#复制的实现">#</a></h2>
<p><code>SLAVEOF &lt;master_ip&gt; &lt;master_port&gt;</code></p>
<p>让从复制一个主服务器</p>
<p><strong>1. 设置主服务器的地址和端口</strong></p>
<p>执行<code>SLAVEOF &lt;master_ip&gt; &lt;master_port&gt;</code> 命令后，从服务器会保证设置的 ip和端口</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> redisServer{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">char</span> *masterhost;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> masterport;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>SLAVEOF 命令为一个异步命令，在完成对应的属性设置后，服务器会向客户端返回一个OK，而真正的复制工作会在OK返回之后真正执行</p>
<p><strong>2. 建立套接字连接</strong></p>
<p>SLAVEOF 命令执行之后，从会根据ip和端口，创建与主服务器的套接字连接</p>
<p><strong>3. 发送PING命令</strong></p>
<p>从服务器成为主的客户端后，做的第一件事就是向主发送一个PING命令</p>
<p>PING有两个作用：</p>
<ul>
<li>检查套接字的读写是否正常</li>
<li>检查主服务器是否正常处理命令请求</li>
</ul>
<p>从服务器PING后会遇到下面三种情况之一：</p>
<ul>
<li>如果主向从返回了一个命令回复，而从不能却不能在规定时间内读出内容（即超时），那么表示当前网络状况不佳，不能继续后续工作。每当出现这种情况，从会断开连接并重新连接主的套接字</li>
<li>如果主返回一个错误，那么表示主服务器暂时没法处理从服务器的命令请求，不能继续执行后续步骤。这是从会断开连接，并重新创建连向主的套接字</li>
<li>如果从读取到了&quot;PONG&quot;回复，那么表示当前状态正常</li>
</ul>
<p><strong>4. 身份验证</strong></p>
<p>从收到&quot;PONG&quot; 后，就需要进行下一步，即身份验证</p>
<p>如果从服务器设置了 masterauth选项，就需要进行身份验证，反之，就不需要</p>
<p>那么在需要进行身份验证的情况下，从服务器会向主发送一条AUTH命令，其参数为 masterauth 选项的值</p>
<p>在进行身份验证时，可能遇到下面几个情况：</p>
<ul>
<li>如果主没有设置 requirepass 选项，并且从也没有设置 masterauth，那么主将继续执行从服务器发送的命令，即复制工作继续执行</li>
<li>如果从通过AUTH命令发送的密码和主 requirepass 选项所设置的密码相同，那么主将继续执行从发送的命令；反之就返回一个 invalid password 错误</li>
<li>如果主设置了 requirepass 选项，但从没有设置 masterauth。那么主服务器会返回一个 NOAUTH 错误。</li>
<li>如果主没设置requirepass选项，而从设置了 AUTH，那么主服务器就会返回一个 no password is set错误</li>
</ul>
<p>所有错误情况都会让从服务器中止目前的复制工作，并创立套接字，重新执行，直到验证通过</p>
<p><strong>5. 发送端口信息</strong></p>
<p>在身份验证之后，从会执行 <code>REPLCONF listening-port &lt;port-number&gt;</code>，向主服务器发送从监听的端口</p>
<p>主服务器接收到之后，就将其记录在对应客户端状态中：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">struct</span> redisClient{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 从服务器监听的端口号
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> slave_listening_port;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}redisClient;
</span></span></code></pre></td></tr></table>
</div>
</div><p>slave_listening_port 唯一的作用，是主服务器在执行 INFO replication 命令时，打印出从服务器监听的端口</p>
<p><strong>6. 同步</strong></p>
<p>上面的都执行完后，从服务器将发送 PSYNC 命令，这是主为从的客户端</p>
<p><strong>7. 命令传播</strong></p>
<h2 id="心跳检测">心跳检测<a hidden class="anchor" aria-hidden="true" href="#心跳检测">#</a></h2>
<p>在命令传播的阶段，从默认会以每秒一次的频率，向主发送命令：</p>
<p><code>REPLCONF ACK &lt;replication_offset&gt;</code></p>
<p>其中的replication_offset 就是从服务器当前的偏移量</p>
<p>发送这个命令，主要是检测主从服务器的网络连接状态、辅助实现 min-slaves选项和检测命令丢失</p>
<p><strong>检测主从服务器的网络连接状态</strong></p>
<p>主从服务器通过发送和接收 REPLCONF ACK 命令来检查两者之间的网络连接是否正常</p>
<p>如果超过1s没收到了从服务器发来的 REPLCONF ACK 命令，那么主服务器就认为主从之间的连接失效</p>
<p>通过向主服务器发送<code>INFO replication</code> 命令，在列出的从服务器列表的lag一栏中，我们能看到距离上一次发送过了多少秒，因此值一般为0或者1</p>
<p><strong>辅助实现 min-slaves 配置选项</strong></p>
<p>Redis 的 min-slaves-to-write 和 min-slaves-max-lag 两个选项可以防止主服务器在不安全的情况下执行写命令</p>
<p>如：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>min-slaves-to-write 3
</span></span><span style="display:flex;"><span>min-slaves-max-lag 10
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么在从服务器少于三个，或者三个从服务器的延迟（lag）的值都大于或等于10s时，主服务器就会拒绝执行写命令</p>
<p><strong>检测命令丢失</strong></p>
<p>因为 REPLCONF ACK 命令会传递偏移值，所有命令丢失就会很快发现，进而主服务器在重新进行命令传递即可</p>
<h1 id="sentinel">Sentinel<a hidden class="anchor" aria-hidden="true" href="#sentinel">#</a></h1>
<p>Sentinel（哨岗、哨兵）是Redis高可用性（high availability）解决方案：</p>
<p>由一个或多个 Sentinel 实例（instance）组成的 Sentinel系统（system），可以监视多个主服务器，和它们属下的所有从服务器，并在主下线时，然后将一个从配置为主。</p>
<p>具体步骤：假设当前server1为主服务器，并且下线时长超过了限制</p>
<ol>
<li>首先，Sentinel系统会挑选server1属下的其中一个从服务器，将其升级为主服务器</li>
<li>然后，Sentinel 系统会向server1属下的所有从服务器发送新的复制命令，让它们成为新的主服务器的从，当所有从都完成了复制时，故障转移操作即执行完毕</li>
<li>另外，当server1重新上线时，它将会被设置为新当选的从服务器</li>
</ol>
<h2 id="启动并初始化sentinel">启动并初始化Sentinel<a hidden class="anchor" aria-hidden="true" href="#启动并初始化sentinel">#</a></h2>
<blockquote>
<p>如何启动一个Sentinel？</p>
</blockquote>
<p><code>redis-sentinel sentinel.conf</code> 或者 <code>redis-server sentinel.conf --sentinel</code></p>
<blockquote>
<p>一个Sentinel启动时，大致需要执行哪些步骤？</p>
</blockquote>
<ol>
<li>初始化服务器</li>
<li>将Redis服务器使用的代码替换为 Sentinel 专用的代码</li>
<li>初始化 Sentinel 状态</li>
<li>根据给定的配置文件，初始化Sentinel 监视的主服务器列表</li>
<li>创建与主之间的网络连接</li>
</ol>
<p><strong>初始化服务器</strong></p>
<p>Sentinel本质上也是一个特殊的Redis服务器，所有很多部分都跟Redis服务器初始化相同。</p>
<p>比如：Sentinel不需要数据库，因此就不需要加载RDB或者AOF，也不需要 BGSAVE或SAVE等命令；或者都需要时间事件处理器，只是sentinel的serverCron会执行 sentinel.c/sentinelTimer 函数</p>
<p><strong>使用Sentinel专用代码</strong></p>
<p>将一部份普通Redis服务器使用的代码替换为 Sentinel 专用代码</p>
<p>如：将redis.h/REDIS_SERVERPORT 常量替换为 sentinel.c/REDIS_SENTINEL_PORT</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#define REDIS_SERVERPORT 6379
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#define REDIS_SENTINEL_PORT 26379
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>并且，在加载命令方面，Sentinel模式下使用 sentinel.c/sentinelInfoCommand函数，因此根本没载入SET、DEL等命令，只有 PING、SENTINEL、INFO、SUBSCRIBE、UNSUBSCRIBE、PSUBSCRIBE、PUNSUBSCRIBE七个命令</p>
<p><strong>初始化 Sentinel 状态</strong></p>
<p>应用专用代码后，跟 redisServer结构体一样，sentinel也有一个结构体用来保存状态</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> sentinelState{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 当前纪元，用于故障转移
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">uint64_t</span> current_epoch;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 保存所有被监视的服务器
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 字典键为主服务器的名
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 值为指向 sentinelRedisInstance 结构的指针
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    dict *master;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 是否进入 TILT 模式
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> tilt;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 当前正在执行的脚本数
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> running_scripts;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 进入 TILT 模式的时间
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">mstime_t</span> tilt_start_time;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 最后一次执行时间处理器的时间
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">mstime_t</span> previous_time;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 一个FIFO队列，包含所有需要执行的脚本
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    list *scripts_queuq;
</span></span><span style="display:flex;"><span>}sentinel;
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>初始化 Sentinel 状态的 masters 属性</strong></p>
<p>Sentinel状态的 master 字典记录了所有被 Sentinel 监视的主服务器的相关属性</p>
<p>其字典保存的值就为实例结构，即 sentinelRedisInstance</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">36
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">struct</span> sentinelRedisInstance{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 记录实例的类型，以及当前实例的状态
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> flags;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 实例名字
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 主服务器的名字由用户在配置文件进行配置
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 从以及Sentinel的名字由Sentinel自动配置
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 格式为 ip:port, 如&#34;127.0.0.1:12345&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">char</span> *name;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 实例的运行ID
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">char</span> *runid;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 配置纪元，用于实现故障转移
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">uint64_t</span> config_epoch;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 实例的地址
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    sentinelAddr *addr;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// SENTINEL down-after-milliseconds 选择设置的值
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 实例无响应多少ms后被判断为主观下线（subjectively down）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">mstime_t</span> down_after_period;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// SENTINEL monitor &lt;master-name&gt; &lt;IP&gt; &lt;port&gt; &lt;quorum&gt; 选项中的 quorum 参数
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 判断这个实例为客户下线（objectively down）所需要支持的投票数
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> quorum;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// SENTINEL parallel-syncs &lt;master-name&gt; &lt;number&gt; 选项的值
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 在执行故障操作时，可以同时对新的主服务器进行同步的从服务器数量
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> parallel_syncs;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// SENTINEL failover-timeout &lt;master-name&gt; &lt;ms&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 刷新故障转移状态的最大时间
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">mstime_t</span> failover_timeout;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}sentinelRedisInstance;
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">struct</span> sentinelAddr{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">char</span> *ip;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> port;
</span></span><span style="display:flex;"><span>}sentinelAddr;
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>初始连接向主服务器的网络连接</strong></p>
<p>最后一步就是创建连向被监视的主机服务器的网络连接，Sentinel 在此时做客户端的职责，可以向主服务器发送命令</p>
<p>对于被监视的主服务器，Sentinel 会创建两个连向主服务器的异步网络：</p>
<ul>
<li>命令连接：专门用于向主服务器发送命令，并接收命令回复</li>
<li>订阅连接：专门用于订阅主服务器的 <code>__sentinel__:hello</code>频道</li>
</ul>
<blockquote>
<p>为什么是两个连接？</p>
</blockquote>
<ol>
<li>因为Redis的发布和订阅中，被发送的消息都不会存在Redis服务器中。如果在信息发送时因为接收端断线，导致信息丢失，因此为了不丢失信息，所以需要一个专门的连接，来接收<code>__sentinel__:hello</code>频道的信息</li>
<li>处理订阅频道之外，还有命令的传递，所以还必须向主服务器创建命令连接</li>
<li>因为Sentinel会与多个实例相连，所以这里使用异步连接</li>
</ol>
<img src="C:/Users/yan/AppData/Roaming/Typora/typora-user-images/image-20220405164927173.png" alt="image-20220405164927173" style="zoom:50%;" />
<h2 id="获取主服务器信息">获取主服务器信息<a hidden class="anchor" aria-hidden="true" href="#获取主服务器信息">#</a></h2>
<p>Sentinel 会默认每10s一次，通过命令连接向被监视的主服务器发送INFO命令，并通过分析回复来获取但主服务器当前的信息</p>
<img src="C:/Users/yan/AppData/Roaming/Typora/typora-user-images/image-20220405165151705.png" alt="image-20220405165151705" style="zoom:50%;" />
<p>通过分析INFO命令的回复，Sentinel 可以获取下面两个方面的信息：</p>
<ul>
<li>关于主服务器本身的信息：包括run_id 域记录的服务器运行ID，role域记录的服务器角色</li>
<li>关于主服务器下所有从服务器的信息：每个从都由一个&quot;salve&quot;字符串开头的行记录，包括ip、port等。因此根据这些IP和端口号，Sentinel 就无须用户提供从服务器的地址信息</li>
</ul>
<p>又因为得到了主服务器的run_id 和 role等信息，Sentinel 将对主服务器的实例结构进行更新。如主服务器重重启之后，它的ID会与之间的保存不同，这时候就需要进行更新</p>
<p>对于返回的从服务器状态，则会用于更新主服务器实例结构的 slaves 字典，这个字典记录了主服务器属下的从服务器名单：</p>
<ul>
<li>键：Sentinel 自动设置的名字，格式为IP:port</li>
<li>值：从服务器对对应的实例结构，即 <code>sentinelRedisInstance</code></li>
</ul>
<h2 id="获取从服务器信息">获取从服务器信息<a hidden class="anchor" aria-hidden="true" href="#获取从服务器信息">#</a></h2>
<p>当 Sentinel 发现主有新的从服务器时，Sentinel 除了会为它创建新的实例之外，还会创建连接到从服务器的命令连接和订阅连接</p>
<p>Sentinel 默认情况下，向从发送 INFO 命令，获得以下内容的回复：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#007f7f"># Server</span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>run_id: ...
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># Replication</span>
</span></span><span style="display:flex;"><span>role:slave
</span></span><span style="display:flex;"><span>master_host:127.0.0.1
</span></span><span style="display:flex;"><span>master_port:6379
</span></span><span style="display:flex;"><span>master_link_status:up
</span></span><span style="display:flex;"><span>slave_repl_offset:11887
</span></span><span style="display:flex;"><span>slave_priority:100
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># Other sections</span>
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></td></tr></table>
</div>
</div><p>根据INFO，Sentinel 会提取出下面信息：</p>
<ul>
<li>从服务器的运行ID： run_id</li>
<li>从服务器的角色：role</li>
<li>主服务器的IP地址 master_host，主服务器的端口号 master_port</li>
<li>主从服务器的连接状态 master_link_status</li>
<li>从服务器的优先级 slave_priority</li>
<li>从服务器的复制偏移量 slave_repl_offset</li>
</ul>
<h2 id="向主从服务器发送信息">向主从服务器发送信息<a hidden class="anchor" aria-hidden="true" href="#向主从服务器发送信息">#</a></h2>
<p>默认情况下，Sentinel 会以2s一次的频率，通过命令连接向所有被监视的主服务器和从发送下面格式的命令：</p>
<p><code>PUBLISH __sentinel__:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</code></p>
<p>其中,<code>s_</code>开头的为 Sentinel的信息，而<code>m_</code>开头的参数记录的为主机服务器的信息，如果监视的为主，那就是主的信息，如果是从，那就是从所属主的信息</p>
<h2 id="接收来自主从服务器的频道信息">接收来自主从服务器的频道信息<a hidden class="anchor" aria-hidden="true" href="#接收来自主从服务器的频道信息">#</a></h2>
<p>当Sentinel与一个主或从连接起连接订阅连接后，Sentinel 就会通过订阅连接，也订阅频道 <code>SUBSCRIBE __sentinel__:hello</code></p>
<p>这个订阅会一直持续到Sentinel与服务器的连接断开为止</p>
<p>也就是说，Sentinel 既通过这个频道发布信息，也接受信息。</p>
<p>那么，对于监视同一个服务器的多个Sentinel而言，一个Sentinel 发送的信息也就会被其他 Sentinel 接收到，这些信息会被用于更新其它Sentinel 的认知</p>
<img src="C:/Users/yan/AppData/Roaming/Typora/typora-user-images/image-20220405180448945.png" alt="image-20220405180448945" style="zoom:50%;" />
<p>当 Sentinel 从 <code>__sentinel__:hello</code>频道收到一条信息时，会对这条信息进行分析，提取出其 Sentinel 的IP、端口号、运行ID等八个参数</p>
<ul>
<li>如果信息中的运行ID和本机的一样，那么就是自己发送的，直接丢弃</li>
<li>如果不同，就证明是其它其它Sentinel发送来的，更新对应主服务器的实例结构</li>
</ul>
<p><strong>更新 sentinels 字典</strong></p>
<p>Sentinel 为<strong>主服务器</strong>创建的实例结构中的 sentinels 字典保存了除了 Sentinel 本身之外，还有监视这个服务器的其它 Sentinel 的资料：</p>
<ul>
<li>键：Sentinel的名字，格式为 ip:port</li>
<li>值：对应的 Sentinel 实例结构</li>
</ul>
<p>Sentinel会从其它Sentinel收到的信息分析并提取出下面两方面的参数：</p>
<ul>
<li>与Sentinel 有关的参数：源 Sentinel 的ip、端口、运行ID和配置纪元</li>
<li>与主服务有关的参数：源 Sentinel 正在监视的主服务器的名字、Ip、端口号和配置纪元</li>
</ul>
<p>根据提取到的参数，Sentinel 就会再自己的 masters字典中查询相应的实例结构，然后再根据查询到的主服务器实例查询相应的 sentinels 字典，判断源 Sentinel 实例是否存在。</p>
<p>如果没存在，就创建，再更新字典，如果存在就更新</p>
<blockquote>
<p>为什么对应的主机实例，还需要创建 sentinels 字段？</p>
</blockquote>
<p>用于让一个 Sentinel 知道其它 Sentinel的存在，而且不需要用户提供其它 Sentinel 的地址信息，可以自动发现</p>
<p><strong>创建连向其它 Sentinel 的命令连接</strong></p>
<p>当一个 Sentinel 发现其它新的 Sentinel 时，不止会在相应的主机实例中更新字典，还会创建一个连向新 Sentinel 的命令连接</p>
<img src="C:/Users/yan/AppData/Roaming/Typora/typora-user-images/image-20220405185530535.png" alt="image-20220405185530535" style="zoom: 50%;" />
<p>注意：这里只用与其它 Sentinel 创建命令连接就行了，不需要订阅连接，因为之前的订阅是接收主从发来的频道信息发现未知的新 Sentinel，而这里就不需要了</p>
<h2 id="检测主观下线状态">检测主观下线状态<a hidden class="anchor" aria-hidden="true" href="#检测主观下线状态">#</a></h2>
<p>默认情况下，Sentinel 会以1s一次的频率向所有与它创建了命令连接的实例（包括主从、其它 Sentinel）发送PING，并通过返回的命令，判断是否在线</p>
<img src="C:/Users/yan/AppData/Roaming/Typora/typora-user-images/image-20220405192113719.png" alt="image-20220405192113719" style="zoom:50%;" />
<p>对应PING命令的回复可以分为下面两种情况：</p>
<ul>
<li>有效回复：实例返回 +PONG、-LOADING、-MASTERDOWN 三种中的某一个</li>
<li>无效回复：返回有效回复之外的回复，或者超时</li>
</ul>
<p>Sentinel 配置文件中的 down-after-milliseconds 选项指定了判断主观下线的时间，也就是如果一个实例如果返回了无效返回，那么 Sentinel 会修改其对应的实例结构，即在其 flags 属性中打开 SRI_S_DOWN 标识，表示其已经主观下线</p>
<p>注意：多个 Sentinel 设置的主观下线时长可能不同</p>
<h2 id="检测客观下线状态">检测客观下线状态<a hidden class="anchor" aria-hidden="true" href="#检测客观下线状态">#</a></h2>
<p>当一个主服务器判断为主观下线后，为了确认这个主服务器是否是真的下线，它会对同样监视它的其它 Sentinel 进行询问，看它们是否为下线状态（即客观下线或主观下线），收到足够数量的已下线判断后，就将其认为客观下线状态，并进行故障转移</p>
<p><strong>发送 SENTINEL is-master-down-by-addr 命令</strong></p>
<p>Sentinel 使用 <code>SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt;</code>命令询问其它 Sentinel 是否同意主服务器已下线。</p>
<p>ip、port、current 都为主服务器的属性；runid可以为 * 或者 Sentinel 的运行id（*代表检查客观下线，Sentinel的运行id用来选举头领 Sentinel）</p>
<p><strong>接收 SENTINEL is-master-down-by-addr 命令</strong></p>
<p>当一个Sentinel 收到 SENTINEL 命令时，会分析其中包含的各个参数，根据其中的IP和端口，检查主是否已经下线，然后返回一条包含三个参数的 Multi Bulk 回复：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>1) &lt;down_state&gt;
</span></span><span style="display:flex;"><span>2) &lt;leader_runid&gt;
</span></span><span style="display:flex;"><span>3) &lt;leader_epoch&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>down_state：返回主服务器的检查结果，1为已下线，0为未下线</li>
<li>leader_runid：可以是*符号或者为 Sentinel 的局部领头的runid</li>
<li>leader_epoch：Sentinel 的局部领头 Sentinel 的配置纪元，用于选举领头，只有在 leader_runid 不为*是有用，否则就为0</li>
</ul>
<p>如：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>1) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>2) *
</span></span><span style="display:flex;"><span>3) <span style="color:#ff0;font-weight:bold">0</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>则表明同意下线</p>
<p><strong>接收 SENTINEL is-master-down-by-addr 命令的回复</strong></p>
<p>当同一下线的 Sentinel 超过配置的 quorum 参数的值后，就会被认定为客观下线，将主服务器的 flags 属性的 SRI_O_DOWN 标识打开。</p>
<p>注意：不同Sentinel 判断某个 主服务器为客观下线的条件是不同</p>
<h2 id="选举领头-sentinel">选举领头 Sentinel<a hidden class="anchor" aria-hidden="true" href="#选举领头-sentinel">#</a></h2>
<p>当主服务器被判断为客观下线时，监视这个下线主服务器的各个 Sentinel会进行协商，选举一个头领，并由领头的进行故障转移</p>
<blockquote>
<p>如何选举？</p>
</blockquote>
<ul>
<li>所有 Sentinel 都有被选举为临头的资格</li>
<li>每次临头选举之后，不论选举成功与否，所有 Sentinel 的配置纪元（configuration epoch）的值都会自增一次（配置纪元就是一个计数器）</li>
<li>一个配置纪元里面，所有 Sentinel 都有将某个 Sentinel 设置为局部领头的机会，而且一旦设置，在这个配置纪元里面就无法进行更改</li>
<li>每个发现主服务器进入客观下线的 Sentinel 都会请求其它的 Sentinel 将自己设置为局部领头 Sentinel</li>
<li>当Sentinel 发送的为 <code>SENTINEL is-master-down-by-addr</code>命令时，并且runid不为*,为自己的runid，就表明要求自己成为局部的领头 Sentinel</li>
<li>目标Sentinel回复收到的 <code>SENTINEL</code>命令，回复中leader_runid和leader_epoch 参数分别记录了目标 Sentinel 的局部领头的运行ID和配置纪元（如果当前还未配置局部领头，那么先来就会成为）</li>
<li>源 Sentinel 收到目标 Sentinel 对于 <code>SENTINEL</code> 的回复后，首先判断回复的 leader_epoch 参数是否跟自己的配置纪元，如果相同，就会进行判断 leader_runid 参数是否跟自己的运行id，如果相同，则表示目标已经认位源为局部领头</li>
<li>如果超过半数的 Sentinel 认为这个为局部领头，那么这个Sentinel就成为领头</li>
<li>如果该配置纪元在给定时间内未选出领头，那么各个 Sentinel 将在隔一段时间后，再次进行选举，直到选出 Sentinel 为止</li>
</ul>
<h2 id="故障转移">故障转移<a hidden class="anchor" aria-hidden="true" href="#故障转移">#</a></h2>
<p>在选举出领头 Sentinel 后，其领头将会对已下线的主服务器执行故障转移操作</p>
<ol>
<li>在已下线的主服务器中选择一个从服务器，并将其转化为主服务器</li>
<li>让已下线主服务器属下的所有从服务器都改为复制新的主服务器</li>
<li>将已下线的主服务器设置为新的主的从，即，当以前的主服务器重连后，它会成为新的从服务器</li>
</ol>
<p><strong>选出新的主服务器</strong></p>
<p>选择一个状态良好、数据完整的从服务器，然后向这个从服务器发送 SLAVEOF no one 命令，将其转化为主服务</p>
<blockquote>
<p>这个新的主服务器是怎么选出来的？</p>
</blockquote>
<ol>
<li>将已下线的主服务器的所有从服务器保存到一个列表中</li>
<li>删除已下线或者断线状态的从服务器，保证列表中剩余的从服务器都是正常在线的</li>
<li>删除列表中所有最近5s内没有回复过领头 Sentinel 的INFO命令的从服务器，保证剩余的都是最近成功进行通信过的</li>
<li>删除所有与已下线主服务器连接断开超过 down-after-milliseconds*10 ms的，保证数据较新</li>
<li>根据优先级、偏移量排序，选择最大的，如果都一样，则根据ID排序，选择最小的ID</li>
</ol>
<p>然后，Sentinel 会向被选中的从服务器发送 SLAVEOF no one 命令，并且每1s都会向被升级的从服务器发送 INFO 命令（平时为每10s一次），当被升级的 role 从原来的 slave 变成 master 时，领头的就知道已经完成了升级</p>
<p><strong>修改从服务器的复制目标</strong></p>
<p>下一步就是剩下的从服务器去复制新的主服务器，即<code>SLAVEOF</code>命令</p>
<p><strong>将旧的主服务器变为从服务器</strong></p>
<p>因为旧的主已经下线，所以设置保存在了 server1 对应的实例结构里，当server1重新上线时，Sentinel 就会通过命令连接向它发送<code>SLAVEOF</code>命令</p>
<h1 id="集群">集群<a hidden class="anchor" aria-hidden="true" href="#集群">#</a></h1>
<p>redis集群是redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供故障转移功能</p>
<h2 id="节点">节点<a hidden class="anchor" aria-hidden="true" href="#节点">#</a></h2>
<p><code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code> 命令用来连接各个节点，该node节点会与IP:port所指定的节点进行握手（handshake），当握手成功时，node节点就会将ip和port指定的节点加入当前node所在的集群中</p>
<p>另外，<code>CLUSTER NODES</code>能查看当前集群里的所有节点</p>
<p><strong>启动节点</strong></p>
<p>Redis 服务器在启动时会根据 cluster-enabled 配置选项是否为yes来决定是否开启服务器的集群模式，反之就为单机（stand alone）模式</p>
<p>节点也会继续使用所有在单机模式中的服务器组件，如：</p>
<ul>
<li>文件时间来处理命令请求和回复</li>
<li>时间事件处理器来执行 serverCron 函数，而serverCron函数也会调用集群特有的 clusterCron函数</li>
<li>数据库来保存键值对</li>
<li>RBD和AOF</li>
</ul>
<p>另外，也会使用redisServer和redisClient。对于只有集群模式下才会用到的数据，节点将其保存到了 cluster.h/clusterNode 、clusterLink、clusterState结构里面</p>
<p><strong>集群的数据结构</strong></p>
<p>每个节点都会使用一个 clusterNode 来保存自己的状态，为集群中的其它节点（包括主从节点）都创建一个 clusterNode 结构，以此来记录其它节点的状态：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> clusterNode{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 创建时间
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">mstime_t</span> ctime;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 节点的名字，由40个十六进制字符组成
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">char</span> name[REDIS_CLUSTER_NAMELEN];
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 节点标识
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 记录当前节点的角色（主从）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 以及当前所处的状态（是否下线）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> flags;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 节点当前的配置纪元，用于实现故障转移
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">uint64_t</span> configEpoch;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 节点的IP
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">char</span> ip[REDIS_IP_STR_LEN];
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 节点的端口号
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> port;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 保存连接节点所需的有关信息
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    clusterLink *link;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>};
</span></span></code></pre></td></tr></table>
</div>
</div><p>link属性为一个 clusterLink 结构，该结构保存了连接节点的有关信息：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">struct</span> clusterLink{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 连接创建的时间
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">mstime_t</span> ctime;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// TCP 套接字描述符
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> fd;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 输出缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    sds sndbuf;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 输入缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    sds rcvbuf;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 与这个连接相关联的节点，如果没有就为NULL
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">struct</span> clusterNode *node;
</span></span><span style="display:flex;"><span>}clusterLink;
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>redisClient 和 clusterLink 的异同？</p>
</blockquote>
<p>同：都有自己的输入输出缓冲区和套接字描述符</p>
<p>异：redisClient 中的缓冲区和套接字是用于与客户端之间的连接，而clusterLink为用于节点之间的连接</p>
<p>最后，每个节点都保存着一个 clusterState结构，这个结构记录了在当前节点的视角下，集群目前所处的状态</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">struct</span> clusterState{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 指向当前节点的指针
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    clusterNode *myself;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 集群当前的配置纪元
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">uint64_t</span> currentEpoch;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 集群当前的状态
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> state;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 集群中至少处理着一个槽的节点的数量
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> size;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 集群节点的名单（包括myself）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 键位节点名字，值位 clusterNode 结构
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    dict *node;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}clusterState;
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>CLUSTER MEET 命令的实现</strong></p>
<p>假设节点A像B发送CLUSTER MEET 命令，那么节点之间会进行握手（handshake），来确认彼此的存在，并为后续的通信打好基础：</p>
<ol>
<li>节点A会为B创建一个 clusterNode 结构，并将该结构添加到自己的 clusterState.nodes 字典里</li>
<li>节点A根据 CLUSTER MEET 给定的IP和端口号，向B发送一条MEET消息（message）</li>
<li>节点B收到A发送的MEET消息，节点B会为A创建一个 clusterNode 结构，然后将其加入到自己的 clusterState.nodes 字典里</li>
<li>节点B向A返回一条PONG消息</li>
<li>A节点通过这条PONG信息，确认B已经收到A的发送的MEET信息</li>
<li>然后，A又会向B发送一条PING消息</li>
<li>B收到A发送的PING，确认A已经收到自己的PONG，握手完成</li>
</ol>
<img src="C:/Users/yan/AppData/Roaming/Typora/typora-user-images/image-20220406134810293.png" alt="image-20220406134810293" style="zoom:50%;" />
<p>最后，A会将B的信息通过 Gossip 协议传播给集群中的其它节点，让其它节点与B握手，最终，一段时候后，节点B就会被集群中的所有节点认识</p>
<h2 id="槽指派">槽指派<a hidden class="anchor" aria-hidden="true" href="#槽指派">#</a></h2>
<p>Redis 集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽（slot），而数据库的每个键都属于这 16384 槽中的一个，集群中的每个节点可以处理0个或最多16384个槽</p>
<p>只有当数据库中的16384个槽都有节点在处理时，集群才处于上线状态（ok），反之，则为下线状态（fail）</p>
<p>通过向节点发送<code>CLUSTER ADDSLOTS</code>命令，可以将一个或多个槽指派（assign）给节点负责，如：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#007f7f"># CLUSTER ADDSLOTS &lt;slot&gt; [slot ...]</span>
</span></span><span style="display:flex;"><span>redis&gt; CLUSTER ADDSLOTS <span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">1</span> <span style="color:#ff0;font-weight:bold">2</span> <span style="color:#ff0;font-weight:bold">3</span> <span style="color:#ff0;font-weight:bold">4</span> ... <span style="color:#ff0;font-weight:bold">5000</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>记录节点的槽指派信息</strong></p>
<p>clusterNode 结构的 slots 属性和 numslot 属性记录了节点负责处理哪些槽：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> clusterNode{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> slots[<span style="color:#ff0;font-weight:bold">16384</span>/<span style="color:#ff0;font-weight:bold">8</span>];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> numslots;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>};
</span></span></code></pre></td></tr></table>
</div>
</div><p>slots 属性为一个二进制数组（bit array），这个数组的长度为 2048 个字节，共 16384 个二进制位</p>
<p>如果对应的 slots 位上的值为1，那边就代表负责处理槽i；反之为0，就不处理。</p>
<p>那么，对于一个给定节点的 slots数组来说，检查是否负责处理某个槽或者指派某个槽给节点的时间复杂度为O(1)</p>
<p><strong>传播节点的槽指派信息</strong></p>
<p>一个节点不仅会记录自己的槽信息，还会将自己的slots数组通过消息发送给集群中的其它节点，以此来告知其它节点自己负责了哪些槽</p>
<p>并且每个节点收到之后，还会在自己的 clusterState.nodes 找到相应的 clusterNode结构，并对结构中的 slots 数组进行保存或更新，这样每个节点都会知道整个集群分配的槽了</p>
<p><strong>记录集群所有槽的指派信息</strong></p>
<p>clusterState 结构中的 slots 数组记录了集群中所有 16384 个槽的指派信息：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">struct</span> clusterState{
</span></span><span style="display:flex;"><span>  	<span style="color:#007f7f">// ..
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    clusterNode *slots[<span style="color:#ff0;font-weight:bold">16384</span>];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>};
</span></span></code></pre></td></tr></table>
</div>
</div><p>slots 数组包含 16384 个项，每项都指向一个 clusterNode 结构的指针：</p>
<ul>
<li>如果 slots[i] 指针指向 NULL，那么就表示槽 i 尚未指派给任何节点</li>
<li>反之就指向对应的节点</li>
</ul>
<blockquote>
<p>为什么需要 clusterNode.slots 数组 和 clusterState.slots 数组？</p>
</blockquote>
<ul>
<li>如果节点只使用 clusterNode.slots 数组来记录槽的指派信息，那么当需要知道i是否被指派，或者i被谁指派时，就需要遍历 clusterState.nodes字典中的所有 clusterNode结构，并检查这些结构的 slots数组，时间复杂度为 O(n)；而对于 clusterState.slots 数组，只需要 O(1)的时间复杂度即可</li>
<li>当程序需要将某个节点的槽指派信息通过消息发送给其它信息时，程序只需要将相应节点的 clusterNode.slots 数组整个发送过去即可</li>
</ul>
<p><strong>CLUSTER ADDSLOTS 命令的实现</strong></p>
<p>伪代码实现：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">def</span> CLUSTER_ADDSLOTS(*all_input_slots):
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f"># 遍历所有输入槽，检查是否未指派</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> i in all_input_slots:
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f"># 如果有一个已经指派了，就返回错误，并终止命令</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> clusterState.slots[i]!=NULL:
</span></span><span style="display:flex;"><span>            reply_error()
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f"># 都是未指派的</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> i in all_input_slots:
</span></span><span style="display:flex;"><span>        clusterState.slots[i]=clusterState.myself
</span></span><span style="display:flex;"><span>        setSlotBit(clusterState.myself.slots,i)
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="在集群中执行命令">在集群中执行命令<a hidden class="anchor" aria-hidden="true" href="#在集群中执行命令">#</a></h2>
<p>在数据库的 16384个槽都进行了指派后，集群就会进行上线状态，这时候客户端就可以向集群中的节点发送数据命令了</p>
<p>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，如果这个槽正好就指派给了当前节点，那么节点直接执行这个命令；如果没有指派给当前节点，那么就会返回一个 MOVED 错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令</p>
<p><strong>计算键属于哪个槽</strong></p>
<p>伪代码实现：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">def</span> slot_number(key):
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> CYC16(key) &amp; <span style="color:#ff0;font-weight:bold">16383</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用 CYC16计算key的 CYC-16 校验和</p>
<p>对于命令<code>CLUSTER KEYSLOT &lt;key&gt;</code>，可以查看给定键属于哪个槽：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>redis&gt; CLUSTER KEYSLOT <span style="color:#0ff;font-weight:bold">&#34;date&#34;</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2022</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>判断槽是否由当前节点负责处理</strong></p>
<p>在计算出键所属的槽i后，节点检查自己的 clusterState.slots 数组中的i项，判断其是否由自己负责</p>
<p>如果是，就自己处理，反之就根据指针指向的 clusterNode结构所记录的IP和端口，向客户端返回 MOVED 错误</p>
<p><strong>MOVED 错误</strong></p>
<p>当节点发现该键并非自己处理时，就会向客户端返回一个 MOVED 错误，指引客户端转向至正在负责槽的节点。</p>
<p>MOVED 错误格式为：<code>MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</code></p>
<p>如：<code>MOVED 10086 127.0.0.1:7002</code></p>
<blockquote>
<p>每次切换客户端不会造成开销？</p>
</blockquote>
<p>一个集群客户端通常会与集群中的多个节点创建套接字连接，所以实际上切换客户端，只是换一个套接字来发送命令。如果尚未连接，创建连接即可</p>
<p>注意：集群模式下的 redis-cli 客户端在接收 MOVED 错误时，会自动切换，再打印出日志。只有在单机模式下，会将MOVED 错误打印出来，因为它不知道MOVED错误是什么</p>
<p><strong>节点数据库的实现</strong></p>
<p>节点对过期键的保存跟单机一样</p>
<p>节点和单机在数据库方面的一个区别是，节点只能用0号数据库</p>
<p>另外，除了将键值对保存在数据库里面之外，节点还会用 clusterState结构中的 slots_to_keys 跳跃表来保存槽和键之间的关系：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">struct</span> clusterState{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    
</span></span><span style="display:flex;"><span>    zskiplist *slots_to_keys;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}clusterState;
</span></span></code></pre></td></tr></table>
</div>
</div><p>slots_to_keys 跳跃表每个节点的分值（score）都是一个编号，每个节点的成员都是一个数据库键</p>
<p>那么，通过 slots_to_keys 跳跃表中记录的各个数据库键所属槽，就能方便对某个或某些槽的所有数据库键进行操作，如：<code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code>返回最多count个属于槽slot的数据库键</p>
<h2 id="重新分片">重新分片<a hidden class="anchor" aria-hidden="true" href="#重新分片">#</a></h2>
<p>重新分片：将任意数量个已经分派给某个节点的槽，分配给另一个节点，并且相关槽所属的键值对也会被移动到另一个节点</p>
<p>重新分片可为在线进行，并且在重新分配过程中，集群不用下线，对应的节点也可以继续处理命令请求</p>
<p><strong>重新分片的实现原理</strong></p>
<p>由 Redis 的集群管理软件 redis-trib 负责执行，它通过向源节点和目标节点发送命令来重新分片操作</p>
<p>对集群的单个槽 slot 进行重新分片的操作如下：</p>
<ol>
<li>对目标节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code> 命令，让目标节点准备好从源节点导入（import）属于槽 slot 的键值对</li>
<li>对源节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code>命令，让源节点准备好将属于槽 slot 的键值对迁移（migrate）至目标节点</li>
<li>向源节点发送<code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code>命令，获取最多 count个属于槽 slot 的键值对的键名</li>
<li>将步骤3获取的所有键名，遍历，并将每一个都向源节点发送一个<code>MIGRATE &lt;target_ip&gt; &lt;target_port&gt; &lt;key_name&gt; 0 &lt;timeout&gt;</code>命令，即将被选中的键<strong>原子地</strong>从源迁移至目标</li>
<li>重复34步骤，直到所有键都被迁移</li>
<li>redis-trib 向集群中的任意一个节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;targer_id&gt;</code>命令，即将槽 slot 指派给了目标节点，然后再发送给整个集群</li>
</ol>
<h2 id="ask-错误">ASK 错误<a hidden class="anchor" aria-hidden="true" href="#ask-错误">#</a></h2>
<p>在进行重新分片的过程中，可能存在一部分键值对在源节点里面，而另一部分键值对则保存在目标节点里。</p>
<p>那么，当这时用户查找某个键时，如果正在迁移过程中，且正好迁移到了目标节点，就会返回一个 ASK 错误，指引客户端转向正在导入的槽，并再次发送之前想要执行的命令</p>
<img src="C:/Users/yan/AppData/Roaming/Typora/typora-user-images/image-20220408232432696.png" alt="image-20220408232432696" style="zoom:50%;" />
<p>注意：在群集下的 redis-cli 接到 ASK 错误时，也会跟 MOVED 一样，进行转向，也不会打印出错误</p>
<p><strong>CLUSTER SETSLOT IMPORTING 命令的实现</strong></p>
<p>clusterState 结构的 importing_slots_from 数组记录了当前节点正从其它节点导入的槽：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">struct</span> clusterState{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    clusterNode *importing_slots_from[<span style="color:#ff0;font-weight:bold">16384</span>];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>   
</span></span><span style="display:flex;"><span>}clusterState;
</span></span></code></pre></td></tr></table>
</div>
</div><p>在对集群重新进行分片时，会向目标节点发送：<code>CLUSTER SETSLOT &lt;i&gt; IMPORTING &lt;source_id&gt;</code></p>
<p>如：</p>
<p><code>CLUSTER SETSLOT 16198 IMPORTING 9df3...</code></p>
<p><strong>CLUSTER SETSLOT MIGRATING 命令的实现</strong></p>
<p>clusterState 结构的 migrating_slots_to 数组记录了当前节点正在迁移其它节点的槽：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">struct</span> clusterState{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    clusterNode *migrating_slots_to[<span style="color:#ff0;font-weight:bold">16384</span>];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}clusterState;
</span></span></code></pre></td></tr></table>
</div>
</div><p>在集群重新分片时，向源节点发送：<code>ClUSTER SETLOT &lt;i&gt; MIGRATING &lt;target_id&gt;</code></p>
<p><strong>ASK 错误</strong></p>
<p>当节点未查找自己数据库中的键时，会查看 clusterState.migrating_slots_to[i] ，其i是否正在进行迁移，如果时，就会返回一个对应的ASK错误</p>
<p><img loading="lazy" src="https://s2.loli.net/2022/04/08/Y74mhuvAKTyqopw.png" alt="image-20220408233845748"  />
</p>
<p>接收到ASK错误的客户端，会向目标节点发送一个ASKING 命令，之后再执行原本想执行的命令</p>
<img src="C:/Users/yan/AppData/Roaming/Typora/typora-user-images/image-20220408233958884.png" alt="image-20220408233958884" style="zoom:67%;" />
<p><strong>ASKING 命令</strong></p>
<p>ASKING 命令唯一要做的就是打开客户端的 REDIS_ASKING 标识</p>
<p>伪代码实现：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">def</span> ASKING():
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f"># 打开标识</span>
</span></span><span style="display:flex;"><span>    client.flags |= REDIS_ASKING
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f"># 向客户端返回 OK</span>
</span></span><span style="display:flex;"><span>    reply(<span style="color:#0ff;font-weight:bold">&#34;OK&#34;</span>)
</span></span></code></pre></td></tr></table>
</div>
</div><p>因为，若该节点判断没有改键时，会执行 MOVED 错误，</p>
<p>然而，如果带有 ASKING 标识，节点就会继续执行客户端发送的命令</p>
<p>注意：REDIS_ASKING 标识只能用一次，用一次之后便会被移除</p>
<h2 id="复制和故障转移">复制和故障转移<a hidden class="anchor" aria-hidden="true" href="#复制和故障转移">#</a></h2>
<p>集群中的节点也分为主节点和从节点，主节点用于处理槽，而从节点用于复制某个主节点，并在被复制的主节点下线时，代替下线的主节点继续处理命令</p>
<p><strong>设置从节点</strong></p>
<p>向一个节点发送 <code>CLUSTER REPLICATE &lt;node_id&gt;</code></p>
<p>让接收的从节点进行对主节点的复制：</p>
<ol>
<li>
<p>接收到该命令的节点首先会在自己的 clusterState.nodes 字典中找到 node_id 对应的 clusterNode 结构，并将自己的 clusterState.myself.slaveof 指针指向这个结构，以此来表示该节点正在进行主节点的复制</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> clusterNode{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">struct</span> clusterNode *slaveof;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>};
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>修改自己的 clusterNode.myself.flags 中的标识，关闭原来的 REDIS_NODE_MASTER 标识，打开 REDIS_NODE_SLAVE 标识。表示这个节点已经由主变为了从</p>
</li>
<li>
<p>节点调用复制代码，根据保存的主节点的IP和port，这里跟单机数据库一样，即相当于向从数据库发送<code>SLAVEOF &lt;master_ip&gt; &lt;master_port&gt;</code></p>
</li>
</ol>
<p>另外，一个节点成为从节点，并开始复制某一个主节点这一信息会通过消息发送给集群中的其它节点，最终集群中的所有节点都会在知道某个从正在复制某个主节点</p>
<p>集群中的所有节点都会在代表主节点的 clusterNode 结构的 slaves 属性和 numslaves 属性中记录正在复制这个主节点的名单：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> clusterNode{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 正在复制这个主节点的从节点数量
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> numslaves;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 数组，指向复制该主节点的从节点名单
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">struct</span> clusterNode **slaves;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>};
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>故障检测</strong></p>
<p>集群中的节点会定期向集群中其他节点发送 PING 信息，来检测对方是否在线，如果没有及时回复，就会将其标记为疑似下线（probable fail，PFAIL）</p>
<p>集群中的各个节点之间还会通过互发消息的方式来交换集群中各个节点的状态信息，某个节点是处于在线状态、疑似下线状态（PFAIL）、还是已下线状态（FAIL）</p>
<p>一个节点收到某个节点进入疑似下线状态时，会将节点的下线报告（failure report）添加到 clusterNode 结构的 fail_reports 链表里面：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> clusterNode{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 一个链表，记录所有其他节点对该节点的下线报告
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    list *fail_reports;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>};
</span></span></code></pre></td></tr></table>
</div>
</div><p>每个下线报告都由 clusterNodeFailReport 结构表示：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> clusterNodeFailReport{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 已下线的节点
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">struct</span> clusterNode *node;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 最后一次从 node 节点收到下线报告的时间
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 用来检测这个报告是否过期，过得太久的下线报告会被删除
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">mstime_t</span> time;
</span></span><span style="display:flex;"><span>}<span style="color:#fff;font-weight:bold">typedef</span> clusterNodeFailReport;
</span></span></code></pre></td></tr></table>
</div>
</div><p>当集群中超过半数以上负责槽的主节点都将某个主节点报告为疑似下线时，这个节点就会被标记为已下线（FAIL），并且将该节点已下线的消息广播给其他节点</p>
<p><strong>故障转移</strong></p>
<ol>
<li>已下线的主所属的从节点中，选择一个</li>
<li>对被选中的从，执行 <code>SLAVEOF no noe</code>，成为主节点</li>
<li>将已下线的主的槽指派给自己</li>
<li>向集群广播一条 PONG消息，让其他节点知道自己已由从变为了主，并接管了原本主负责的槽</li>
<li>新主节点负责处理与槽有关的命令</li>
</ol>
<p><strong>选举新的主节点</strong></p>
<p>从节点向集群发送一条广播消息 <code>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</code></p>
<p>其他都跟选举主哨兵一样，超过半数、配置纪元等</p>
<p>都是根据 Raft算法进行领头选举的</p>
<h2 id="消息">消息<a hidden class="anchor" aria-hidden="true" href="#消息">#</a></h2>
<p>集群中的各个节点都是通过发送和接收消息（message）来进行通信的。由消息头（header）和消息正文（data）组成</p>
<p>发送的消息主要有以下五种：</p>
<ul>
<li>MEET 消息：请求接收者加入到发送者当前所处的集群里</li>
<li>PING 消息：每个节点默认每隔1s就会从已知节点列表中随机选出五个节点，然后对五个节点中最久未发送过 PING 消息的节点发送 PING 消息，以此来检测被选中的节点是否在线。如果节点A最后一次收到节点B返回的PONG消息的时间，超过了当前节点A的 cluster-node-timeout 选项设置时长的一半，那么节点A也会向B发送PING，防止长期未选择到B而导致消息更新滞后</li>
<li>PONG 消息：当接收者收到发送者发来的 MEET 消息 或者 PING消息时，返回一条PONG。也可以向集群广播一条PONG，来刷新关于这个节点的认知。如：故障转移后的PONG，告知集群自己成为主节点</li>
<li>FAIL 消息：某个节点判断该节点已经为下线状态时，就会广播一条关于该节点的FAIL 消息</li>
<li>PUBLISH 消息：节点会执行这个命令，并向集群广播这个命令，让其它节点也执行</li>
</ul>
<p><strong>消息头</strong></p>
<p>记录消息发送者自身的一些信息，因为这些信息也会被消息接收者使用到</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">struct</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 消息的长度，包括了头和正文
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">uint32_t</span> totlen;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 消息的类型
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">uint16_t</span> type;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 消息正文包含的节点信息数量
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 只发送 MEET、PING、PONG三种 Gossip 协议消息时使用
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">uint16_t</span> count;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 发送者的配置纪元
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">uint64_t</span> currentEpoch;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 如果当前节点为主，这就是发送的配置纪元
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 如果为从，这就是发送者正在复制的主节点的配置纪元
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">uint64_t</span> configEpoch;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 发送者的名字(ID)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">char</span> sender[REDIS_CLUSTER_NAMELEN];
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 发送者目前的槽派信息
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> myslots[REDIS_CLUSTER_SLOTS/<span style="color:#ff0;font-weight:bold">8</span>];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 如果为从，就是主的名字
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 如果为主，这里记录的就是 REDIS_NODE_NULL_NAME
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">char</span> slaveof[REDIS_CLUSTER_NAMELEN];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 发送者的端口号
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">uint16_t</span> port;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 发送者的标识值
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">uint16_t</span> flags;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 发送者所在的集群
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> state;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 消息正文，也就是内容
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">union</span> clusterMsgData data;
</span></span><span style="display:flex;"><span>}clusterMsg;
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">union</span> clusterMsgData{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// MEET、PING、PONG 消息的正文
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 每条 MEET、PING、PONG 消息都包含两个 clusterMsgDataGossip 结构
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        clusterMsgDataGossip gossip[<span style="color:#ff0;font-weight:bold">1</span>];
</span></span><span style="display:flex;"><span>    }ping;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// FAIL 消息的正文
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">struct</span>{
</span></span><span style="display:flex;"><span>        clusterMsgDataFail about;
</span></span><span style="display:flex;"><span>    }fail;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// PUBLISH 消息的正文
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">struct</span>{
</span></span><span style="display:flex;"><span>        clusterMsgDataPublish msg;
</span></span><span style="display:flex;"><span>    }publish;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 其他消息的正文
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>};
</span></span></code></pre></td></tr></table>
</div>
</div><p>clusterMsg 结构包含了一系列本节点的信息，那么接收者，就可以根据这些信息找到对应的 clusterNode结构并对其进行更新</p>
<p><strong>MEET、PING、PONG消息的实现</strong></p>
<p>因为这三种的正文消息都使用的 clusterMsgDataGossip 结构，所以节点通过消息头的 type 属性来判断一条消息为 MEET、PING、PONG 消息</p>
<p>每次发送MEET、PING、PONG消息时，发送者都会从自己已知节点列表中随机选择两个节点（可以为主，也可以为从），并将这两个节点放到两个 clusterMsgDataGossip 结构中</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">struct</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 节点的名字
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">char</span> nodename[REDIS_CLUSTER_NAMELEN];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 最后一次向该节点发送PING信息的时间戳
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">uint32_t</span> ping_sent;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 最后一次从该节点收到 PONG 消息的时间戳
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">uint32_t</span> pong_received;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 节点的IP地址
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">char</span> ip[<span style="color:#ff0;font-weight:bold">16</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 节点的端口号
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">uint16_t</span> port;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 节点的标识值
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">uint16_t</span> flags;
</span></span><span style="display:flex;"><span>}clusterMsgDataGossip;
</span></span></code></pre></td></tr></table>
</div>
</div><p>接收者会将接收到的 clusterMsgDataGossip 结构中记录的被选中的节点进行相应的操作：</p>
<ul>
<li>如果被选中节点不存在于已知节点列表，那么说明接收者第一次接触到被选中节点，然后根据 IP和 port等信息，进行握手</li>
<li>如果存在已知的节点列表，对节点信息进行更新即可</li>
</ul>
<img src="C:/Users/yan/AppData/Roaming/Typora/typora-user-images/image-20220409152542122.png" alt="image-20220409152542122" style="zoom:50%;" />
<p><strong>FAIL消息的实现</strong></p>
<p>当节点A认为节点B已下线时，节点A就会向集群广播一条关于节点B已经下线的FAIL消息</p>
<p>在节点数量比较大的情况，单纯的使用Gossip 协议来传播节点已下线信息会给节点的信息带了一定的延迟，因为Gossip 会需要一段时间后，才会传播至整个集群，而发送 FAIL 消息，可以尽快的让集群知道，从而判断集群是否要标记为下线，或者尽快进行故障转移</p>
<p>FAIL 消息的正文由 clusterMsgDataFail 结构进行表示，这个结构只包含一个 nodename 属性，记录已下线的节点名：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">struct</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">char</span> nodename[REDIS_CLUSTER_NAMELEN];
</span></span><span style="display:flex;"><span>}clusterMsgDataFail;
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>PUBLISH 消息的实现</strong></p>
<p>当客户端向集群中的某个节点发送命令 <code>PUBLISH &lt;channel&gt; &lt;message&gt;</code></p>
<p>它不仅会向 channel 频道发送消息 message，还会广播一条 PUBLISH 消息，接收到的节点，也都会向 channel 频道发送 message 消息</p>
<p>PUBLISH 消息的正文由 clusterMsgDataPublish 结构表示</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">struct</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">uint32_t</span> channel_len;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">uint32_t</span> message_len;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 8字节是为对齐其它消息结构
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 实际的长度由保存的内容决定
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> bulk_data[<span style="color:#ff0;font-weight:bold">8</span>];
</span></span><span style="display:flex;"><span>}clusterMsgDataPublish;
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中，bulk_data 的 0~channel_len-1 字节保存的为 channel 参数；channel_len~channel_len+message_len+1 字节保存的为 message 参数</p>
<blockquote>
<p>为什么不直接向节点广播 PUBLISH 命令？</p>
</blockquote>
<p>这种做法不符合Redis集群的规则，即&quot;各节点通过发送和接收消息来进行处理通信&quot;</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/z-anshun/en/tags/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">Redis设计与实现</a></li>
      <li><a href="http://localhost:1313/z-anshun/en/tags/books/">Books</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/z-anshun/en/posts/read/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/">
    <span class="title">« Prev</span>
    <br>
    <span>独立功能的实现</span>
  </a>
  <a class="next" href="http://localhost:1313/z-anshun/en/posts/read/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/">
    <span class="title">Next »</span>
    <br>
    <span>单机数据库的实现</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 多机数据库 on x"
            href="https://x.com/intent/tweet/?text=%e5%a4%9a%e6%9c%ba%e6%95%b0%e6%8d%ae%e5%ba%93&amp;url=http%3a%2f%2flocalhost%3a1313%2fz-anshun%2fen%2fposts%2fread%2fredis%25E8%25AE%25BE%25E8%25AE%25A1%25E4%25B8%258E%25E5%25AE%259E%25E7%258E%25B0%2f%25E5%25A4%259A%25E6%259C%25BA%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%2f&amp;hashtags=redis%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0%2cBooks">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 多机数据库 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fz-anshun%2fen%2fposts%2fread%2fredis%25E8%25AE%25BE%25E8%25AE%25A1%25E4%25B8%258E%25E5%25AE%259E%25E7%258E%25B0%2f%25E5%25A4%259A%25E6%259C%25BA%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%2f&amp;title=%e5%a4%9a%e6%9c%ba%e6%95%b0%e6%8d%ae%e5%ba%93&amp;summary=%e5%a4%9a%e6%9c%ba%e6%95%b0%e6%8d%ae%e5%ba%93&amp;source=http%3a%2f%2flocalhost%3a1313%2fz-anshun%2fen%2fposts%2fread%2fredis%25E8%25AE%25BE%25E8%25AE%25A1%25E4%25B8%258E%25E5%25AE%259E%25E7%258E%25B0%2f%25E5%25A4%259A%25E6%259C%25BA%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 多机数据库 on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fz-anshun%2fen%2fposts%2fread%2fredis%25E8%25AE%25BE%25E8%25AE%25A1%25E4%25B8%258E%25E5%25AE%259E%25E7%258E%25B0%2f%25E5%25A4%259A%25E6%259C%25BA%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%2f&title=%e5%a4%9a%e6%9c%ba%e6%95%b0%e6%8d%ae%e5%ba%93">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 多机数据库 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fz-anshun%2fen%2fposts%2fread%2fredis%25E8%25AE%25BE%25E8%25AE%25A1%25E4%25B8%258E%25E5%25AE%259E%25E7%258E%25B0%2f%25E5%25A4%259A%25E6%259C%25BA%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 多机数据库 on whatsapp"
            href="https://api.whatsapp.com/send?text=%e5%a4%9a%e6%9c%ba%e6%95%b0%e6%8d%ae%e5%ba%93%20-%20http%3a%2f%2flocalhost%3a1313%2fz-anshun%2fen%2fposts%2fread%2fredis%25E8%25AE%25BE%25E8%25AE%25A1%25E4%25B8%258E%25E5%25AE%259E%25E7%258E%25B0%2f%25E5%25A4%259A%25E6%259C%25BA%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 多机数据库 on telegram"
            href="https://telegram.me/share/url?text=%e5%a4%9a%e6%9c%ba%e6%95%b0%e6%8d%ae%e5%ba%93&amp;url=http%3a%2f%2flocalhost%3a1313%2fz-anshun%2fen%2fposts%2fread%2fredis%25E8%25AE%25BE%25E8%25AE%25A1%25E4%25B8%258E%25E5%25AE%259E%25E7%258E%25B0%2f%25E5%25A4%259A%25E6%259C%25BA%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 多机数据库 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%e5%a4%9a%e6%9c%ba%e6%95%b0%e6%8d%ae%e5%ba%93&u=http%3a%2f%2flocalhost%3a1313%2fz-anshun%2fen%2fposts%2fread%2fredis%25E8%25AE%25BE%25E8%25AE%25A1%25E4%25B8%258E%25E5%25AE%259E%25E7%258E%25B0%2f%25E5%25A4%259A%25E6%259C%25BA%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://localhost:1313/z-anshun/en/">Noodles2hg的博客</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
